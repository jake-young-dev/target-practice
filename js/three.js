/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const $267b85717c4872ea$export$fa32c300549af6a5 = '130';
const $267b85717c4872ea$export$d78992bca4afbca7 = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
};
const $267b85717c4872ea$export$2e732985dd0c742e = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
};
const $267b85717c4872ea$export$9e80385aa9c806bb = 0;
const $267b85717c4872ea$export$f496fd4f7446e1b0 = 1;
const $267b85717c4872ea$export$2a91c9dc6715044b = 2;
const $267b85717c4872ea$export$a9020704c0df4578 = 3;
const $267b85717c4872ea$export$3771004bdf05d21a = 0;
const $267b85717c4872ea$export$c49a0658083527ab = 1;
const $267b85717c4872ea$export$8eff1e0d566412fd = 2;
const $267b85717c4872ea$export$b3924b4be61e1947 = 3;
const $267b85717c4872ea$export$9b320e6c690b4c3e = 0;
const $267b85717c4872ea$export$fbde0e233a2945e1 = 1;
const $267b85717c4872ea$export$6c33fb00521864ae = 2;
const $267b85717c4872ea$export$f5234beed215aca0 = 1;
const $267b85717c4872ea$export$85335ba38aba5eca = 2;
const $267b85717c4872ea$export$8dd1256cd8ee174c = 0;
const $267b85717c4872ea$export$d1aa5279bbe89448 = 1;
const $267b85717c4872ea$export$602e701c332c9ac2 = 2;
const $267b85717c4872ea$export$a1133d0ae81edc93 = 3;
const $267b85717c4872ea$export$a047c2dc4c9f9b57 = 4;
const $267b85717c4872ea$export$dc2fbdf24590e64f = 5;
const $267b85717c4872ea$export$fffd413922b3da9 = 100;
const $267b85717c4872ea$export$6336208e23eefe4e = 101;
const $267b85717c4872ea$export$8a9f14acf70743d8 = 102;
const $267b85717c4872ea$export$eab936f85fba1d02 = 103;
const $267b85717c4872ea$export$cf7d66f5a928163 = 104;
const $267b85717c4872ea$export$303cbd1773549e65 = 200;
const $267b85717c4872ea$export$fff2f5cacd5e1e79 = 201;
const $267b85717c4872ea$export$17e71dd197f07640 = 202;
const $267b85717c4872ea$export$eb4508d122da01a5 = 203;
const $267b85717c4872ea$export$5b505308e80fcb9a = 204;
const $267b85717c4872ea$export$1ce08e87b3183a15 = 205;
const $267b85717c4872ea$export$2736baa06465ec72 = 206;
const $267b85717c4872ea$export$3cb5715888305d61 = 207;
const $267b85717c4872ea$export$6c07c189c269503e = 208;
const $267b85717c4872ea$export$28d873cbf0b0b918 = 209;
const $267b85717c4872ea$export$eb0c225fa9c4c2bd = 210;
const $267b85717c4872ea$export$2bb8e8432a9b4ce8 = 0;
const $267b85717c4872ea$export$35969032108360b7 = 1;
const $267b85717c4872ea$export$83071cabd063cdbc = 2;
const $267b85717c4872ea$export$2ebf14d6a1f62fd5 = 3;
const $267b85717c4872ea$export$2414e420c55a2ff = 4;
const $267b85717c4872ea$export$34574d9c49a0e706 = 5;
const $267b85717c4872ea$export$2472b4d9932a0cd = 6;
const $267b85717c4872ea$export$ee21baa762b29e5b = 7;
const $267b85717c4872ea$export$9662028f262f1c9a = 0;
const $267b85717c4872ea$export$684c8e251d1491ba = 1;
const $267b85717c4872ea$export$ef4d269b71829b10 = 2;
const $267b85717c4872ea$export$f1d4bd8fdcc91a4e = 0;
const $267b85717c4872ea$export$cc6c2a4a6309dd6b = 1;
const $267b85717c4872ea$export$474a2b0636ec644b = 2;
const $267b85717c4872ea$export$dbe5a6b233dae689 = 3;
const $267b85717c4872ea$export$5d789c3b0a082607 = 4;
const $267b85717c4872ea$export$931972901eb25928 = 5;
const $267b85717c4872ea$export$f5c72f32487b09db = 300;
const $267b85717c4872ea$export$14b9933b43601226 = 301;
const $267b85717c4872ea$export$2be972fd003606e2 = 302;
const $267b85717c4872ea$export$2fcdd5238f6d0712 = 303;
const $267b85717c4872ea$export$84dcc0fe92473f5c = 304;
const $267b85717c4872ea$export$fb3ca8bcae285728 = 306;
const $267b85717c4872ea$export$8be195802fe0213b = 307;
const $267b85717c4872ea$export$7e167fb3a9a9867a = 1000;
const $267b85717c4872ea$export$73b90a84ed7db63c = 1001;
const $267b85717c4872ea$export$2dd54949bff6f96d = 1002;
const $267b85717c4872ea$export$f8b53649f0062e3e = 1003;
const $267b85717c4872ea$export$3d857d6c85506f73 = 1004;
const $267b85717c4872ea$export$544445f276ecbd0b = 1004;
const $267b85717c4872ea$export$977236fa8e8d0f1d = 1005;
const $267b85717c4872ea$export$c5bb8f193acb5df2 = 1005;
const $267b85717c4872ea$export$d8f3ba475551f5c1 = 1006;
const $267b85717c4872ea$export$f8cffbbc87915209 = 1007;
const $267b85717c4872ea$export$f0ac2ef90eb5eee = 1007;
const $267b85717c4872ea$export$f4f4190ac785556 = 1008;
const $267b85717c4872ea$export$e319d7bdb4b0ba0a = 1008;
const $267b85717c4872ea$export$33b8d64de134adc1 = 1009;
const $267b85717c4872ea$export$5d43c8adb415a88a = 1010;
const $267b85717c4872ea$export$6781601bc435a716 = 1011;
const $267b85717c4872ea$export$4a825e20fda0d845 = 1012;
const $267b85717c4872ea$export$c9de5d5e5b970ad5 = 1013;
const $267b85717c4872ea$export$fb395af353fbcc10 = 1014;
const $267b85717c4872ea$export$64bd8724f3c14b98 = 1015;
const $267b85717c4872ea$export$c22551bc1ee2a31d = 1016;
const $267b85717c4872ea$export$e8900341e7540f8c = 1017;
const $267b85717c4872ea$export$9690850d69171577 = 1018;
const $267b85717c4872ea$export$5da3b78b085b401d = 1019;
const $267b85717c4872ea$export$2773efb061bfa2af = 1020;
const $267b85717c4872ea$export$f38bccefee451eaa = 1021;
const $267b85717c4872ea$export$cb1f224ebfa17eab = 1022;
const $267b85717c4872ea$export$fdd3489947276d08 = 1023;
const $267b85717c4872ea$export$999f557d3c8c3681 = 1024;
const $267b85717c4872ea$export$5710a603f99ec06e = 1025;
const $267b85717c4872ea$export$1148782ca903ca69 = $267b85717c4872ea$export$fdd3489947276d08;
const $267b85717c4872ea$export$9e7c899e9114cafe = 1026;
const $267b85717c4872ea$export$4db2359531a79852 = 1027;
const $267b85717c4872ea$export$f0d5000ba8a776ea = 1028;
const $267b85717c4872ea$export$6381e580c6532e0a = 1029;
const $267b85717c4872ea$export$bb4542cbc0b0fcb4 = 1030;
const $267b85717c4872ea$export$7eaf8c0128a45eb7 = 1031;
const $267b85717c4872ea$export$6c64a16ae53bc40a = 1032;
const $267b85717c4872ea$export$d9ae70be7e9145b5 = 1033;
const $267b85717c4872ea$export$47de5e258251f386 = 33776;
const $267b85717c4872ea$export$543f9c07fd164b56 = 33777;
const $267b85717c4872ea$export$b324179473ee2beb = 33778;
const $267b85717c4872ea$export$a92d2910884454c2 = 33779;
const $267b85717c4872ea$export$2ff26eb41f992be7 = 35840;
const $267b85717c4872ea$export$3908ca1f09c8af6d = 35841;
const $267b85717c4872ea$export$ec2a0d199cb4688d = 35842;
const $267b85717c4872ea$export$1f64ee88d8c1b79d = 35843;
const $267b85717c4872ea$export$311582cb92b9f0ce = 36196;
const $267b85717c4872ea$export$54e325746e5af855 = 37492;
const $267b85717c4872ea$export$e4dd60eba5a0f51d = 37496;
const $267b85717c4872ea$export$6f46e5a91a34b69f = 37808;
const $267b85717c4872ea$export$d3526ab43ceb959d = 37809;
const $267b85717c4872ea$export$7c39c8281574170 = 37810;
const $267b85717c4872ea$export$b3da099ba6df5e6d = 37811;
const $267b85717c4872ea$export$72c0cb4bed2648f5 = 37812;
const $267b85717c4872ea$export$e7504f3f6a0d8461 = 37813;
const $267b85717c4872ea$export$b1b6a0fb53a81093 = 37814;
const $267b85717c4872ea$export$9fa5145c61535f3c = 37815;
const $267b85717c4872ea$export$767a9de51290e906 = 37816;
const $267b85717c4872ea$export$ddc7e5bbcc2a758d = 37817;
const $267b85717c4872ea$export$640456ee42ded39e = 37818;
const $267b85717c4872ea$export$b3e2613a5c8f1fb5 = 37819;
const $267b85717c4872ea$export$e17495e09dc978d1 = 37820;
const $267b85717c4872ea$export$64c98186ccc95178 = 37821;
const $267b85717c4872ea$export$2fc72d562acdcc34 = 36492;
const $267b85717c4872ea$export$e0b7643d13ca1a09 = 37840;
const $267b85717c4872ea$export$e18c9d1306bf8de9 = 37841;
const $267b85717c4872ea$export$7c38c998ae4be8e4 = 37842;
const $267b85717c4872ea$export$583370b2d6bc81b1 = 37843;
const $267b85717c4872ea$export$68ac1a00d1685202 = 37844;
const $267b85717c4872ea$export$9f354c8a98a199aa = 37845;
const $267b85717c4872ea$export$6924f47271244951 = 37846;
const $267b85717c4872ea$export$270e187d8e261ee7 = 37847;
const $267b85717c4872ea$export$b365e692b627d538 = 37848;
const $267b85717c4872ea$export$35e73e04c104281 = 37849;
const $267b85717c4872ea$export$9622f924286f6aad = 37850;
const $267b85717c4872ea$export$9d29e480b5b4e442 = 37851;
const $267b85717c4872ea$export$23e303fe9ae2bdaf = 37852;
const $267b85717c4872ea$export$2a7a787eb5fd19b0 = 37853;
const $267b85717c4872ea$export$1efb31fa1fe592ac = 2200;
const $267b85717c4872ea$export$a7f3b3240c891dfd = 2201;
const $267b85717c4872ea$export$bb892b3ce5de7091 = 2202;
const $267b85717c4872ea$export$3b97cb67250b5b78 = 2300;
const $267b85717c4872ea$export$6b1e0ecaec10d488 = 2301;
const $267b85717c4872ea$export$a21a2facc0e6ec62 = 2302;
const $267b85717c4872ea$export$d8b6fdb2f300ab40 = 2400;
const $267b85717c4872ea$export$6f63fb2e509705af = 2401;
const $267b85717c4872ea$export$ab43ac719393f08d = 2402;
const $267b85717c4872ea$export$54330578444a738c = 2500;
const $267b85717c4872ea$export$1b7d33858890b670 = 2501;
const $267b85717c4872ea$export$cb8e90c753659143 = 0;
const $267b85717c4872ea$export$f0f3630cc8566b4e = 1;
const $267b85717c4872ea$export$21415aa39778d4b9 = 2;
const $267b85717c4872ea$export$b2fb0348530d6a72 = 3000;
const $267b85717c4872ea$export$e7c1dc234bb46352 = 3001;
const $267b85717c4872ea$export$bdceb2aaf414b246 = 3007;
const $267b85717c4872ea$export$ace080f0744d1804 = 3002;
const $267b85717c4872ea$export$8aafe6ce3e58c0a1 = 3003;
const $267b85717c4872ea$export$8a6fae5b6cf692b2 = 3004;
const $267b85717c4872ea$export$75672e157e360d47 = 3005;
const $267b85717c4872ea$export$d7502b91b57a25b6 = 3006;
const $267b85717c4872ea$export$29e65aaafc98ee9a = 3200;
const $267b85717c4872ea$export$a8b736629af114b7 = 3201;
const $267b85717c4872ea$export$9c3212295f347347 = 0;
const $267b85717c4872ea$export$f4022e1d647ebcad = 1;
const $267b85717c4872ea$export$48b641232dbe4858 = 0;
const $267b85717c4872ea$export$efbda882eafb9ba9 = 7680;
const $267b85717c4872ea$export$78df02eed42d6083 = 7681;
const $267b85717c4872ea$export$fb3fd5a841746819 = 7682;
const $267b85717c4872ea$export$bc8a8c338925da18 = 7683;
const $267b85717c4872ea$export$833555cb1d498516 = 34055;
const $267b85717c4872ea$export$58a7a3be6d7f694c = 34056;
const $267b85717c4872ea$export$8374fd13c420d588 = 5386;
const $267b85717c4872ea$export$24e5087d4b115b53 = 512;
const $267b85717c4872ea$export$f715b42fd10ed5d8 = 513;
const $267b85717c4872ea$export$aea77f1b7100e05f = 514;
const $267b85717c4872ea$export$21539a7fdd9eee71 = 515;
const $267b85717c4872ea$export$59a82aac813d6e33 = 516;
const $267b85717c4872ea$export$fd2ba7a9cb2e9029 = 517;
const $267b85717c4872ea$export$e795796f72bb623a = 518;
const $267b85717c4872ea$export$895f731f76382563 = 519;
const $267b85717c4872ea$export$ec469a709bf33b5b = 35044;
const $267b85717c4872ea$export$7d5edd11bbbbcdb4 = 35048;
const $267b85717c4872ea$export$31692f16f51800d5 = 35040;
const $267b85717c4872ea$export$39a91f12388c220d = 35045;
const $267b85717c4872ea$export$4708f7be339f72a7 = 35049;
const $267b85717c4872ea$export$3f60e08205a932c2 = 35041;
const $267b85717c4872ea$export$315dc685ffe2d4f6 = 35046;
const $267b85717c4872ea$export$d8293016a3b7131 = 35050;
const $267b85717c4872ea$export$f675fe1a2a471d83 = 35042;
const $267b85717c4872ea$export$203cf62e4e920638 = '100';
const $267b85717c4872ea$export$48c70045116d2bc9 = '300 es';
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */ class $267b85717c4872ea$export$4615b0b33ebec6c8 {
    addEventListener(type, listener) {
        if (this._listeners === undefined) this._listeners = {
        };
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    }
    hasEventListener(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    }
    dispatchEvent(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i = 0, l = array.length; i < l; i++)array[i].call(this, event);
            event.target = null;
        }
    }
}
const $267b85717c4872ea$var$_lut = [];
for(let i = 0; i < 256; i++)$267b85717c4872ea$var$_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
let $267b85717c4872ea$var$_seed = 1234567;
const $267b85717c4872ea$var$DEG2RAD = Math.PI / 180;
const $267b85717c4872ea$var$RAD2DEG = 180 / Math.PI;
// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function $267b85717c4872ea$var$generateUUID() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = $267b85717c4872ea$var$_lut[d0 & 255] + $267b85717c4872ea$var$_lut[d0 >> 8 & 255] + $267b85717c4872ea$var$_lut[d0 >> 16 & 255] + $267b85717c4872ea$var$_lut[d0 >> 24 & 255] + '-' + $267b85717c4872ea$var$_lut[d1 & 255] + $267b85717c4872ea$var$_lut[d1 >> 8 & 255] + '-' + $267b85717c4872ea$var$_lut[d1 >> 16 & 15 | 64] + $267b85717c4872ea$var$_lut[d1 >> 24 & 255] + '-' + $267b85717c4872ea$var$_lut[d2 & 63 | 128] + $267b85717c4872ea$var$_lut[d2 >> 8 & 255] + '-' + $267b85717c4872ea$var$_lut[d2 >> 16 & 255] + $267b85717c4872ea$var$_lut[d2 >> 24 & 255] + $267b85717c4872ea$var$_lut[d3 & 255] + $267b85717c4872ea$var$_lut[d3 >> 8 & 255] + $267b85717c4872ea$var$_lut[d3 >> 16 & 255] + $267b85717c4872ea$var$_lut[d3 >> 24 & 255];
    // .toUpperCase() here flattens concatenated strings to save heap memory space.
    return uuid.toUpperCase();
}
function $267b85717c4872ea$var$clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}
// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function $267b85717c4872ea$var$euclideanModulo(n, m) {
    return (n % m + m) % m;
}
// Linear mapping from range <a1, a2> to range <b1, b2>
function $267b85717c4872ea$var$mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function $267b85717c4872ea$var$inverseLerp(x, y, value) {
    if (x !== y) return (value - x) / (y - x);
    else return 0;
}
// https://en.wikipedia.org/wiki/Linear_interpolation
function $267b85717c4872ea$var$lerp(x, y, t) {
    return (1 - t) * x + t * y;
}
// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function $267b85717c4872ea$var$damp(x, y, lambda, dt) {
    return $267b85717c4872ea$var$lerp(x, y, 1 - Math.exp(-lambda * dt));
}
// https://www.desmos.com/calculator/vcsjnyz7x4
function $267b85717c4872ea$var$pingpong(x, length = 1) {
    return length - Math.abs($267b85717c4872ea$var$euclideanModulo(x, length * 2) - length);
}
// http://en.wikipedia.org/wiki/Smoothstep
function $267b85717c4872ea$var$smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
}
function $267b85717c4872ea$var$smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
}
// Random integer from <low, high> interval
function $267b85717c4872ea$var$randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
}
// Random float from <low, high> interval
function $267b85717c4872ea$var$randFloat(low, high) {
    return low + Math.random() * (high - low);
}
// Random float from <-range/2, range/2> interval
function $267b85717c4872ea$var$randFloatSpread(range) {
    return range * (0.5 - Math.random());
}
// Deterministic pseudo-random float in the interval [ 0, 1 ]
function $267b85717c4872ea$var$seededRandom(s) {
    if (s !== undefined) $267b85717c4872ea$var$_seed = s % 2147483647;
    // Park-Miller algorithm
    $267b85717c4872ea$var$_seed = $267b85717c4872ea$var$_seed * 16807 % 2147483647;
    return ($267b85717c4872ea$var$_seed - 1) / 2147483646;
}
function $267b85717c4872ea$var$degToRad(degrees) {
    return degrees * $267b85717c4872ea$var$DEG2RAD;
}
function $267b85717c4872ea$var$radToDeg(radians) {
    return radians * $267b85717c4872ea$var$RAD2DEG;
}
function $267b85717c4872ea$var$isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
}
function $267b85717c4872ea$var$ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function $267b85717c4872ea$var$floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function $267b85717c4872ea$var$setQuaternionFromProperEuler(q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);
    switch(order){
        case 'XYX':
            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
            break;
        case 'YZY':
            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
            break;
        case 'ZXZ':
            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
            break;
        case 'XZX':
            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
            break;
        case 'YXY':
            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
            break;
        case 'ZYZ':
            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
            break;
        default:
            console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
}
var $267b85717c4872ea$export$4f170baab2cf9610 = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    DEG2RAD: $267b85717c4872ea$var$DEG2RAD,
    RAD2DEG: $267b85717c4872ea$var$RAD2DEG,
    generateUUID: $267b85717c4872ea$var$generateUUID,
    clamp: $267b85717c4872ea$var$clamp,
    euclideanModulo: $267b85717c4872ea$var$euclideanModulo,
    mapLinear: $267b85717c4872ea$var$mapLinear,
    inverseLerp: $267b85717c4872ea$var$inverseLerp,
    lerp: $267b85717c4872ea$var$lerp,
    damp: $267b85717c4872ea$var$damp,
    pingpong: $267b85717c4872ea$var$pingpong,
    smoothstep: $267b85717c4872ea$var$smoothstep,
    smootherstep: $267b85717c4872ea$var$smootherstep,
    randInt: $267b85717c4872ea$var$randInt,
    randFloat: $267b85717c4872ea$var$randFloat,
    randFloatSpread: $267b85717c4872ea$var$randFloatSpread,
    seededRandom: $267b85717c4872ea$var$seededRandom,
    degToRad: $267b85717c4872ea$var$degToRad,
    radToDeg: $267b85717c4872ea$var$radToDeg,
    isPowerOfTwo: $267b85717c4872ea$var$isPowerOfTwo,
    ceilPowerOfTwo: $267b85717c4872ea$var$ceilPowerOfTwo,
    floorPowerOfTwo: $267b85717c4872ea$var$floorPowerOfTwo,
    setQuaternionFromProperEuler: $267b85717c4872ea$var$setQuaternionFromProperEuler
});
class $267b85717c4872ea$export$95d9e1e745cc7977 {
    constructor(x1 = 0, y1 = 0){
        this.x = x1;
        this.y = y1;
    }
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x2 = this.x, y2 = this.y;
        const e = m.elements;
        this.x = e[0] * x2 + e[3] * y2 + e[6];
        this.y = e[1] * x2 + e[4] * y2 + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x2 = this.x - center.x;
        const y2 = this.y - center.y;
        this.x = x2 * c - y2 * s + center.x;
        this.y = x2 * s + y2 * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
}
$267b85717c4872ea$export$95d9e1e745cc7977.prototype.isVector2 = true;
class $267b85717c4872ea$export$6b1dbb040148d435 {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i1 = te[8];
        return a * e * i1 - a * f * h - b * d * i1 + b * f * g + c * d * h - c * e * g;
    }
    invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp;
        const m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i1 = 0; i1 < 9; i1++){
            if (te[i1] !== me[i1]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i1 = 0; i1 < 9; i1++)this.elements[i1] = array[i1 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
}
$267b85717c4872ea$export$6b1dbb040148d435.prototype.isMatrix3 = true;
let $267b85717c4872ea$var$_canvas;
class $267b85717c4872ea$export$efc8126a946586b9 {
    static getDataURL(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if ($267b85717c4872ea$var$_canvas === undefined) $267b85717c4872ea$var$_canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            $267b85717c4872ea$var$_canvas.width = image.width;
            $267b85717c4872ea$var$_canvas.height = image.height;
            const context = $267b85717c4872ea$var$_canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = $267b85717c4872ea$var$_canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
            console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
            return canvas.toDataURL('image/jpeg', 0.6);
        } else return canvas.toDataURL('image/png');
    }
}
let $267b85717c4872ea$var$textureId = 0;
class $267b85717c4872ea$export$1cad442f1a6e549f extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(image = $267b85717c4872ea$export$1cad442f1a6e549f.DEFAULT_IMAGE, mapping = $267b85717c4872ea$export$1cad442f1a6e549f.DEFAULT_MAPPING, wrapS = $267b85717c4872ea$export$73b90a84ed7db63c, wrapT = $267b85717c4872ea$export$73b90a84ed7db63c, magFilter = $267b85717c4872ea$export$d8f3ba475551f5c1, minFilter = $267b85717c4872ea$export$f4f4190ac785556, format = $267b85717c4872ea$export$fdd3489947276d08, type8 = $267b85717c4872ea$export$33b8d64de134adc1, anisotropy = 1, encoding = $267b85717c4872ea$export$b2fb0348530d6a72){
        super();
        Object.defineProperty(this, 'id', {
            value: $267b85717c4872ea$var$textureId++
        });
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.name = '';
        this.image = image;
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type8;
        this.offset = new $267b85717c4872ea$export$95d9e1e745cc7977(0, 0);
        this.repeat = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.center = new $267b85717c4872ea$export$95d9e1e745cc7977(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new $267b85717c4872ea$export$6b1dbb040148d435();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding;
        this.version = 0;
        this.onUpdate = null;
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    }
    toJSON(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            const image1 = this.image;
            if (image1.uuid === undefined) image1.uuid = $267b85717c4872ea$var$generateUUID(); // UGH
            if (!isRootObject && meta.images[image1.uuid] === undefined) {
                let url;
                if (Array.isArray(image1)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(let i1 = 0, l = image1.length; i1 < l; i1++)// check cube texture with data textures
                    if (image1[i1].isDataTexture) url.push($267b85717c4872ea$var$serializeImage(image1[i1].image));
                    else url.push($267b85717c4872ea$var$serializeImage(image1[i1]));
                } else // process single image
                url = $267b85717c4872ea$var$serializeImage(image1);
                meta.images[image1.uuid] = {
                    uuid: image1.uuid,
                    url: url
                };
            }
            output.image = image1.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
    transformUv(uv) {
        if (this.mapping !== $267b85717c4872ea$export$f5c72f32487b09db) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case $267b85717c4872ea$export$7e167fb3a9a9867a:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case $267b85717c4872ea$export$73b90a84ed7db63c:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case $267b85717c4872ea$export$2dd54949bff6f96d:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case $267b85717c4872ea$export$7e167fb3a9a9867a:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case $267b85717c4872ea$export$73b90a84ed7db63c:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case $267b85717c4872ea$export$2dd54949bff6f96d:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
}
$267b85717c4872ea$export$1cad442f1a6e549f.DEFAULT_IMAGE = undefined;
$267b85717c4872ea$export$1cad442f1a6e549f.DEFAULT_MAPPING = $267b85717c4872ea$export$f5c72f32487b09db;
$267b85717c4872ea$export$1cad442f1a6e549f.prototype.isTexture = true;
function $267b85717c4872ea$var$serializeImage(image1) {
    if (typeof HTMLImageElement !== 'undefined' && image1 instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image1 instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image1 instanceof ImageBitmap) // default images
    return $267b85717c4872ea$export$efc8126a946586b9.getDataURL(image1);
    else {
        if (image1.data) // images of DataTexture
        return {
            data: Array.prototype.slice.call(image1.data),
            width: image1.width,
            height: image1.height,
            type: image1.data.constructor.name
        };
        else {
            console.warn('THREE.Texture: Unable to serialize Texture.');
            return {
            };
        }
    }
}
class $267b85717c4872ea$export$14dfcb76afe97063 {
    constructor(x2 = 0, y2 = 0, z1 = 0, w1 = 1){
        this.x = x2;
        this.y = y2;
        this.z = z1;
        this.w = w1;
    }
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x3 = this.x, y3 = this.y, z2 = this.z, w2 = this.w;
        const e = m.elements;
        this.x = e[0] * x3 + e[4] * y3 + e[8] * z2 + e[12] * w2;
        this.y = e[1] * x3 + e[5] * y3 + e[9] * z2 + e[13] * w2;
        this.z = e[2] * x3 + e[6] * y3 + e[10] * z2 + e[14] * w2;
        this.w = e[3] * x3 + e[7] * y3 + e[11] * z2 + e[15] * w2;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x3, y3, z2; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x3 = 0;
                    y3 = 0.707106781;
                    z2 = 0.707106781;
                } else {
                    x3 = Math.sqrt(xx);
                    y3 = xy / x3;
                    z2 = xz / x3;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x3 = 0.707106781;
                    y3 = 0;
                    z2 = 0.707106781;
                } else {
                    y3 = Math.sqrt(yy);
                    x3 = xy / y3;
                    z2 = yz / y3;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x3 = 0.707106781;
                y3 = 0.707106781;
                z2 = 0;
            } else {
                z2 = Math.sqrt(zz);
                x3 = xz / z2;
                y3 = yz / z2;
            }
            this.set(x3, y3, z2, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
}
$267b85717c4872ea$export$14dfcb76afe97063.prototype.isVector4 = true;
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/ class $267b85717c4872ea$export$aef5a065c75d61ea extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(width1, height1, options4 = {
    }){
        super();
        this.width = width1;
        this.height = height1;
        this.depth = 1;
        this.scissor = new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, width1, height1);
        this.scissorTest = false;
        this.viewport = new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, width1, height1);
        this.texture = new $267b85717c4872ea$export$1cad442f1a6e549f(undefined, options4.mapping, options4.wrapS, options4.wrapT, options4.magFilter, options4.minFilter, options4.format, options4.type, options4.anisotropy, options4.encoding);
        this.texture.image = {
            width: width1,
            height: height1,
            depth: 1
        };
        this.texture.generateMipmaps = options4.generateMipmaps !== undefined ? options4.generateMipmaps : false;
        this.texture.minFilter = options4.minFilter !== undefined ? options4.minFilter : $267b85717c4872ea$export$d8f3ba475551f5c1;
        this.depthBuffer = options4.depthBuffer !== undefined ? options4.depthBuffer : true;
        this.stencilBuffer = options4.stencilBuffer !== undefined ? options4.stencilBuffer : false;
        this.depthTexture = options4.depthTexture !== undefined ? options4.depthTexture : null;
    }
    setTexture(texture) {
        texture.image = {
            width: this.width,
            height: this.height,
            depth: this.depth
        };
        this.texture = texture;
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.texture.image.depth = depth;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.texture.image = {
            ...this.texture.image
        }; // See #20328.
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
$267b85717c4872ea$export$aef5a065c75d61ea.prototype.isWebGLRenderTarget = true;
class $267b85717c4872ea$export$b53c271ab0be54d4 extends $267b85717c4872ea$export$aef5a065c75d61ea {
    constructor(width2, height2, count1){
        super(width2, height2);
        const texture1 = this.texture;
        this.texture = [];
        for(let i1 = 0; i1 < count1; i1++)this.texture[i1] = texture1.clone();
    }
    setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
            this.width = width;
            this.height = height;
            this.depth = depth;
            for(let i2 = 0, il = this.texture.length; i2 < il; i2++){
                this.texture[i2].image.width = width;
                this.texture[i2].image.height = height;
                this.texture[i2].image.depth = depth;
            }
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
        return this;
    }
    copy(source) {
        this.dispose();
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.set(0, 0, this.width, this.height);
        this.scissor.set(0, 0, this.width, this.height);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        this.texture.length = 0;
        for(let i2 = 0, il = source.texture.length; i2 < il; i2++)this.texture[i2] = source.texture[i2].clone();
        return this;
    }
}
$267b85717c4872ea$export$b53c271ab0be54d4.prototype.isWebGLMultipleRenderTargets = true;
class $267b85717c4872ea$export$2d31aa8271a06773 extends $267b85717c4872ea$export$aef5a065c75d61ea {
    constructor(width3, height3, options1){
        super(width3, height3, options1);
        this.samples = 4;
    }
    copy(source) {
        super.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
}
$267b85717c4872ea$export$2d31aa8271a06773.prototype.isWebGLMultisampleRenderTarget = true;
class $267b85717c4872ea$export$8756178d528e80f7 {
    constructor(x3 = 0, y3 = 0, z2 = 0, w2 = 1){
        this._x = x3;
        this._y = y3;
        this._z = z2;
        this._w = w2;
    }
    static slerp(qa, qb, qm, t) {
        console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
        return qm.slerpQuaternions(qa, qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x11 = src1[srcOffset1 + 0], y11 = src1[srcOffset1 + 1], z11 = src1[srcOffset1 + 2], w11 = src1[srcOffset1 + 3];
        if (t === 0) {
            dst[dstOffset + 0] = x0;
            dst[dstOffset + 1] = y0;
            dst[dstOffset + 2] = z0;
            dst[dstOffset + 3] = w0;
            return;
        }
        if (t === 1) {
            dst[dstOffset + 0] = x11;
            dst[dstOffset + 1] = y11;
            dst[dstOffset + 2] = z11;
            dst[dstOffset + 3] = w11;
            return;
        }
        if (w0 !== w11 || x0 !== x11 || y0 !== y11 || z0 !== z11) {
            let s = 1 - t;
            const cos = x0 * x11 + y0 * y11 + z0 * z11 + w0 * w11, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
            // Skip the Slerp for tiny steps to avoid numeric problems:
            if (sqrSin > Number.EPSILON) {
                const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
                s = Math.sin(s * len) / sin;
                t = Math.sin(t * len) / sin;
            }
            const tDir = t * dir;
            x0 = x0 * s + x11 * tDir;
            y0 = y0 * s + y11 * tDir;
            z0 = z0 * s + z11 * tDir;
            w0 = w0 * s + w11 * tDir;
            // Normalize in case we just did a lerp:
            if (s === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x11 = src1[srcOffset1];
        const y11 = src1[srcOffset1 + 1];
        const z11 = src1[srcOffset1 + 2];
        const w11 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w11 + w0 * x11 + y0 * z11 - z0 * y11;
        dst[dstOffset + 1] = y0 * w11 + w0 * y11 + z0 * x11 - x0 * z11;
        dst[dstOffset + 2] = z0 * w11 + w0 * z11 + x0 * y11 - y0 * x11;
        dst[dstOffset + 3] = w0 * w11 - x0 * x11 - y0 * y11 - z0 * z11;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x4 = euler._x, y4 = euler._y, z3 = euler._z, order = euler._order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x4 / 2);
        const c2 = cos(y4 / 2);
        const c3 = cos(z3 / 2);
        const s1 = sin(x4 / 2);
        const s2 = sin(y4 / 2);
        const s3 = sin(z3 / 2);
        switch(order){
            case 'XYZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'YZX':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'XZY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        let r = vFrom.dot(vTo) + 1;
        if (r < Number.EPSILON) {
            // vFrom and vTo point in opposite directions
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs($267b85717c4872ea$var$clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x4 = this._x, y4 = this._y, z3 = this._z, w3 = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w3 * qb._w + x4 * qb._x + y4 * qb._y + z3 * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w3;
            this._x = x4;
            this._y = y4;
            this._z = z3;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w3 + t * this._w;
            this._x = s * x4 + t * this._x;
            this._y = s * y4 + t * this._y;
            this._z = s * z3 + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w3 * ratioA + this._w * ratioB;
        this._x = x4 * ratioA + this._x * ratioB;
        this._y = y4 * ratioA + this._y * ratioB;
        this._z = z3 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    slerpQuaternions(qa, qb, t) {
        this.copy(qa).slerp(qb, t);
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
}
$267b85717c4872ea$export$8756178d528e80f7.prototype.isQuaternion = true;
class $267b85717c4872ea$export$cbf9fa4ea4e2e3d2 {
    constructor(x4 = 0, y4 = 0, z3 = 0){
        this.x = x4;
        this.y = y4;
        this.z = z3;
    }
    set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion($267b85717c4872ea$var$_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion($267b85717c4872ea$var$_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x5 + e[3] * y5 + e[6] * z4;
        this.y = e[1] * x5 + e[4] * y5 + e[7] * z4;
        this.z = e[2] * x5 + e[5] * y5 + e[8] * z4;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        const w3 = 1 / (e[3] * x5 + e[7] * y5 + e[11] * z4 + e[15]);
        this.x = (e[0] * x5 + e[4] * y5 + e[8] * z4 + e[12]) * w3;
        this.y = (e[1] * x5 + e[5] * y5 + e[9] * z4 + e[13]) * w3;
        this.z = (e[2] * x5 + e[6] * y5 + e[10] * z4 + e[14]) * w3;
        return this;
    }
    applyQuaternion(q) {
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x5 + qy * z4 - qz * y5;
        const iy = qw * y5 + qz * x5 - qx * z4;
        const iz = qw * z4 + qx * y5 - qy * x5;
        const iw = -qx * x5 - qy * y5 - qz * z4;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x5 = this.x, y5 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x5 + e[4] * y5 + e[8] * z4;
        this.y = e[1] * x5 + e[5] * y5 + e[9] * z4;
        this.z = e[2] * x5 + e[6] * y5 + e[10] * z4;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        $267b85717c4872ea$var$_vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub($267b85717c4872ea$var$_vector$c);
    }
    reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub($267b85717c4872ea$var$_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos($267b85717c4872ea$var$clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
}
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.isVector3 = true;
const $267b85717c4872ea$var$_vector$c = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_quaternion$4 = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
class $267b85717c4872ea$export$c99edadde72ee706 {
    constructor(min1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(Infinity, Infinity, Infinity), max1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-Infinity, -Infinity, -Infinity)){
        this.min = min1;
        this.max = max1;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i2 = 0, l = array.length; i2 < l; i2 += 3){
            const x5 = array[i2];
            const y5 = array[i2 + 1];
            const z4 = array[i2 + 2];
            if (x5 < minX) minX = x5;
            if (y5 < minY) minY = y5;
            if (z4 < minZ) minZ = z4;
            if (x5 > maxX) maxX = x5;
            if (y5 > maxY) maxY = y5;
            if (z4 > maxZ) maxZ = z4;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i2 = 0, l = attribute.count; i2 < l; i2++){
            const x5 = attribute.getX(i2);
            const y5 = attribute.getY(i2);
            const z4 = attribute.getZ(i2);
            if (x5 < minX) minX = x5;
            if (y5 < minY) minY = y5;
            if (z4 < minZ) minZ = z4;
            if (x5 > maxX) maxX = x5;
            if (y5 > maxY) maxY = y5;
            if (z4 > maxZ) maxZ = z4;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i2 = 0, il = points.length; i2 < il; i2++)this.expandByPoint(points[i2]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = $267b85717c4872ea$var$_vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    setFromObject(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    expandByObject(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            $267b85717c4872ea$var$_box$3.copy(geometry.boundingBox);
            $267b85717c4872ea$var$_box$3.applyMatrix4(object.matrixWorld);
            this.union($267b85717c4872ea$var$_box$3);
        }
        const children = object.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)this.expandByObject(children[i2]);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, $267b85717c4872ea$var$_vector$b);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return $267b85717c4872ea$var$_vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min2, max2;
        if (plane.normal.x > 0) {
            min2 = plane.normal.x * this.min.x;
            max2 = plane.normal.x * this.max.x;
        } else {
            min2 = plane.normal.x * this.max.x;
            max2 = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min2 += plane.normal.y * this.min.y;
            max2 += plane.normal.y * this.max.y;
        } else {
            min2 += plane.normal.y * this.max.y;
            max2 += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min2 += plane.normal.z * this.min.z;
            max2 += plane.normal.z * this.max.z;
        } else {
            min2 += plane.normal.z * this.max.z;
            max2 += plane.normal.z * this.min.z;
        }
        return min2 <= -plane.constant && max2 >= -plane.constant;
    }
    intersectsTriangle(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter($267b85717c4872ea$var$_center);
        $267b85717c4872ea$var$_extents.subVectors(this.max, $267b85717c4872ea$var$_center);
        // translate triangle to aabb origin
        $267b85717c4872ea$var$_v0$2.subVectors(triangle.a, $267b85717c4872ea$var$_center);
        $267b85717c4872ea$var$_v1$7.subVectors(triangle.b, $267b85717c4872ea$var$_center);
        $267b85717c4872ea$var$_v2$3.subVectors(triangle.c, $267b85717c4872ea$var$_center);
        // compute edge vectors for triangle
        $267b85717c4872ea$var$_f0.subVectors($267b85717c4872ea$var$_v1$7, $267b85717c4872ea$var$_v0$2);
        $267b85717c4872ea$var$_f1.subVectors($267b85717c4872ea$var$_v2$3, $267b85717c4872ea$var$_v1$7);
        $267b85717c4872ea$var$_f2.subVectors($267b85717c4872ea$var$_v0$2, $267b85717c4872ea$var$_v2$3);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -$267b85717c4872ea$var$_f0.z,
            $267b85717c4872ea$var$_f0.y,
            0,
            -$267b85717c4872ea$var$_f1.z,
            $267b85717c4872ea$var$_f1.y,
            0,
            -$267b85717c4872ea$var$_f2.z,
            $267b85717c4872ea$var$_f2.y,
            $267b85717c4872ea$var$_f0.z,
            0,
            -$267b85717c4872ea$var$_f0.x,
            $267b85717c4872ea$var$_f1.z,
            0,
            -$267b85717c4872ea$var$_f1.x,
            $267b85717c4872ea$var$_f2.z,
            0,
            -$267b85717c4872ea$var$_f2.x,
            -$267b85717c4872ea$var$_f0.y,
            $267b85717c4872ea$var$_f0.x,
            0,
            -$267b85717c4872ea$var$_f1.y,
            $267b85717c4872ea$var$_f1.x,
            0,
            -$267b85717c4872ea$var$_f2.y,
            $267b85717c4872ea$var$_f2.x,
            0
        ];
        if (!$267b85717c4872ea$var$satForAxes(axes, $267b85717c4872ea$var$_v0$2, $267b85717c4872ea$var$_v1$7, $267b85717c4872ea$var$_v2$3, $267b85717c4872ea$var$_extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!$267b85717c4872ea$var$satForAxes(axes, $267b85717c4872ea$var$_v0$2, $267b85717c4872ea$var$_v1$7, $267b85717c4872ea$var$_v2$3, $267b85717c4872ea$var$_extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        $267b85717c4872ea$var$_triangleNormal.crossVectors($267b85717c4872ea$var$_f0, $267b85717c4872ea$var$_f1);
        axes = [
            $267b85717c4872ea$var$_triangleNormal.x,
            $267b85717c4872ea$var$_triangleNormal.y,
            $267b85717c4872ea$var$_triangleNormal.z
        ];
        return $267b85717c4872ea$var$satForAxes(axes, $267b85717c4872ea$var$_v0$2, $267b85717c4872ea$var$_v1$7, $267b85717c4872ea$var$_v2$3, $267b85717c4872ea$var$_extents);
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = $267b85717c4872ea$var$_vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize($267b85717c4872ea$var$_vector$b).length() * 0.5;
        return target;
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    applyMatrix4(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        $267b85717c4872ea$var$_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        $267b85717c4872ea$var$_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        $267b85717c4872ea$var$_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        $267b85717c4872ea$var$_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        $267b85717c4872ea$var$_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        $267b85717c4872ea$var$_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        $267b85717c4872ea$var$_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        $267b85717c4872ea$var$_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints($267b85717c4872ea$var$_points);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
$267b85717c4872ea$export$c99edadde72ee706.prototype.isBox3 = true;
const $267b85717c4872ea$var$_points = [
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()
];
const $267b85717c4872ea$var$_vector$b = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_box$3 = /*@__PURE__*/ new $267b85717c4872ea$export$c99edadde72ee706();
// triangle centered vertices
const $267b85717c4872ea$var$_v0$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v1$7 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v2$3 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
// triangle edge vectors
const $267b85717c4872ea$var$_f0 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_f1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_f2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_center = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_extents = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_triangleNormal = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_testAxis = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
function $267b85717c4872ea$var$satForAxes(axes, v0, v1, v2, extents) {
    for(let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3){
        $267b85717c4872ea$var$_testAxis.fromArray(axes, i2);
        // project the aabb onto the seperating axis
        const r = extents.x * Math.abs($267b85717c4872ea$var$_testAxis.x) + extents.y * Math.abs($267b85717c4872ea$var$_testAxis.y) + extents.z * Math.abs($267b85717c4872ea$var$_testAxis.z);
        // project all 3 vertices of the triangle onto the seperating axis
        const p0 = v0.dot($267b85717c4872ea$var$_testAxis);
        const p1 = v1.dot($267b85717c4872ea$var$_testAxis);
        const p2 = v2.dot($267b85717c4872ea$var$_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is seperating and we can exit
        return false;
    }
    return true;
}
const $267b85717c4872ea$var$_box$2 = /*@__PURE__*/ new $267b85717c4872ea$export$c99edadde72ee706();
const $267b85717c4872ea$var$_v1$6 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_toFarthestPoint = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_toPoint = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$48b052fa5734fd42 {
    constructor(center1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), radius1 = -1){
        this.center = center1;
        this.radius = radius1;
    }
    set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    }
    setFromPoints(points, optionalCenter) {
        const center2 = this.center;
        if (optionalCenter !== undefined) center2.copy(optionalCenter);
        else $267b85717c4872ea$var$_box$2.setFromPoints(points).getCenter(center2);
        let maxRadiusSq = 0;
        for(let i2 = 0, il = points.length; i2 < il; i2++)maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared(points[i2]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    }
    copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    }
    containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
        return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    }
    getBoundingBox(target) {
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    }
    applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    }
    translate(offset) {
        this.center.add(offset);
        return this;
    }
    expandByPoint(point) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
        $267b85717c4872ea$var$_toPoint.subVectors(point, this.center);
        const lengthSq = $267b85717c4872ea$var$_toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
            const length = Math.sqrt(lengthSq);
            const missingRadiusHalf = (length - this.radius) * 0.5;
            // Nudge this sphere towards the target point. Add half the missing distance to radius,
            // and the other half to position. This gives a tighter enclosure, instead of if
            // the whole missing distance were just added to radius.
            this.center.add($267b85717c4872ea$var$_toPoint.multiplyScalar(missingRadiusHalf / length));
            this.radius += missingRadiusHalf;
        }
        return this;
    }
    union(sphere) {
        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
        // To enclose another sphere into this sphere, we only need to enclose two points:
        // 1) Enclose the farthest point on the other sphere into this sphere.
        // 2) Enclose the opposite point of the farthest point into this sphere.
        $267b85717c4872ea$var$_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        this.expandByPoint($267b85717c4872ea$var$_v1$6.copy(sphere.center).add($267b85717c4872ea$var$_toFarthestPoint));
        this.expandByPoint($267b85717c4872ea$var$_v1$6.copy(sphere.center).sub($267b85717c4872ea$var$_toFarthestPoint));
        return this;
    }
    equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $267b85717c4872ea$var$_vector$a = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_segCenter = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_segDir = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_diff = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_edge1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_edge2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_normal$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$c0bfd01633e732a2 {
    constructor(origin1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), direction1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, -1)){
        this.origin = origin1;
        this.direction = direction1;
    }
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, $267b85717c4872ea$var$_vector$a));
        return this;
    }
    closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = $267b85717c4872ea$var$_vector$a.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        $267b85717c4872ea$var$_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return $267b85717c4872ea$var$_vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        $267b85717c4872ea$var$_segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        $267b85717c4872ea$var$_segDir.copy(v1).sub(v0).normalize();
        $267b85717c4872ea$var$_diff.copy(this.origin).sub($267b85717c4872ea$var$_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot($267b85717c4872ea$var$_segDir);
        const b0 = $267b85717c4872ea$var$_diff.dot(this.direction);
        const b1 = -$267b85717c4872ea$var$_diff.dot($267b85717c4872ea$var$_segDir);
        const c = $267b85717c4872ea$var$_diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else {
                if (s1 <= -extDet) {
                    // region 4
                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                    s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                } else if (s1 <= extDet) {
                    // region 3
                    s0 = 0;
                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = s1 * (s1 + 2 * b1) + c;
                } else {
                    // region 2
                    s0 = Math.max(0, -(a01 * segExtent + b0));
                    s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy($267b85717c4872ea$var$_segDir).multiplyScalar(s1).add($267b85717c4872ea$var$_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        $267b85717c4872ea$var$_vector$a.subVectors(sphere.center, this.origin);
        const tca = $267b85717c4872ea$var$_vector$a.dot(this.direction);
        const d2 = $267b85717c4872ea$var$_vector$a.dot($267b85717c4872ea$var$_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin2 = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin2.x) * invdirx;
            tmax = (box.max.x - origin2.x) * invdirx;
        } else {
            tmin = (box.max.x - origin2.x) * invdirx;
            tmax = (box.min.x - origin2.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin2.y) * invdiry;
            tymax = (box.max.y - origin2.y) * invdiry;
        } else {
            tymin = (box.max.y - origin2.y) * invdiry;
            tymax = (box.min.y - origin2.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin2.z) * invdirz;
            tzmax = (box.max.z - origin2.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin2.z) * invdirz;
            tzmax = (box.min.z - origin2.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, $267b85717c4872ea$var$_vector$a) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        $267b85717c4872ea$var$_edge1.subVectors(b, a);
        $267b85717c4872ea$var$_edge2.subVectors(c, a);
        $267b85717c4872ea$var$_normal$1.crossVectors($267b85717c4872ea$var$_edge1, $267b85717c4872ea$var$_edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot($267b85717c4872ea$var$_normal$1);
        let sign;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign = 1;
        } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
        } else return null;
        $267b85717c4872ea$var$_diff.subVectors(this.origin, a);
        const DdQxE2 = sign * this.direction.dot($267b85717c4872ea$var$_edge2.crossVectors($267b85717c4872ea$var$_diff, $267b85717c4872ea$var$_edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign * this.direction.dot($267b85717c4872ea$var$_edge1.cross($267b85717c4872ea$var$_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign * $267b85717c4872ea$var$_diff.dot($267b85717c4872ea$var$_normal$1);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class $267b85717c4872ea$export$960b1460cb9cd6c9 {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new $267b85717c4872ea$export$960b1460cb9cd6c9().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / $267b85717c4872ea$var$_v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / $267b85717c4872ea$var$_v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / $267b85717c4872ea$var$_v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x5 = euler.x, y5 = euler.y, z4 = euler.z;
        const a = Math.cos(x5), b = Math.sin(x5);
        const c = Math.cos(y5), d = Math.sin(y5);
        const e = Math.cos(z4), f = Math.sin(z4);
        if (euler.order === 'XYZ') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
        } else if (euler.order === 'YXZ') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
        } else if (euler.order === 'ZXY') {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            te[0] = ce - df * b;
            te[4] = -a * f;
            te[8] = de + cf * b;
            te[1] = cf + de * b;
            te[5] = a * e;
            te[9] = df - ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
        } else if (euler.order === 'ZYX') {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            te[0] = c * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
        } else if (euler.order === 'YZX') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose($267b85717c4872ea$var$_zero, q, $267b85717c4872ea$var$_one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        $267b85717c4872ea$var$_z.subVectors(eye, target);
        if ($267b85717c4872ea$var$_z.lengthSq() === 0) // eye and target are in the same position
        $267b85717c4872ea$var$_z.z = 1;
        $267b85717c4872ea$var$_z.normalize();
        $267b85717c4872ea$var$_x.crossVectors(up, $267b85717c4872ea$var$_z);
        if ($267b85717c4872ea$var$_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) $267b85717c4872ea$var$_z.x += 0.0001;
            else $267b85717c4872ea$var$_z.z += 0.0001;
            $267b85717c4872ea$var$_z.normalize();
            $267b85717c4872ea$var$_x.crossVectors(up, $267b85717c4872ea$var$_z);
        }
        $267b85717c4872ea$var$_x.normalize();
        $267b85717c4872ea$var$_y.crossVectors($267b85717c4872ea$var$_z, $267b85717c4872ea$var$_x);
        te[0] = $267b85717c4872ea$var$_x.x;
        te[4] = $267b85717c4872ea$var$_y.x;
        te[8] = $267b85717c4872ea$var$_z.x;
        te[1] = $267b85717c4872ea$var$_x.y;
        te[5] = $267b85717c4872ea$var$_y.y;
        te[9] = $267b85717c4872ea$var$_z.y;
        te[2] = $267b85717c4872ea$var$_x.z;
        te[6] = $267b85717c4872ea$var$_y.z;
        te[10] = $267b85717c4872ea$var$_z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x5 = v.x, y5 = v.y, z4 = v.z;
        te[0] *= x5;
        te[4] *= y5;
        te[8] *= z4;
        te[1] *= x5;
        te[5] *= y5;
        te[9] *= z4;
        te[2] *= x5;
        te[6] *= y5;
        te[10] *= z4;
        te[3] *= x5;
        te[7] *= y5;
        te[11] *= z4;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c;
        const x5 = axis.x, y5 = axis.y, z4 = axis.z;
        const tx = t * x5, ty = t * y5;
        this.set(tx * x5 + c, tx * y5 - s * z4, tx * z4 + s * y5, 0, tx * y5 + s * z4, ty * y5 + c, ty * z4 - s * x5, 0, tx * z4 - s * y5, ty * z4 + s * x5, t * z4 * z4 + c, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x5 = quaternion._x, y5 = quaternion._y, z4 = quaternion._z, w3 = quaternion._w;
        const x21 = x5 + x5, y21 = y5 + y5, z21 = z4 + z4;
        const xx = x5 * x21, xy = x5 * y21, xz = x5 * z21;
        const yy = y5 * y21, yz = y5 * z21, zz = z4 * z21;
        const wx = w3 * x21, wy = w3 * y21, wz = w3 * z21;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = $267b85717c4872ea$var$_v1$5.set(te[0], te[1], te[2]).length();
        const sy = $267b85717c4872ea$var$_v1$5.set(te[4], te[5], te[6]).length();
        const sz = $267b85717c4872ea$var$_v1$5.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        $267b85717c4872ea$var$_m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        $267b85717c4872ea$var$_m1$2.elements[0] *= invSX;
        $267b85717c4872ea$var$_m1$2.elements[1] *= invSX;
        $267b85717c4872ea$var$_m1$2.elements[2] *= invSX;
        $267b85717c4872ea$var$_m1$2.elements[4] *= invSY;
        $267b85717c4872ea$var$_m1$2.elements[5] *= invSY;
        $267b85717c4872ea$var$_m1$2.elements[6] *= invSY;
        $267b85717c4872ea$var$_m1$2.elements[8] *= invSZ;
        $267b85717c4872ea$var$_m1$2.elements[9] *= invSZ;
        $267b85717c4872ea$var$_m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix($267b85717c4872ea$var$_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x5 = 2 * near / (right - left);
        const y5 = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x5;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y5;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w3 = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x5 = (right + left) * w3;
        const y5 = (top + bottom) * h;
        const z4 = (far + near) * p;
        te[0] = 2 * w3;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x5;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y5;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z4;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i2 = 0; i2 < 16; i2++){
            if (te[i2] !== me[i2]) return false;
        }
        return true;
    }
    fromArray(array, offset = 0) {
        for(let i2 = 0; i2 < 16; i2++)this.elements[i2] = array[i2 + offset];
        return this;
    }
    toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
}
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.isMatrix4 = true;
const $267b85717c4872ea$var$_v1$5 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_m1$2 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_zero = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 0);
const $267b85717c4872ea$var$_one = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 1, 1);
const $267b85717c4872ea$var$_x = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_y = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_z = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_matrix$1 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_quaternion$3 = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
class $267b85717c4872ea$export$1c7119953d158aca {
    constructor(x5 = 0, y5 = 0, z4 = 0, order1 = $267b85717c4872ea$export$1c7119953d158aca.DefaultOrder){
        this._x = x5;
        this._y = y5;
        this._z = z4;
        this._order = order1;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order = this._order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order = this._order, update = true) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch(order){
            case 'XYZ':
                this._y = Math.asin($267b85717c4872ea$var$clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-$267b85717c4872ea$var$clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin($267b85717c4872ea$var$clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-$267b85717c4872ea$var$clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin($267b85717c4872ea$var$clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-$267b85717c4872ea$var$clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update === true) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        $267b85717c4872ea$var$_matrix$1.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix($267b85717c4872ea$var$_matrix$1, order, update);
    }
    setFromVector3(v, order = this._order) {
        return this.set(v.x, v.y, v.z, order);
    }
    reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston
        $267b85717c4872ea$var$_quaternion$3.setFromEuler(this);
        return this.setFromQuaternion($267b85717c4872ea$var$_quaternion$3, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
}
$267b85717c4872ea$export$1c7119953d158aca.prototype.isEuler = true;
$267b85717c4872ea$export$1c7119953d158aca.DefaultOrder = 'XYZ';
$267b85717c4872ea$export$1c7119953d158aca.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
class $267b85717c4872ea$export$89313398f0a7ef36 {
    constructor(){
        this.mask = 1;
    }
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
}
let $267b85717c4872ea$var$_object3DId = 0;
const $267b85717c4872ea$var$_v1$4 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_q1 = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
const $267b85717c4872ea$var$_m1$1 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_target = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_position$3 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_scale$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_quaternion$2 = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
const $267b85717c4872ea$var$_xAxis = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 0, 0);
const $267b85717c4872ea$var$_yAxis = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0);
const $267b85717c4872ea$var$_zAxis = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 1);
const $267b85717c4872ea$var$_addedEvent = {
    type: 'added'
};
const $267b85717c4872ea$var$_removedEvent = {
    type: 'removed'
};
class $267b85717c4872ea$export$c8ea94beaa33360 extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: $267b85717c4872ea$var$_object3DId++
        });
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.name = '';
        this.type = 'Object3D';
        this.parent = null;
        this.children = [];
        this.up = $267b85717c4872ea$export$c8ea94beaa33360.DefaultUp.clone();
        const position = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const rotation = new $267b85717c4872ea$export$1c7119953d158aca();
        const quaternion = new $267b85717c4872ea$export$8756178d528e80f7();
        const scale = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 1, 1);
        function onRotationChange() {
            quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
            rotation.setFromQuaternion(quaternion, undefined, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new $267b85717c4872ea$export$960b1460cb9cd6c9()
            },
            normalMatrix: {
                value: new $267b85717c4872ea$export$6b1dbb040148d435()
            }
        });
        this.matrix = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.matrixWorld = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.matrixAutoUpdate = $267b85717c4872ea$export$c8ea94beaa33360.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new $267b85717c4872ea$export$89313398f0a7ef36();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {
        };
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
    }
    setRotationFromAxisAngle(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    }
    setRotationFromQuaternion(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    }
    rotateOnAxis(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        $267b85717c4872ea$var$_q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply($267b85717c4872ea$var$_q1);
        return this;
    }
    rotateOnWorldAxis(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        $267b85717c4872ea$var$_q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply($267b85717c4872ea$var$_q1);
        return this;
    }
    rotateX(angle) {
        return this.rotateOnAxis($267b85717c4872ea$var$_xAxis, angle);
    }
    rotateY(angle) {
        return this.rotateOnAxis($267b85717c4872ea$var$_yAxis, angle);
    }
    rotateZ(angle) {
        return this.rotateOnAxis($267b85717c4872ea$var$_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        $267b85717c4872ea$var$_v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add($267b85717c4872ea$var$_v1$4.multiplyScalar(distance));
        return this;
    }
    translateX(distance) {
        return this.translateOnAxis($267b85717c4872ea$var$_xAxis, distance);
    }
    translateY(distance) {
        return this.translateOnAxis($267b85717c4872ea$var$_yAxis, distance);
    }
    translateZ(distance) {
        return this.translateOnAxis($267b85717c4872ea$var$_zAxis, distance);
    }
    localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
        return vector.applyMatrix4($267b85717c4872ea$var$_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x, y, z) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x.isVector3) $267b85717c4872ea$var$_target.copy(x);
        else $267b85717c4872ea$var$_target.set(x, y, z);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        $267b85717c4872ea$var$_position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) $267b85717c4872ea$var$_m1$1.lookAt($267b85717c4872ea$var$_position$3, $267b85717c4872ea$var$_target, this.up);
        else $267b85717c4872ea$var$_m1$1.lookAt($267b85717c4872ea$var$_target, $267b85717c4872ea$var$_position$3, this.up);
        this.quaternion.setFromRotationMatrix($267b85717c4872ea$var$_m1$1);
        if (parent) {
            $267b85717c4872ea$var$_m1$1.extractRotation(parent.matrixWorld);
            $267b85717c4872ea$var$_q1.setFromRotationMatrix($267b85717c4872ea$var$_m1$1);
            this.quaternion.premultiply($267b85717c4872ea$var$_q1.invert());
        }
    }
    add(object) {
        if (arguments.length > 1) {
            for(let i2 = 0; i2 < arguments.length; i2++)this.add(arguments[i2]);
            return this;
        }
        if (object === this) {
            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent($267b85717c4872ea$var$_addedEvent);
        } else console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
        return this;
    }
    remove(object) {
        if (arguments.length > 1) {
            for(let i2 = 0; i2 < arguments.length; i2++)this.remove(arguments[i2]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent($267b85717c4872ea$var$_removedEvent);
        }
        return this;
    }
    removeFromParent() {
        const parent = this.parent;
        if (parent !== null) parent.remove(this);
        return this;
    }
    clear() {
        for(let i2 = 0; i2 < this.children.length; i2++){
            const object = this.children[i2];
            object.parent = null;
            object.dispatchEvent($267b85717c4872ea$var$_removedEvent);
        }
        this.children.length = 0;
        return this;
    }
    attach(object) {
        // adds object as a child of this, while maintaining the object's world transform
        this.updateWorldMatrix(true, false);
        $267b85717c4872ea$var$_m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            $267b85717c4872ea$var$_m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4($267b85717c4872ea$var$_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
    }
    getObjectById(id) {
        return this.getObjectByProperty('id', id);
    }
    getObjectByName(name) {
        return this.getObjectByProperty('name', name);
    }
    getObjectByProperty(name, value) {
        if (this[name] === value) return this;
        for(let i2 = 0, l = this.children.length; i2 < l; i2++){
            const child = this.children[i2];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    }
    getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose($267b85717c4872ea$var$_position$3, target, $267b85717c4872ea$var$_scale$2);
        return target;
    }
    getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose($267b85717c4872ea$var$_position$3, $267b85717c4872ea$var$_quaternion$2, target);
        return target;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
        callback(this);
        const children = this.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)children[i2].traverse(callback);
    }
    traverseVisible(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)children[i2].traverseVisible(callback);
    }
    traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)children[i2].updateMatrixWorld(force);
    }
    updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i2 = 0, l = children.length; i2 < l; i2++)children[i2].updateWorldMatrix(false, true);
        }
    }
    toJSON(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {
        };
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {
                },
                materials: {
                },
                textures: {
                },
                images: {
                },
                shapes: {
                },
                skeletons: {
                },
                animations: {
                }
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        const object = {
        };
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isScene) {
            if (this.background) {
                if (this.background.isColor) object.background = this.background.toJSON();
                else if (this.background.isTexture) object.background = this.background.toJSON(meta).uuid;
            }
            if (this.environment && this.environment.isTexture) object.environment = this.environment.toJSON(meta).uuid;
        } else if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i2 = 0, l = shapes.length; i2 < l; i2++){
                    const shape = shapes[i2];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.isSkinnedMesh) {
            object.bindMode = this.bindMode;
            object.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== undefined) {
                serialize(meta.skeletons, this.skeleton);
                object.skeleton = this.skeleton.uuid;
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i2 = 0, l = this.material.length; i2 < l; i2++)uuids.push(serialize(meta.materials, this.material[i2]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i2 = 0; i2 < this.children.length; i2++)object.children.push(this.children[i2].toJSON(meta).object);
        }
        //
        if (this.animations.length > 0) {
            object.animations = [];
            for(let i2 = 0; i2 < this.animations.length; i2++){
                const animation = this.animations[i2];
                object.animations.push(serialize(meta.animations, animation));
            }
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            const skeletons = extractFromCache(meta.skeletons);
            const animations = extractFromCache(meta.animations);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
            if (skeletons.length > 0) output.skeletons = skeletons;
            if (animations.length > 0) output.animations = animations;
        }
        output.object = object;
        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data = cache[key];
                delete data.metadata;
                values.push(data);
            }
            return values;
        }
        return output;
    }
    clone(recursive) {
        return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i2 = 0; i2 < source.children.length; i2++){
            const child = source.children[i2];
            this.add(child.clone());
        }
        return this;
    }
}
$267b85717c4872ea$export$c8ea94beaa33360.DefaultUp = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0);
$267b85717c4872ea$export$c8ea94beaa33360.DefaultMatrixAutoUpdate = true;
$267b85717c4872ea$export$c8ea94beaa33360.prototype.isObject3D = true;
const $267b85717c4872ea$var$_v0$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v1$3 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v2$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v3$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vab = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vac = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vbc = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vap = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vbp = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vcp = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$cc2ce4c411239af4 {
    constructor(a1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), b1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), c1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()){
        this.a = a1;
        this.b = b1;
        this.c = c1;
    }
    static getNormal(a, b, c, target) {
        target.subVectors(c, b);
        $267b85717c4872ea$var$_v0$1.subVectors(a, b);
        target.cross($267b85717c4872ea$var$_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    }
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    static getBarycoord(point, a, b, c, target) {
        $267b85717c4872ea$var$_v0$1.subVectors(c, a);
        $267b85717c4872ea$var$_v1$3.subVectors(b, a);
        $267b85717c4872ea$var$_v2$2.subVectors(point, a);
        const dot00 = $267b85717c4872ea$var$_v0$1.dot($267b85717c4872ea$var$_v0$1);
        const dot01 = $267b85717c4872ea$var$_v0$1.dot($267b85717c4872ea$var$_v1$3);
        const dot02 = $267b85717c4872ea$var$_v0$1.dot($267b85717c4872ea$var$_v2$2);
        const dot11 = $267b85717c4872ea$var$_v1$3.dot($267b85717c4872ea$var$_v1$3);
        const dot12 = $267b85717c4872ea$var$_v1$3.dot($267b85717c4872ea$var$_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    }
    static containsPoint(point, a, b, c) {
        this.getBarycoord(point, a, b, c, $267b85717c4872ea$var$_v3$1);
        return $267b85717c4872ea$var$_v3$1.x >= 0 && $267b85717c4872ea$var$_v3$1.y >= 0 && $267b85717c4872ea$var$_v3$1.x + $267b85717c4872ea$var$_v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, $267b85717c4872ea$var$_v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, $267b85717c4872ea$var$_v3$1.x);
        target.addScaledVector(uv2, $267b85717c4872ea$var$_v3$1.y);
        target.addScaledVector(uv3, $267b85717c4872ea$var$_v3$1.z);
        return target;
    }
    static isFrontFacing(a, b, c, direction) {
        $267b85717c4872ea$var$_v0$1.subVectors(c, b);
        $267b85717c4872ea$var$_v1$3.subVectors(a, b);
        // strictly front facing
        return $267b85717c4872ea$var$_v0$1.cross($267b85717c4872ea$var$_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    }
    getArea() {
        $267b85717c4872ea$var$_v0$1.subVectors(this.c, this.b);
        $267b85717c4872ea$var$_v1$3.subVectors(this.a, this.b);
        return $267b85717c4872ea$var$_v0$1.cross($267b85717c4872ea$var$_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
        return $267b85717c4872ea$export$cc2ce4c411239af4.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
        return $267b85717c4872ea$export$cc2ce4c411239af4.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
        return $267b85717c4872ea$export$cc2ce4c411239af4.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
        return $267b85717c4872ea$export$cc2ce4c411239af4.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
        return $267b85717c4872ea$export$cc2ce4c411239af4.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
        return box.intersectsTriangle(this);
    }
    closestPointToPoint(p, target) {
        const a2 = this.a, b2 = this.b, c2 = this.c;
        let v, w3;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        $267b85717c4872ea$var$_vab.subVectors(b2, a2);
        $267b85717c4872ea$var$_vac.subVectors(c2, a2);
        $267b85717c4872ea$var$_vap.subVectors(p, a2);
        const d1 = $267b85717c4872ea$var$_vab.dot($267b85717c4872ea$var$_vap);
        const d2 = $267b85717c4872ea$var$_vac.dot($267b85717c4872ea$var$_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a2);
        $267b85717c4872ea$var$_vbp.subVectors(p, b2);
        const d3 = $267b85717c4872ea$var$_vab.dot($267b85717c4872ea$var$_vbp);
        const d4 = $267b85717c4872ea$var$_vac.dot($267b85717c4872ea$var$_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b2);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a2).addScaledVector($267b85717c4872ea$var$_vab, v);
        }
        $267b85717c4872ea$var$_vcp.subVectors(p, c2);
        const d5 = $267b85717c4872ea$var$_vab.dot($267b85717c4872ea$var$_vcp);
        const d6 = $267b85717c4872ea$var$_vac.dot($267b85717c4872ea$var$_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c2);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w3 = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a2).addScaledVector($267b85717c4872ea$var$_vac, w3);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            $267b85717c4872ea$var$_vbc.subVectors(c2, b2);
            w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b2).addScaledVector($267b85717c4872ea$var$_vbc, w3); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w3 = vc * denom;
        return target.copy(a2).addScaledVector($267b85717c4872ea$var$_vab, v).addScaledVector($267b85717c4872ea$var$_vac, w3);
    }
    equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
}
let $267b85717c4872ea$var$materialId = 0;
class $267b85717c4872ea$export$1631e5d26e6ca932 extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: $267b85717c4872ea$var$materialId++
        });
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = $267b85717c4872ea$export$d1aa5279bbe89448;
        this.side = $267b85717c4872ea$export$9b320e6c690b4c3e;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = $267b85717c4872ea$export$5b505308e80fcb9a;
        this.blendDst = $267b85717c4872ea$export$1ce08e87b3183a15;
        this.blendEquation = $267b85717c4872ea$export$fffd413922b3da9;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = $267b85717c4872ea$export$2ebf14d6a1f62fd5;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = $267b85717c4872ea$export$895f731f76382563;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = $267b85717c4872ea$export$efbda882eafb9ba9;
        this.stencilZFail = $267b85717c4872ea$export$efbda882eafb9ba9;
        this.stencilZPass = $267b85717c4872ea$export$efbda882eafb9ba9;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null; // override the renderer's default precision for this material
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {
        };
        this.version = 0;
    }
    onBuild() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === $267b85717c4872ea$export$f5234beed215aca0 ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    }
    toJSON(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {
            },
            images: {
            }
        };
        const data = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
            data.lightMap = this.lightMap.toJSON(meta).uuid;
            data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            if (this.combine !== undefined) data.combine = this.combine;
        }
        if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.transmission !== undefined) data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== undefined) data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== undefined) data.size = this.size;
        if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== $267b85717c4872ea$export$d1aa5279bbe89448) data.blending = this.blending;
        if (this.side !== $267b85717c4872ea$export$9b320e6c690b4c3e) data.side = this.side;
        if (this.vertexColors) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.colorWrite = this.colorWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.morphNormals === true) data.morphNormals = true;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data1 = cache[key];
                delete data1.metadata;
                values.push(data1);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i2 = 0; i2 !== n; ++i2)dstPlanes[i2] = srcPlanes[i2].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
}
$267b85717c4872ea$export$1631e5d26e6ca932.prototype.isMaterial = true;
const $267b85717c4872ea$var$_colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const $267b85717c4872ea$var$_hslA = {
    h: 0,
    s: 0,
    l: 0
};
const $267b85717c4872ea$var$_hslB = {
    h: 0,
    s: 0,
    l: 0
};
function $267b85717c4872ea$var$hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function $267b85717c4872ea$var$SRGBToLinear(c2) {
    return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function $267b85717c4872ea$var$LinearToSRGB(c2) {
    return c2 < 0.0031308 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
class $267b85717c4872ea$export$e4830c8e55b4f80d {
    constructor(r1, g1, b2){
        if (g1 === undefined && b2 === undefined) // r is THREE.Color, hex or string
        return this.set(r1);
        return this.setRGB(r1, g1, b2);
    }
    set(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === 'number') this.setHex(value);
        else if (typeof value === 'string') this.setStyle(value);
        return this;
    }
    setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    }
    setHex(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    }
    setRGB(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    }
    setHSL(h, s, l) {
        // h,s,l ranges are in 0.0 - 1.0
        h = $267b85717c4872ea$var$euclideanModulo(h, 1);
        s = $267b85717c4872ea$var$clamp(s, 0, 1);
        l = $267b85717c4872ea$var$clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = $267b85717c4872ea$var$hue2rgb(q, p, h + 1 / 3);
            this.g = $267b85717c4872ea$var$hue2rgb(q, p, h);
            this.b = $267b85717c4872ea$var$hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    }
    setStyle(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                        handleAlpha(color[4]);
                        return this;
                    }
                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                        handleAlpha(color[4]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color[1]) / 360;
                        const s = parseInt(color[2], 10) / 100;
                        const l = parseInt(color[3], 10) / 100;
                        handleAlpha(color[4]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    }
    setColorName(style) {
        // color keywords
        const hex = $267b85717c4872ea$var$_colorKeywords[style.toLowerCase()];
        if (hex !== undefined) // red
        this.setHex(hex);
        else // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
        return this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
    }
    convertGammaToLinear(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    }
    convertLinearToGamma(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    }
    copySRGBToLinear(color) {
        this.r = $267b85717c4872ea$var$SRGBToLinear(color.r);
        this.g = $267b85717c4872ea$var$SRGBToLinear(color.g);
        this.b = $267b85717c4872ea$var$SRGBToLinear(color.b);
        return this;
    }
    copyLinearToSRGB(color) {
        this.r = $267b85717c4872ea$var$LinearToSRGB(color.r);
        this.g = $267b85717c4872ea$var$LinearToSRGB(color.g);
        this.b = $267b85717c4872ea$var$LinearToSRGB(color.b);
        return this;
    }
    convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
    }
    convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
    }
    getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
        // h,s,l ranges are in 0.0 - 1.0
        const r2 = this.r, g2 = this.g, b3 = this.b;
        const max2 = Math.max(r2, g2, b3);
        const min2 = Math.min(r2, g2, b3);
        let hue, saturation;
        const lightness = (min2 + max2) / 2;
        if (min2 === max2) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max2 - min2;
            saturation = lightness <= 0.5 ? delta / (max2 + min2) : delta / (2 - max2 - min2);
            switch(max2){
                case r2:
                    hue = (g2 - b3) / delta + (g2 < b3 ? 6 : 0);
                    break;
                case g2:
                    hue = (b3 - r2) / delta + 2;
                    break;
                case b3:
                    hue = (r2 - g2) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    }
    getStyle() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    }
    offsetHSL(h, s, l) {
        this.getHSL($267b85717c4872ea$var$_hslA);
        $267b85717c4872ea$var$_hslA.h += h;
        $267b85717c4872ea$var$_hslA.s += s;
        $267b85717c4872ea$var$_hslA.l += l;
        this.setHSL($267b85717c4872ea$var$_hslA.h, $267b85717c4872ea$var$_hslA.s, $267b85717c4872ea$var$_hslA.l);
        return this;
    }
    add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
    }
    addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    }
    addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    }
    sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
    }
    multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
    }
    multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    }
    lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
    }
    lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
    }
    lerpHSL(color, alpha) {
        this.getHSL($267b85717c4872ea$var$_hslA);
        color.getHSL($267b85717c4872ea$var$_hslB);
        const h = $267b85717c4872ea$var$lerp($267b85717c4872ea$var$_hslA.h, $267b85717c4872ea$var$_hslB.h, alpha);
        const s = $267b85717c4872ea$var$lerp($267b85717c4872ea$var$_hslA.s, $267b85717c4872ea$var$_hslB.s, alpha);
        const l = $267b85717c4872ea$var$lerp($267b85717c4872ea$var$_hslA.l, $267b85717c4872ea$var$_hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    }
    equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
    }
    fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    }
    toJSON() {
        return this.getHex();
    }
}
$267b85717c4872ea$export$e4830c8e55b4f80d.NAMES = $267b85717c4872ea$var$_colorKeywords;
$267b85717c4872ea$export$e4830c8e55b4f80d.prototype.isColor = true;
$267b85717c4872ea$export$e4830c8e55b4f80d.prototype.r = 1;
$267b85717c4872ea$export$e4830c8e55b4f80d.prototype.g = 1;
$267b85717c4872ea$export$e4830c8e55b4f80d.prototype.b = 1;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>
 * }
 */ class $267b85717c4872ea$export$f191b8c5dbd3d9f9 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters){
        super();
        this.type = 'MeshBasicMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215); // emissive
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $267b85717c4872ea$export$9662028f262f1c9a;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.morphTargets = false;
        this.setValues(parameters);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.morphTargets = source.morphTargets;
        return this;
    }
}
$267b85717c4872ea$export$f191b8c5dbd3d9f9.prototype.isMeshBasicMaterial = true;
const $267b85717c4872ea$var$_vector$9 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vector2$1 = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
class $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array1, itemSize14, normalized){
        if (Array.isArray(array1)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        this.name = '';
        this.array = array1;
        this.itemSize = itemSize14;
        this.count = array1 !== undefined ? array1.length / itemSize14 : 0;
        this.normalized = normalized === true;
        this.usage = $267b85717c4872ea$export$ec469a709bf33b5b;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i2 = 0, l = this.itemSize; i2 < l; i2++)this.array[index1 + i2] = attribute.array[index2 + i2];
        return this;
    }
    copyArray(array) {
        this.array.set(array);
        return this;
    }
    copyColorsArray(colors) {
        const array2 = this.array;
        let offset = 0;
        for(let i2 = 0, l = colors.length; i2 < l; i2++){
            let color = colors[i2];
            if (color === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i2);
                color = new $267b85717c4872ea$export$e4830c8e55b4f80d();
            }
            array2[offset++] = color.r;
            array2[offset++] = color.g;
            array2[offset++] = color.b;
        }
        return this;
    }
    copyVector2sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for(let i2 = 0, l = vectors.length; i2 < l; i2++){
            let vector = vectors[i2];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i2);
                vector = new $267b85717c4872ea$export$95d9e1e745cc7977();
            }
            array2[offset++] = vector.x;
            array2[offset++] = vector.y;
        }
        return this;
    }
    copyVector3sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for(let i2 = 0, l = vectors.length; i2 < l; i2++){
            let vector = vectors[i2];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i2);
                vector = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            }
            array2[offset++] = vector.x;
            array2[offset++] = vector.y;
            array2[offset++] = vector.z;
        }
        return this;
    }
    copyVector4sArray(vectors) {
        const array2 = this.array;
        let offset = 0;
        for(let i2 = 0, l = vectors.length; i2 < l; i2++){
            let vector = vectors[i2];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i2);
                vector = new $267b85717c4872ea$export$14dfcb76afe97063();
            }
            array2[offset++] = vector.x;
            array2[offset++] = vector.y;
            array2[offset++] = vector.z;
            array2[offset++] = vector.w;
        }
        return this;
    }
    applyMatrix3(m) {
        if (this.itemSize === 2) for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector2$1.fromBufferAttribute(this, i2);
            $267b85717c4872ea$var$_vector2$1.applyMatrix3(m);
            this.setXY(i2, $267b85717c4872ea$var$_vector2$1.x, $267b85717c4872ea$var$_vector2$1.y);
        }
        else if (this.itemSize === 3) for(let i3 = 0, l1 = this.count; i3 < l1; i3++){
            $267b85717c4872ea$var$_vector$9.fromBufferAttribute(this, i3);
            $267b85717c4872ea$var$_vector$9.applyMatrix3(m);
            this.setXYZ(i3, $267b85717c4872ea$var$_vector$9.x, $267b85717c4872ea$var$_vector$9.y, $267b85717c4872ea$var$_vector$9.z);
        }
        return this;
    }
    applyMatrix4(m) {
        for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$9.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$9.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$9.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$9.applyMatrix4(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$9.x, $267b85717c4872ea$var$_vector$9.y, $267b85717c4872ea$var$_vector$9.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$9.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$9.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$9.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$9.applyNormalMatrix(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$9.x, $267b85717c4872ea$var$_vector$9.y, $267b85717c4872ea$var$_vector$9.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$9.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$9.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$9.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$9.transformDirection(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$9.x, $267b85717c4872ea$var$_vector$9.y, $267b85717c4872ea$var$_vector$9.z);
        }
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    getX(index) {
        return this.array[index * this.itemSize];
    }
    setX(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
    }
    getY(index) {
        return this.array[index * this.itemSize + 1];
    }
    setY(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
    }
    getZ(index) {
        return this.array[index * this.itemSize + 2];
    }
    setZ(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
    }
    getW(index) {
        return this.array[index * this.itemSize + 3];
    }
    setW(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
    }
    setXY(index, x, y) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const data = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        if (this.name !== '') data.name = this.name;
        if (this.usage !== $267b85717c4872ea$export$ec469a709bf33b5b) data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
        return data;
    }
}
$267b85717c4872ea$export$3d45483f125de856.prototype.isBufferAttribute = true;
//
class $267b85717c4872ea$export$f614dc6b4671f584 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array2, itemSize1, normalized1){
        super(new Int8Array(array2), itemSize1, normalized1);
    }
}
class $267b85717c4872ea$export$f45fc10ff2aaa0ef extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array3, itemSize2, normalized2){
        super(new Uint8Array(array3), itemSize2, normalized2);
    }
}
class $267b85717c4872ea$export$522e22163c689adf extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array4, itemSize3, normalized3){
        super(new Uint8ClampedArray(array4), itemSize3, normalized3);
    }
}
class $267b85717c4872ea$export$3e147586bc80f717 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array5, itemSize4, normalized4){
        super(new Int16Array(array5), itemSize4, normalized4);
    }
}
class $267b85717c4872ea$export$1673be55325c3b52 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array6, itemSize5, normalized5){
        super(new Uint16Array(array6), itemSize5, normalized5);
    }
}
class $267b85717c4872ea$export$5117506a26efbc58 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array7, itemSize6, normalized6){
        super(new Int32Array(array7), itemSize6, normalized6);
    }
}
class $267b85717c4872ea$export$f86c6826769eb286 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array8, itemSize7, normalized7){
        super(new Uint32Array(array8), itemSize7, normalized7);
    }
}
class $267b85717c4872ea$export$a4f41ea101d20c9 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array9, itemSize8, normalized8){
        super(new Uint16Array(array9), itemSize8, normalized8);
    }
}
$267b85717c4872ea$export$a4f41ea101d20c9.prototype.isFloat16BufferAttribute = true;
class $267b85717c4872ea$export$8af155dd3ccd7773 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array10, itemSize9, normalized9){
        super(new Float32Array(array10), itemSize9, normalized9);
    }
}
class $267b85717c4872ea$export$eb3f0288ee857d2b extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array11, itemSize10, normalized10){
        super(new Float64Array(array11), itemSize10, normalized10);
    }
}
function $267b85717c4872ea$var$arrayMax(array12) {
    if (array12.length === 0) return -Infinity;
    let max2 = array12[0];
    for(let i2 = 1, l = array12.length; i2 < l; ++i2)if (array12[i2] > max2) max2 = array12[i2];
    return max2;
}
const $267b85717c4872ea$var$TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function $267b85717c4872ea$var$getTypedArray(type1, buffer) {
    return new $267b85717c4872ea$var$TYPED_ARRAYS[type1](buffer);
}
let $267b85717c4872ea$var$_id = 0;
const $267b85717c4872ea$var$_m1 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_obj = /*@__PURE__*/ new $267b85717c4872ea$export$c8ea94beaa33360();
const $267b85717c4872ea$var$_offset = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_box$1 = /*@__PURE__*/ new $267b85717c4872ea$export$c99edadde72ee706();
const $267b85717c4872ea$var$_boxMorphTargets = /*@__PURE__*/ new $267b85717c4872ea$export$c99edadde72ee706();
const $267b85717c4872ea$var$_vector$8 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$84a34b4c8ecb6751 extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(){
        super();
        Object.defineProperty(this, 'id', {
            value: $267b85717c4872ea$var$_id++
        });
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.name = '';
        this.type = 'BufferGeometry';
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = {
            start: 0,
            count: Infinity
        };
        this.userData = {
        };
    }
    getIndex() {
        return this.index;
    }
    setIndex(index) {
        if (Array.isArray(index)) this.index = new ($267b85717c4872ea$var$arrayMax(index) > 65535 ? $267b85717c4872ea$export$f86c6826769eb286 : $267b85717c4872ea$export$1673be55325c3b52)(index, 1);
        else this.index = index;
        return this;
    }
    getAttribute(name) {
        return this.attributes[name];
    }
    setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    }
    deleteAttribute(name) {
        delete this.attributes[name];
        return this;
    }
    hasAttribute(name) {
        return this.attributes[name] !== undefined;
    }
    addGroup(start, count, materialIndex = 0) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex
        });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
        const position1 = this.attributes.position;
        if (position1 !== undefined) {
            position1.applyMatrix4(matrix);
            position1.needsUpdate = true;
        }
        const normal = this.attributes.normal;
        if (normal !== undefined) {
            const normalMatrix = new $267b85717c4872ea$export$6b1dbb040148d435().getNormalMatrix(matrix);
            normal.applyNormalMatrix(normalMatrix);
            normal.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    }
    applyQuaternion(q) {
        $267b85717c4872ea$var$_m1.makeRotationFromQuaternion(q);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    rotateX(angle) {
        // rotate geometry around world x-axis
        $267b85717c4872ea$var$_m1.makeRotationX(angle);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    rotateY(angle) {
        // rotate geometry around world y-axis
        $267b85717c4872ea$var$_m1.makeRotationY(angle);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    rotateZ(angle) {
        // rotate geometry around world z-axis
        $267b85717c4872ea$var$_m1.makeRotationZ(angle);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    translate(x, y, z) {
        // translate geometry
        $267b85717c4872ea$var$_m1.makeTranslation(x, y, z);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    scale(x, y, z) {
        // scale geometry
        $267b85717c4872ea$var$_m1.makeScale(x, y, z);
        this.applyMatrix4($267b85717c4872ea$var$_m1);
        return this;
    }
    lookAt(vector) {
        $267b85717c4872ea$var$_obj.lookAt(vector);
        $267b85717c4872ea$var$_obj.updateMatrix();
        this.applyMatrix4($267b85717c4872ea$var$_obj.matrix);
        return this;
    }
    center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter($267b85717c4872ea$var$_offset).negate();
        this.translate($267b85717c4872ea$var$_offset.x, $267b85717c4872ea$var$_offset.y, $267b85717c4872ea$var$_offset.z);
        return this;
    }
    setFromPoints(points) {
        const position1 = [];
        for(let i2 = 0, l = points.length; i2 < l; i2++){
            const point = points[i2];
            position1.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(position1, 3));
        return this;
    }
    computeBoundingBox() {
        if (this.boundingBox === null) this.boundingBox = new $267b85717c4872ea$export$c99edadde72ee706();
        const position1 = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position1 && position1.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingBox.set(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-Infinity, -Infinity, -Infinity), new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(Infinity, Infinity, Infinity));
            return;
        }
        if (position1 !== undefined) {
            this.boundingBox.setFromBufferAttribute(position1);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++){
                const morphAttribute = morphAttributesPosition[i2];
                $267b85717c4872ea$var$_box$1.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    $267b85717c4872ea$var$_vector$8.addVectors(this.boundingBox.min, $267b85717c4872ea$var$_box$1.min);
                    this.boundingBox.expandByPoint($267b85717c4872ea$var$_vector$8);
                    $267b85717c4872ea$var$_vector$8.addVectors(this.boundingBox.max, $267b85717c4872ea$var$_box$1.max);
                    this.boundingBox.expandByPoint($267b85717c4872ea$var$_vector$8);
                } else {
                    this.boundingBox.expandByPoint($267b85717c4872ea$var$_box$1.min);
                    this.boundingBox.expandByPoint($267b85717c4872ea$var$_box$1.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
        if (this.boundingSphere === null) this.boundingSphere = new $267b85717c4872ea$export$48b052fa5734fd42();
        const position1 = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position1 && position1.isGLBufferAttribute) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
            this.boundingSphere.set(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), Infinity);
            return;
        }
        if (position1) {
            // first, find the center of the bounding sphere
            const center2 = this.boundingSphere.center;
            $267b85717c4872ea$var$_box$1.setFromBufferAttribute(position1);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++){
                const morphAttribute = morphAttributesPosition[i2];
                $267b85717c4872ea$var$_boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    $267b85717c4872ea$var$_vector$8.addVectors($267b85717c4872ea$var$_box$1.min, $267b85717c4872ea$var$_boxMorphTargets.min);
                    $267b85717c4872ea$var$_box$1.expandByPoint($267b85717c4872ea$var$_vector$8);
                    $267b85717c4872ea$var$_vector$8.addVectors($267b85717c4872ea$var$_box$1.max, $267b85717c4872ea$var$_boxMorphTargets.max);
                    $267b85717c4872ea$var$_box$1.expandByPoint($267b85717c4872ea$var$_vector$8);
                } else {
                    $267b85717c4872ea$var$_box$1.expandByPoint($267b85717c4872ea$var$_boxMorphTargets.min);
                    $267b85717c4872ea$var$_box$1.expandByPoint($267b85717c4872ea$var$_boxMorphTargets.max);
                }
            }
            $267b85717c4872ea$var$_box$1.getCenter(center2);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i3 = 0, il1 = position1.count; i3 < il1; i3++){
                $267b85717c4872ea$var$_vector$8.fromBufferAttribute(position1, i3);
                maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared($267b85717c4872ea$var$_vector$8));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i4 = 0, il2 = morphAttributesPosition.length; i4 < il2; i4++){
                const morphAttribute = morphAttributesPosition[i4];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    $267b85717c4872ea$var$_vector$8.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        $267b85717c4872ea$var$_offset.fromBufferAttribute(position1, j);
                        $267b85717c4872ea$var$_vector$8.add($267b85717c4872ea$var$_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center2.distanceToSquared($267b85717c4872ea$var$_vector$8));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
    computeFaceNormals() {
    // backwards compatibility
    }
    computeTangents() {
        const index = this.index;
        const attributes = this.attributes;
        // based on http://www.terathon.com/code/tangent.html
        // (per vertex tangents)
        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
            console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
            return;
        }
        const indices = index.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (attributes.tangent === undefined) this.setAttribute('tangent', new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(4 * nVertices), 4));
        const tangents = attributes.tangent.array;
        const tan1 = [], tan2 = [];
        for(let i2 = 0; i2 < nVertices; i2++){
            tan1[i2] = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            tan2[i2] = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        }
        const vA = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), vB = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), vC = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), uvA = new $267b85717c4872ea$export$95d9e1e745cc7977(), uvB = new $267b85717c4872ea$export$95d9e1e745cc7977(), uvC = new $267b85717c4872ea$export$95d9e1e745cc7977(), sdir = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), tdir = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        function handleTriangle(a2, b3, c2) {
            vA.fromArray(positions, a2 * 3);
            vB.fromArray(positions, b3 * 3);
            vC.fromArray(positions, c2 * 3);
            uvA.fromArray(uvs, a2 * 2);
            uvB.fromArray(uvs, b3 * 2);
            uvC.fromArray(uvs, c2 * 2);
            vB.sub(vA);
            vC.sub(vA);
            uvB.sub(uvA);
            uvC.sub(uvA);
            const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
            // silently ignore degenerate uv triangles having coincident or colinear vertices
            if (!isFinite(r2)) return;
            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
            tan1[a2].add(sdir);
            tan1[b3].add(sdir);
            tan1[c2].add(sdir);
            tan2[a2].add(tdir);
            tan2[b3].add(tdir);
            tan2[c2].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) groups = [
            {
                start: 0,
                count: indices.length
            }
        ];
        for(let i3 = 0, il = groups.length; i3 < il; ++i3){
            const group = groups[i3];
            const start = group.start;
            const count2 = group.count;
            for(let j = start, jl = start + count2; j < jl; j += 3)handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
        }
        const tmp = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), tmp2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const n = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), n2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        function handleVertex(v) {
            n.fromArray(normals, v * 3);
            n2.copy(n);
            const t = tan1[v];
            // Gram-Schmidt orthogonalize
            tmp.copy(t);
            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
            // Calculate handedness
            tmp2.crossVectors(n2, t);
            const test = tmp2.dot(tan2[v]);
            const w3 = test < 0 ? -1 : 1;
            tangents[v * 4] = tmp.x;
            tangents[v * 4 + 1] = tmp.y;
            tangents[v * 4 + 2] = tmp.z;
            tangents[v * 4 + 3] = w3;
        }
        for(let i4 = 0, il1 = groups.length; i4 < il1; ++i4){
            const group = groups[i4];
            const start = group.start;
            const count2 = group.count;
            for(let j = start, jl = start + count2; j < jl; j += 3){
                handleVertex(indices[j + 0]);
                handleVertex(indices[j + 1]);
                handleVertex(indices[j + 2]);
            }
        }
    }
    computeVertexNormals() {
        const index = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else // reset existing normals to zero
            for(let i2 = 0, il = normalAttribute.count; i2 < il; i2++)normalAttribute.setXYZ(i2, 0, 0, 0);
            const pA = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), pB = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), pC = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const nA = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), nB = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), nC = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const cb = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), ab = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            // indexed elements
            if (index) for(let i3 = 0, il1 = index.count; i3 < il1; i3 += 3){
                const vA = index.getX(i3 + 0);
                const vB = index.getX(i3 + 1);
                const vC = index.getX(i3 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i4 = 0, il2 = positionAttribute.count; i4 < il2; i4 += 3){
                pA.fromBufferAttribute(positionAttribute, i4 + 0);
                pB.fromBufferAttribute(positionAttribute, i4 + 1);
                pC.fromBufferAttribute(positionAttribute, i4 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i4 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i4 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i4 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    }
    merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i2 = 0, j = attributeOffset; i2 < length; i2++, j++)attributeArray1[j] = attributeArray2[i2];
        }
        return this;
    }
    normalizeNormals() {
        const normals = this.attributes.normal;
        for(let i2 = 0, il = normals.count; i2 < il; i2++){
            $267b85717c4872ea$var$_vector$8.fromBufferAttribute(normals, i2);
            $267b85717c4872ea$var$_vector$8.normalize();
            normals.setXYZ(i2, $267b85717c4872ea$var$_vector$8.x, $267b85717c4872ea$var$_vector$8.y, $267b85717c4872ea$var$_vector$8.z);
        }
    }
    toNonIndexed() {
        function convertBufferAttribute(attribute, indices) {
            const array12 = attribute.array;
            const itemSize11 = attribute.itemSize;
            const normalized11 = attribute.normalized;
            const array21 = new array12.constructor(indices.length * itemSize11);
            let index = 0, index2 = 0;
            for(let i2 = 0, l = indices.length; i2 < l; i2++){
                if (attribute.isInterleavedBufferAttribute) index = indices[i2] * attribute.data.stride + attribute.offset;
                else index = indices[i2] * itemSize11;
                for(let j = 0; j < itemSize11; j++)array21[index2++] = array12[index++];
            }
            return new $267b85717c4872ea$export$3d45483f125de856(array21, itemSize11, normalized11);
        }
        //
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
            return this;
        }
        const geometry2 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        const indices = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name1 in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i2 = 0, il = morphAttribute.length; i2 < il; i2++){
                const attribute = morphAttribute[i2];
                const newAttribute = convertBufferAttribute(attribute, indices);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name1] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i2 = 0, l = groups.length; i2 < l; i2++){
            const group = groups[i2];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    }
    toJSON() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters1 = this.parameters;
            for(const key in parameters1)if (parameters1[key] !== undefined) data[key] = parameters1[key];
            return data;
        }
        // for simplicity the code assumes attributes are not shared across geometries, see #15811
        data.data = {
            attributes: {
            }
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {
        };
        let hasMorphAttributes = false;
        for(const key1 in this.morphAttributes){
            const attributeArray = this.morphAttributes[key1];
            const array12 = [];
            for(let i2 = 0, il = attributeArray.length; i2 < il; i2++){
                const attribute = attributeArray[i2];
                array12.push(attribute.toJSON(data.data));
            }
            if (array12.length > 0) {
                morphAttributes[key1] = array12;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    }
    clone() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */ return new $267b85717c4872ea$export$84a34b4c8ecb6751().copy(this);
    }
    copy(source) {
        // reset
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {
        };
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name1 in morphAttributes){
            const array12 = [];
            const morphAttribute = morphAttributes[name1]; // morphAttribute: array of Float32BufferAttributes
            for(let i2 = 0, l = morphAttribute.length; i2 < l; i2++)array12.push(morphAttribute[i2].clone(data));
            this.morphAttributes[name1] = array12;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i2 = 0, l = groups.length; i2 < l; i2++){
            const group = groups[i2];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.isBufferGeometry = true;
const $267b85717c4872ea$var$_inverseMatrix$2 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_ray$2 = /*@__PURE__*/ new $267b85717c4872ea$export$c0bfd01633e732a2();
const $267b85717c4872ea$var$_sphere$3 = /*@__PURE__*/ new $267b85717c4872ea$export$48b052fa5734fd42();
const $267b85717c4872ea$var$_vA$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vB$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vC$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_tempA = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_tempB = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_tempC = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_morphA = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_morphB = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_morphC = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_uvA$1 = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_uvB$1 = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_uvC$1 = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_intersectionPoint = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_intersectionPointWorld = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$4cdb671a7054bbf9 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(geometry = new $267b85717c4872ea$export$84a34b4c8ecb6751(), material17 = new $267b85717c4872ea$export$f191b8c5dbd3d9f9()){
        super();
        this.type = 'Mesh';
        this.geometry = geometry;
        this.material = material17;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({
        }, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    updateMorphTargets() {
        const geometry1 = this.geometry;
        if (geometry1.isBufferGeometry) {
            const morphAttributes = geometry1.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry1.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
    raycast(raycaster, intersects) {
        const geometry1 = this.geometry;
        const material1 = this.material;
        const matrixWorld = this.matrixWorld;
        if (material1 === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry1.boundingSphere === null) geometry1.computeBoundingSphere();
        $267b85717c4872ea$var$_sphere$3.copy(geometry1.boundingSphere);
        $267b85717c4872ea$var$_sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere($267b85717c4872ea$var$_sphere$3) === false) return;
        //
        $267b85717c4872ea$var$_inverseMatrix$2.copy(matrixWorld).invert();
        $267b85717c4872ea$var$_ray$2.copy(raycaster.ray).applyMatrix4($267b85717c4872ea$var$_inverseMatrix$2);
        // Check boundingBox before continuing
        if (geometry1.boundingBox !== null) {
            if ($267b85717c4872ea$var$_ray$2.intersectsBox(geometry1.boundingBox) === false) return;
        }
        let intersection;
        if (geometry1.isBufferGeometry) {
            const index = geometry1.index;
            const position1 = geometry1.attributes.position;
            const morphPosition = geometry1.morphAttributes.position;
            const morphTargetsRelative = geometry1.morphTargetsRelative;
            const uv = geometry1.attributes.uv;
            const uv2 = geometry1.attributes.uv2;
            const groups = geometry1.groups;
            const drawRange = geometry1.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material1)) for(let i2 = 0, il = groups.length; i2 < il; i2++){
                    const group = groups[i2];
                    const groupMaterial = material1[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a2 = index.getX(j);
                        const b3 = index.getX(j + 1);
                        const c2 = index.getX(j + 2);
                        intersection = $267b85717c4872ea$var$checkBufferGeometryIntersection(this, groupMaterial, raycaster, $267b85717c4872ea$var$_ray$2, position1, morphPosition, morphTargetsRelative, uv, uv2, a2, b3, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i3 = start, il1 = end; i3 < il1; i3 += 3){
                        const a2 = index.getX(i3);
                        const b3 = index.getX(i3 + 1);
                        const c2 = index.getX(i3 + 2);
                        intersection = $267b85717c4872ea$var$checkBufferGeometryIntersection(this, material1, raycaster, $267b85717c4872ea$var$_ray$2, position1, morphPosition, morphTargetsRelative, uv, uv2, a2, b3, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i3 / 3); // triangle number in indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position1 !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material1)) for(let i2 = 0, il = groups.length; i2 < il; i2++){
                    const group = groups[i2];
                    const groupMaterial = material1[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a2 = j;
                        const b3 = j + 1;
                        const c2 = j + 2;
                        intersection = $267b85717c4872ea$var$checkBufferGeometryIntersection(this, groupMaterial, raycaster, $267b85717c4872ea$var$_ray$2, position1, morphPosition, morphTargetsRelative, uv, uv2, a2, b3, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position1.count, drawRange.start + drawRange.count);
                    for(let i3 = start, il1 = end; i3 < il1; i3 += 3){
                        const a2 = i3;
                        const b3 = i3 + 1;
                        const c2 = i3 + 2;
                        intersection = $267b85717c4872ea$var$checkBufferGeometryIntersection(this, material1, raycaster, $267b85717c4872ea$var$_ray$2, position1, morphPosition, morphTargetsRelative, uv, uv2, a2, b3, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i3 / 3); // triangle number in non-indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry1.isGeometry) console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
}
$267b85717c4872ea$export$4cdb671a7054bbf9.prototype.isMesh = true;
function $267b85717c4872ea$var$checkIntersection(object, material1, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material1.side !== $267b85717c4872ea$export$6c33fb00521864ae, point);
    if (intersect === null) return null;
    $267b85717c4872ea$var$_intersectionPointWorld.copy(point);
    $267b85717c4872ea$var$_intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo($267b85717c4872ea$var$_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: $267b85717c4872ea$var$_intersectionPointWorld.clone(),
        object: object
    };
}
function $267b85717c4872ea$var$checkBufferGeometryIntersection(object, material1, raycaster, ray, position1, morphPosition, morphTargetsRelative, uv, uv2, a2, b3, c2) {
    $267b85717c4872ea$var$_vA$1.fromBufferAttribute(position1, a2);
    $267b85717c4872ea$var$_vB$1.fromBufferAttribute(position1, b3);
    $267b85717c4872ea$var$_vC$1.fromBufferAttribute(position1, c2);
    const morphInfluences = object.morphTargetInfluences;
    if (material1.morphTargets && morphPosition && morphInfluences) {
        $267b85717c4872ea$var$_morphA.set(0, 0, 0);
        $267b85717c4872ea$var$_morphB.set(0, 0, 0);
        $267b85717c4872ea$var$_morphC.set(0, 0, 0);
        for(let i2 = 0, il = morphPosition.length; i2 < il; i2++){
            const influence = morphInfluences[i2];
            const morphAttribute = morphPosition[i2];
            if (influence === 0) continue;
            $267b85717c4872ea$var$_tempA.fromBufferAttribute(morphAttribute, a2);
            $267b85717c4872ea$var$_tempB.fromBufferAttribute(morphAttribute, b3);
            $267b85717c4872ea$var$_tempC.fromBufferAttribute(morphAttribute, c2);
            if (morphTargetsRelative) {
                $267b85717c4872ea$var$_morphA.addScaledVector($267b85717c4872ea$var$_tempA, influence);
                $267b85717c4872ea$var$_morphB.addScaledVector($267b85717c4872ea$var$_tempB, influence);
                $267b85717c4872ea$var$_morphC.addScaledVector($267b85717c4872ea$var$_tempC, influence);
            } else {
                $267b85717c4872ea$var$_morphA.addScaledVector($267b85717c4872ea$var$_tempA.sub($267b85717c4872ea$var$_vA$1), influence);
                $267b85717c4872ea$var$_morphB.addScaledVector($267b85717c4872ea$var$_tempB.sub($267b85717c4872ea$var$_vB$1), influence);
                $267b85717c4872ea$var$_morphC.addScaledVector($267b85717c4872ea$var$_tempC.sub($267b85717c4872ea$var$_vC$1), influence);
            }
        }
        $267b85717c4872ea$var$_vA$1.add($267b85717c4872ea$var$_morphA);
        $267b85717c4872ea$var$_vB$1.add($267b85717c4872ea$var$_morphB);
        $267b85717c4872ea$var$_vC$1.add($267b85717c4872ea$var$_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a2, $267b85717c4872ea$var$_vA$1);
        object.boneTransform(b3, $267b85717c4872ea$var$_vB$1);
        object.boneTransform(c2, $267b85717c4872ea$var$_vC$1);
    }
    const intersection = $267b85717c4872ea$var$checkIntersection(object, material1, raycaster, ray, $267b85717c4872ea$var$_vA$1, $267b85717c4872ea$var$_vB$1, $267b85717c4872ea$var$_vC$1, $267b85717c4872ea$var$_intersectionPoint);
    if (intersection) {
        if (uv) {
            $267b85717c4872ea$var$_uvA$1.fromBufferAttribute(uv, a2);
            $267b85717c4872ea$var$_uvB$1.fromBufferAttribute(uv, b3);
            $267b85717c4872ea$var$_uvC$1.fromBufferAttribute(uv, c2);
            intersection.uv = $267b85717c4872ea$export$cc2ce4c411239af4.getUV($267b85717c4872ea$var$_intersectionPoint, $267b85717c4872ea$var$_vA$1, $267b85717c4872ea$var$_vB$1, $267b85717c4872ea$var$_vC$1, $267b85717c4872ea$var$_uvA$1, $267b85717c4872ea$var$_uvB$1, $267b85717c4872ea$var$_uvC$1, new $267b85717c4872ea$export$95d9e1e745cc7977());
        }
        if (uv2) {
            $267b85717c4872ea$var$_uvA$1.fromBufferAttribute(uv2, a2);
            $267b85717c4872ea$var$_uvB$1.fromBufferAttribute(uv2, b3);
            $267b85717c4872ea$var$_uvC$1.fromBufferAttribute(uv2, c2);
            intersection.uv2 = $267b85717c4872ea$export$cc2ce4c411239af4.getUV($267b85717c4872ea$var$_intersectionPoint, $267b85717c4872ea$var$_vA$1, $267b85717c4872ea$var$_vB$1, $267b85717c4872ea$var$_vC$1, $267b85717c4872ea$var$_uvA$1, $267b85717c4872ea$var$_uvB$1, $267b85717c4872ea$var$_uvC$1, new $267b85717c4872ea$export$95d9e1e745cc7977());
        }
        const face = {
            a: a2,
            b: b3,
            c: c2,
            normal: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
            materialIndex: 0
        };
        $267b85717c4872ea$export$cc2ce4c411239af4.getNormal($267b85717c4872ea$var$_vA$1, $267b85717c4872ea$var$_vB$1, $267b85717c4872ea$var$_vC$1, face.normal);
        intersection.face = face;
    }
    return intersection;
}
class $267b85717c4872ea$export$7adcd09f49b1ca3c extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(width4 = 1, height4 = 1, depth1 = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = 'BoxGeometry';
        this.parameters = {
            width: width4,
            height: height4,
            depth: depth1,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        // segments
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth1, height4, width4, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth1, height4, -width4, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width4, depth1, height4, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width4, depth1, -height4, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width4, height4, depth1, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width4, height4, -depth1, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs, 2));
        function buildPlane(u, v, w3, udir, vdir, width5, height5, depth1, gridX, gridY, materialIndex) {
            const segmentWidth = width5 / gridX;
            const segmentHeight = height5 / gridY;
            const widthHalf = width5 / 2;
            const heightHalf = height5 / 2;
            const depthHalf = depth1 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y6 = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x6 = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x6 * udir;
                    vector[v] = y6 * vdir;
                    vector[w3] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w3] = depth1 > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
                const a2 = numberOfVertices + ix + gridX1 * iy1;
                const b3 = numberOfVertices + ix + gridX1 * (iy1 + 1);
                const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy1 + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy1;
                // faces
                indices.push(a2, b3, d);
                indices.push(b3, c2, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$7adcd09f49b1ca3c(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
}
/**
 * Uniform Utilities
 */ function $267b85717c4872ea$var$cloneUniforms(src) {
    const dst = {
    };
    for(const u in src){
        dst[u] = {
        };
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function $267b85717c4872ea$var$mergeUniforms(uniforms) {
    const merged = {
    };
    for(let u = 0; u < uniforms.length; u++){
        const tmp = $267b85717c4872ea$var$cloneUniforms(uniforms[u]);
        for(const p in tmp)merged[p] = tmp[p];
    }
    return merged;
}
// Legacy
const $267b85717c4872ea$export$7c3162ea2c0a01b6 = {
    clone: $267b85717c4872ea$var$cloneUniforms,
    merge: $267b85717c4872ea$var$mergeUniforms
};
var $267b85717c4872ea$var$default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var $267b85717c4872ea$var$default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ class $267b85717c4872ea$export$2a77b7c526ae5937 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters1){
        super();
        this.type = 'ShaderMaterial';
        this.defines = {
        };
        this.uniforms = {
        };
        this.vertexShader = $267b85717c4872ea$var$default_vertex;
        this.fragmentShader = $267b85717c4872ea$var$default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false // set to use shader texture LOD
        };
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [
                1,
                1,
                1
            ],
            'uv': [
                0,
                0
            ],
            'uv2': [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters1 !== undefined) {
            if (parameters1.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            this.setValues(parameters1);
        }
    }
    copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = $267b85717c4872ea$var$cloneUniforms(source.uniforms);
        this.defines = Object.assign({
        }, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = Object.assign({
        }, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {
        };
        for(const name in this.uniforms){
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: 't',
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: 'c',
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: 'v2',
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: 'v3',
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: 'v4',
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: 'm3',
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: 'm4',
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            };
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {
        };
        for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    }
}
$267b85717c4872ea$export$2a77b7c526ae5937.prototype.isShaderMaterial = true;
class $267b85717c4872ea$export$d193d689dcf22ce8 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this.type = 'Camera';
        this.matrixWorldInverse = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.projectionMatrix = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.projectionMatrixInverse = new $267b85717c4872ea$export$960b1460cb9cd6c9();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    }
    getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
$267b85717c4872ea$export$d193d689dcf22ce8.prototype.isCamera = true;
class $267b85717c4872ea$export$95bab1c599905cc4 extends $267b85717c4872ea$export$d193d689dcf22ce8 {
    constructor(fov = 50, aspect = 1, near5 = 0.1, far5 = 2000){
        super();
        this.type = 'PerspectiveCamera';
        this.fov = fov;
        this.zoom = 1;
        this.near = near5;
        this.far = far5;
        this.focus = 10;
        this.aspect = aspect;
        this.view = null;
        this.filmGauge = 35; // width of the film (default in millimeters)
        this.filmOffset = 0; // horizontal film offset (same unit as gauge)
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    }
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */ setFocalLength(focalLength) {
        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */ const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = $267b85717c4872ea$var$RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    }
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */ getFocalLength() {
        const vExtentSlope = Math.tan($267b85717c4872ea$var$DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
        return $267b85717c4872ea$var$RAD2DEG * 2 * Math.atan(Math.tan($267b85717c4872ea$var$DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */ setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const near1 = this.near;
        let top = near1 * Math.tan($267b85717c4872ea$var$DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height5 = 2 * top;
        let width5 = this.aspect * height5;
        let left = -0.5 * width5;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width5 / fullWidth;
            top -= view.offsetY * height5 / fullHeight;
            width5 *= view.width / fullWidth;
            height5 *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near1 * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width5, top, top - height5, near1, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
}
$267b85717c4872ea$export$95bab1c599905cc4.prototype.isPerspectiveCamera = true;
const $267b85717c4872ea$var$fov = 90, $267b85717c4872ea$var$aspect = 1;
class $267b85717c4872ea$export$62bcc2046b614bc8 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(near1, far1, renderTarget){
        super();
        this.type = 'CubeCamera';
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
            console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
            return;
        }
        this.renderTarget = renderTarget;
        const cameraPX = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 0, 0));
        this.add(cameraPX);
        const cameraNX = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-1, 0, 0));
        this.add(cameraNX);
        const cameraPY = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0));
        this.add(cameraPY);
        const cameraNY = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, -1, 0));
        this.add(cameraNY);
        const cameraPZ = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 1));
        this.add(cameraPZ);
        const cameraNZ = new $267b85717c4872ea$export$95bab1c599905cc4($267b85717c4872ea$var$fov, $267b85717c4872ea$var$aspect, near1, far1);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, -1));
        this.add(cameraNZ);
    }
    update(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const renderTarget1 = this.renderTarget;
        const [cameraPX1, cameraNX1, cameraPY1, cameraNY1, cameraPZ1, cameraNZ1] = this.children;
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget1.texture.generateMipmaps;
        renderTarget1.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget1, 0);
        renderer.render(scene, cameraPX1);
        renderer.setRenderTarget(renderTarget1, 1);
        renderer.render(scene, cameraNX1);
        renderer.setRenderTarget(renderTarget1, 2);
        renderer.render(scene, cameraPY1);
        renderer.setRenderTarget(renderTarget1, 3);
        renderer.render(scene, cameraNY1);
        renderer.setRenderTarget(renderTarget1, 4);
        renderer.render(scene, cameraPZ1);
        renderTarget1.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget1, 5);
        renderer.render(scene, cameraNZ1);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    }
}
class $267b85717c4872ea$export$2093b765bab902d5 extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(images1, mapping1, wrapS1, wrapT1, magFilter1, minFilter1, format1, type1, anisotropy1, encoding1){
        images1 = images1 !== undefined ? images1 : [];
        mapping1 = mapping1 !== undefined ? mapping1 : $267b85717c4872ea$export$14b9933b43601226;
        format1 = format1 !== undefined ? format1 : $267b85717c4872ea$export$cb1f224ebfa17eab;
        super(images1, mapping1, wrapS1, wrapT1, magFilter1, minFilter1, format1, type1, anisotropy1, encoding1);
        // Why CubeTexture._needsFlipEnvMap is necessary:
        //
        // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
        // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
        // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
        // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
        // and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
        // when using WebGLCubeRenderTarget.texture as a cube texture.
        this._needsFlipEnvMap = true;
        this.flipY = false;
    }
    get images() {
        return this.image;
    }
    set images(value) {
        this.image = value;
    }
}
$267b85717c4872ea$export$2093b765bab902d5.prototype.isCubeTexture = true;
class $267b85717c4872ea$export$48f3d94ab2a784eb extends $267b85717c4872ea$export$aef5a065c75d61ea {
    constructor(size1, options2, dummy){
        if (Number.isInteger(options2)) {
            console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
            options2 = dummy;
        }
        super(size1, size1, options2);
        options2 = options2 || {
        };
        this.texture = new $267b85717c4872ea$export$2093b765bab902d5(undefined, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.encoding);
        this.texture.generateMipmaps = options2.generateMipmaps !== undefined ? options2.generateMipmaps : false;
        this.texture.minFilter = options2.minFilter !== undefined ? options2.minFilter : $267b85717c4872ea$export$d8f3ba475551f5c1;
        this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.format = $267b85717c4872ea$export$fdd3489947276d08; // see #18859
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: /* glsl */ `\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			`,
            fragmentShader: /* glsl */ `\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			`
        };
        const geometry1 = new $267b85717c4872ea$export$7adcd09f49b1ca3c(5, 5, 5);
        const material1 = new $267b85717c4872ea$export$2a77b7c526ae5937({
            name: 'CubemapFromEquirect',
            uniforms: $267b85717c4872ea$var$cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: $267b85717c4872ea$export$fbde0e233a2945e1,
            blending: $267b85717c4872ea$export$8dd1256cd8ee174c
        });
        material1.uniforms.tEquirect.value = texture;
        const mesh = new $267b85717c4872ea$export$4cdb671a7054bbf9(geometry1, material1);
        const currentMinFilter = texture.minFilter;
        // Avoid blurred poles
        if (texture.minFilter === $267b85717c4872ea$export$f4f4190ac785556) texture.minFilter = $267b85717c4872ea$export$d8f3ba475551f5c1;
        const camera = new $267b85717c4872ea$export$62bcc2046b614bc8(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
    }
    clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i2 = 0; i2 < 6; i2++){
            renderer.setRenderTarget(this, i2);
            renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    }
}
$267b85717c4872ea$export$48f3d94ab2a784eb.prototype.isWebGLCubeRenderTarget = true;
const $267b85717c4872ea$var$_vector1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vector2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_normalMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$6b1dbb040148d435();
class $267b85717c4872ea$export$eff7a5260ebddee8 {
    constructor(normal1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 0, 0), constant1 = 0){
        // normal is assumed to be normalized
        this.normal = normal1;
        this.constant = constant1;
    }
    set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
    }
    setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
    }
    setFromCoplanarPoints(a, b, c) {
        const normal2 = $267b85717c4872ea$var$_vector1.subVectors(c, b).cross($267b85717c4872ea$var$_vector2.subVectors(a, b)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal2, a);
        return this;
    }
    copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    }
    normalize() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    }
    negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    }
    distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
        const direction2 = line.delta($267b85717c4872ea$var$_vector1);
        const denominator = this.normal.dot(direction2);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return null;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return null;
        return target.copy(direction2).multiplyScalar(t).add(line.start);
    }
    intersectsLine(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
        return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || $267b85717c4872ea$var$_normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint($267b85717c4872ea$var$_vector1).applyMatrix4(matrix);
        const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal2);
        return this;
    }
    translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    }
    equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
$267b85717c4872ea$export$eff7a5260ebddee8.prototype.isPlane = true;
const $267b85717c4872ea$var$_sphere$2 = /*@__PURE__*/ new $267b85717c4872ea$export$48b052fa5734fd42();
const $267b85717c4872ea$var$_vector$7 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$6ef72105b8c3e2c6 {
    constructor(p01 = new $267b85717c4872ea$export$eff7a5260ebddee8(), p11 = new $267b85717c4872ea$export$eff7a5260ebddee8(), p21 = new $267b85717c4872ea$export$eff7a5260ebddee8(), p31 = new $267b85717c4872ea$export$eff7a5260ebddee8(), p41 = new $267b85717c4872ea$export$eff7a5260ebddee8(), p51 = new $267b85717c4872ea$export$eff7a5260ebddee8()){
        this.planes = [
            p01,
            p11,
            p21,
            p31,
            p41,
            p51
        ];
    }
    set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    }
    copy(frustum) {
        const planes = this.planes;
        for(let i2 = 0; i2 < 6; i2++)planes[i2].copy(frustum.planes[i2]);
        return this;
    }
    setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    }
    intersectsObject(object) {
        const geometry1 = object.geometry;
        if (geometry1.boundingSphere === null) geometry1.computeBoundingSphere();
        $267b85717c4872ea$var$_sphere$2.copy(geometry1.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere($267b85717c4872ea$var$_sphere$2);
    }
    intersectsSprite(sprite) {
        $267b85717c4872ea$var$_sphere$2.center.set(0, 0, 0);
        $267b85717c4872ea$var$_sphere$2.radius = 0.7071067811865476;
        $267b85717c4872ea$var$_sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere($267b85717c4872ea$var$_sphere$2);
    }
    intersectsSphere(sphere) {
        const planes = this.planes;
        const center2 = sphere.center;
        const negRadius = -sphere.radius;
        for(let i2 = 0; i2 < 6; i2++){
            const distance = planes[i2].distanceToPoint(center2);
            if (distance < negRadius) return false;
        }
        return true;
    }
    intersectsBox(box) {
        const planes = this.planes;
        for(let i2 = 0; i2 < 6; i2++){
            const plane = planes[i2];
            // corner at max distance
            $267b85717c4872ea$var$_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            $267b85717c4872ea$var$_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            $267b85717c4872ea$var$_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint($267b85717c4872ea$var$_vector$7) < 0) return false;
        }
        return true;
    }
    containsPoint(point) {
        const planes = this.planes;
        for(let i2 = 0; i2 < 6; i2++){
            if (planes[i2].distanceToPoint(point) < 0) return false;
        }
        return true;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
function $267b85717c4872ea$var$WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
        animationLoop(time, frame);
        requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
        start: function() {
            if (isAnimating === true) return;
            if (animationLoop === null) return;
            requestId = context.requestAnimationFrame(onAnimationFrame);
            isAnimating = true;
        },
        stop: function() {
            context.cancelAnimationFrame(requestId);
            isAnimating = false;
        },
        setAnimationLoop: function(callback) {
            animationLoop = callback;
        },
        setContext: function(value) {
            context = value;
        }
    };
}
function $267b85717c4872ea$var$WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array12 = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array12, usage);
        attribute.onUploadCallback();
        let type2 = 5126;
        if (array12 instanceof Float32Array) type2 = 5126;
        else if (array12 instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array12 instanceof Uint16Array) {
            if (attribute.isFloat16BufferAttribute) {
                if (isWebGL2) type2 = 5131;
                else console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
            } else type2 = 5123;
        } else if (array12 instanceof Int16Array) type2 = 5122;
        else if (array12 instanceof Uint32Array) type2 = 5125;
        else if (array12 instanceof Int32Array) type2 = 5124;
        else if (array12 instanceof Int8Array) type2 = 5120;
        else if (array12 instanceof Uint8Array) type2 = 5121;
        else if (array12 instanceof Uint8ClampedArray) type2 = 5121;
        return {
            buffer: buffer,
            type: type2,
            bytesPerElement: array12.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array12 = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array12);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array12.BYTES_PER_ELEMENT, array12, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array12.BYTES_PER_ELEMENT, array12.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isGLBufferAttribute) {
            const cached = buffers.get(attribute);
            if (!cached || cached.version < attribute.version) buffers.set(attribute, {
                buffer: attribute.buffer,
                type: attribute.type,
                bytesPerElement: attribute.elementSize,
                version: attribute.version
            });
            return;
        }
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
class $267b85717c4872ea$export$f5196b7984dc72bd extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(width5 = 1, height5 = 1, widthSegments1 = 1, heightSegments1 = 1){
        super();
        this.type = 'PlaneGeometry';
        this.parameters = {
            width: width5,
            height: height5,
            widthSegments: widthSegments1,
            heightSegments: heightSegments1
        };
        const width_half = width5 / 2;
        const height_half = height5 / 2;
        const gridX = Math.floor(widthSegments1);
        const gridY = Math.floor(heightSegments1);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width5 / gridX;
        const segment_height = height5 / gridY;
        //
        const indices1 = [];
        const vertices1 = [];
        const normals1 = [];
        const uvs1 = [];
        for(let iy = 0; iy < gridY1; iy++){
            const y6 = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x6 = ix * segment_width - width_half;
                vertices1.push(x6, -y6, 0);
                normals1.push(0, 0, 1);
                uvs1.push(ix / gridX);
                uvs1.push(1 - iy / gridY);
            }
        }
        for(let iy1 = 0; iy1 < gridY; iy1++)for(let ix = 0; ix < gridX; ix++){
            const a2 = ix + gridX1 * iy1;
            const b3 = ix + gridX1 * (iy1 + 1);
            const c2 = ix + 1 + gridX1 * (iy1 + 1);
            const d = ix + 1 + gridX1 * iy1;
            indices1.push(a2, b3, d);
            indices1.push(b3, c2, d);
        }
        this.setIndex(indices1);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices1, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals1, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs1, 2));
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$f5196b7984dc72bd(data.width, data.height, data.widthSegments, data.heightSegments);
    }
}
var $267b85717c4872ea$var$alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var $267b85717c4872ea$var$alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var $267b85717c4872ea$var$alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var $267b85717c4872ea$var$aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var $267b85717c4872ea$var$aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var $267b85717c4872ea$var$begin_vertex = "vec3 transformed = vec3( position );";
var $267b85717c4872ea$var$beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var $267b85717c4872ea$var$bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var $267b85717c4872ea$var$bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var $267b85717c4872ea$var$clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var $267b85717c4872ea$var$clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var $267b85717c4872ea$var$clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var $267b85717c4872ea$var$clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var $267b85717c4872ea$var$color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
var $267b85717c4872ea$var$color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
var $267b85717c4872ea$var$color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
var $267b85717c4872ea$var$color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
var $267b85717c4872ea$var$common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var $267b85717c4872ea$var$cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
var $267b85717c4872ea$var$defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var $267b85717c4872ea$var$displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var $267b85717c4872ea$var$displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var $267b85717c4872ea$var$emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var $267b85717c4872ea$var$emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var $267b85717c4872ea$var$encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var $267b85717c4872ea$var$encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var $267b85717c4872ea$var$envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var $267b85717c4872ea$var$envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var $267b85717c4872ea$var$envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var $267b85717c4872ea$var$envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var $267b85717c4872ea$var$envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var $267b85717c4872ea$var$fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";
var $267b85717c4872ea$var$fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var $267b85717c4872ea$var$fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var $267b85717c4872ea$var$fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var $267b85717c4872ea$var$gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var $267b85717c4872ea$var$lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var $267b85717c4872ea$var$lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var $267b85717c4872ea$var$lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var $267b85717c4872ea$var$lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var $267b85717c4872ea$var$envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var $267b85717c4872ea$var$lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var $267b85717c4872ea$var$lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var $267b85717c4872ea$var$lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var $267b85717c4872ea$var$lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var $267b85717c4872ea$var$lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var $267b85717c4872ea$var$lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var $267b85717c4872ea$var$lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var $267b85717c4872ea$var$lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var $267b85717c4872ea$var$lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var $267b85717c4872ea$var$logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var $267b85717c4872ea$var$logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var $267b85717c4872ea$var$logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var $267b85717c4872ea$var$logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var $267b85717c4872ea$var$map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var $267b85717c4872ea$var$map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var $267b85717c4872ea$var$map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var $267b85717c4872ea$var$map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var $267b85717c4872ea$var$metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var $267b85717c4872ea$var$metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var $267b85717c4872ea$var$morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var $267b85717c4872ea$var$morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var $267b85717c4872ea$var$morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var $267b85717c4872ea$var$normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var $267b85717c4872ea$var$normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var $267b85717c4872ea$var$normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
var $267b85717c4872ea$var$clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var $267b85717c4872ea$var$clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
var $267b85717c4872ea$var$clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var $267b85717c4872ea$var$packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var $267b85717c4872ea$var$premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var $267b85717c4872ea$var$project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var $267b85717c4872ea$var$dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var $267b85717c4872ea$var$dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var $267b85717c4872ea$var$roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var $267b85717c4872ea$var$roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var $267b85717c4872ea$var$shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var $267b85717c4872ea$var$shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var $267b85717c4872ea$var$shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var $267b85717c4872ea$var$shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var $267b85717c4872ea$var$skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var $267b85717c4872ea$var$skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var $267b85717c4872ea$var$skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var $267b85717c4872ea$var$skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var $267b85717c4872ea$var$specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var $267b85717c4872ea$var$specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var $267b85717c4872ea$var$tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var $267b85717c4872ea$var$tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var $267b85717c4872ea$var$transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSNMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tnormal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";
var $267b85717c4872ea$var$transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";
var $267b85717c4872ea$var$uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var $267b85717c4872ea$var$uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var $267b85717c4872ea$var$uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var $267b85717c4872ea$var$uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var $267b85717c4872ea$var$uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var $267b85717c4872ea$var$uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var $267b85717c4872ea$var$worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var $267b85717c4872ea$var$background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var $267b85717c4872ea$var$background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var $267b85717c4872ea$var$cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var $267b85717c4872ea$var$cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var $267b85717c4872ea$var$depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var $267b85717c4872ea$var$depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var $267b85717c4872ea$var$distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var $267b85717c4872ea$var$distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var $267b85717c4872ea$var$equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var $267b85717c4872ea$var$equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var $267b85717c4872ea$var$linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var $267b85717c4872ea$var$linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var $267b85717c4872ea$var$meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform vec3 attenuationColor;\n\tuniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var $267b85717c4872ea$var$meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";
var $267b85717c4872ea$var$normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var $267b85717c4872ea$var$normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var $267b85717c4872ea$var$points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var $267b85717c4872ea$var$points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var $267b85717c4872ea$var$shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var $267b85717c4872ea$var$sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var $267b85717c4872ea$var$sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const $267b85717c4872ea$export$dfbc21f88d2cbdc4 = {
    alphamap_fragment: $267b85717c4872ea$var$alphamap_fragment,
    alphamap_pars_fragment: $267b85717c4872ea$var$alphamap_pars_fragment,
    alphatest_fragment: $267b85717c4872ea$var$alphatest_fragment,
    aomap_fragment: $267b85717c4872ea$var$aomap_fragment,
    aomap_pars_fragment: $267b85717c4872ea$var$aomap_pars_fragment,
    begin_vertex: $267b85717c4872ea$var$begin_vertex,
    beginnormal_vertex: $267b85717c4872ea$var$beginnormal_vertex,
    bsdfs: $267b85717c4872ea$var$bsdfs,
    bumpmap_pars_fragment: $267b85717c4872ea$var$bumpmap_pars_fragment,
    clipping_planes_fragment: $267b85717c4872ea$var$clipping_planes_fragment,
    clipping_planes_pars_fragment: $267b85717c4872ea$var$clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: $267b85717c4872ea$var$clipping_planes_pars_vertex,
    clipping_planes_vertex: $267b85717c4872ea$var$clipping_planes_vertex,
    color_fragment: $267b85717c4872ea$var$color_fragment,
    color_pars_fragment: $267b85717c4872ea$var$color_pars_fragment,
    color_pars_vertex: $267b85717c4872ea$var$color_pars_vertex,
    color_vertex: $267b85717c4872ea$var$color_vertex,
    common: $267b85717c4872ea$var$common,
    cube_uv_reflection_fragment: $267b85717c4872ea$var$cube_uv_reflection_fragment,
    defaultnormal_vertex: $267b85717c4872ea$var$defaultnormal_vertex,
    displacementmap_pars_vertex: $267b85717c4872ea$var$displacementmap_pars_vertex,
    displacementmap_vertex: $267b85717c4872ea$var$displacementmap_vertex,
    emissivemap_fragment: $267b85717c4872ea$var$emissivemap_fragment,
    emissivemap_pars_fragment: $267b85717c4872ea$var$emissivemap_pars_fragment,
    encodings_fragment: $267b85717c4872ea$var$encodings_fragment,
    encodings_pars_fragment: $267b85717c4872ea$var$encodings_pars_fragment,
    envmap_fragment: $267b85717c4872ea$var$envmap_fragment,
    envmap_common_pars_fragment: $267b85717c4872ea$var$envmap_common_pars_fragment,
    envmap_pars_fragment: $267b85717c4872ea$var$envmap_pars_fragment,
    envmap_pars_vertex: $267b85717c4872ea$var$envmap_pars_vertex,
    envmap_physical_pars_fragment: $267b85717c4872ea$var$envmap_physical_pars_fragment,
    envmap_vertex: $267b85717c4872ea$var$envmap_vertex,
    fog_vertex: $267b85717c4872ea$var$fog_vertex,
    fog_pars_vertex: $267b85717c4872ea$var$fog_pars_vertex,
    fog_fragment: $267b85717c4872ea$var$fog_fragment,
    fog_pars_fragment: $267b85717c4872ea$var$fog_pars_fragment,
    gradientmap_pars_fragment: $267b85717c4872ea$var$gradientmap_pars_fragment,
    lightmap_fragment: $267b85717c4872ea$var$lightmap_fragment,
    lightmap_pars_fragment: $267b85717c4872ea$var$lightmap_pars_fragment,
    lights_lambert_vertex: $267b85717c4872ea$var$lights_lambert_vertex,
    lights_pars_begin: $267b85717c4872ea$var$lights_pars_begin,
    lights_toon_fragment: $267b85717c4872ea$var$lights_toon_fragment,
    lights_toon_pars_fragment: $267b85717c4872ea$var$lights_toon_pars_fragment,
    lights_phong_fragment: $267b85717c4872ea$var$lights_phong_fragment,
    lights_phong_pars_fragment: $267b85717c4872ea$var$lights_phong_pars_fragment,
    lights_physical_fragment: $267b85717c4872ea$var$lights_physical_fragment,
    lights_physical_pars_fragment: $267b85717c4872ea$var$lights_physical_pars_fragment,
    lights_fragment_begin: $267b85717c4872ea$var$lights_fragment_begin,
    lights_fragment_maps: $267b85717c4872ea$var$lights_fragment_maps,
    lights_fragment_end: $267b85717c4872ea$var$lights_fragment_end,
    logdepthbuf_fragment: $267b85717c4872ea$var$logdepthbuf_fragment,
    logdepthbuf_pars_fragment: $267b85717c4872ea$var$logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: $267b85717c4872ea$var$logdepthbuf_pars_vertex,
    logdepthbuf_vertex: $267b85717c4872ea$var$logdepthbuf_vertex,
    map_fragment: $267b85717c4872ea$var$map_fragment,
    map_pars_fragment: $267b85717c4872ea$var$map_pars_fragment,
    map_particle_fragment: $267b85717c4872ea$var$map_particle_fragment,
    map_particle_pars_fragment: $267b85717c4872ea$var$map_particle_pars_fragment,
    metalnessmap_fragment: $267b85717c4872ea$var$metalnessmap_fragment,
    metalnessmap_pars_fragment: $267b85717c4872ea$var$metalnessmap_pars_fragment,
    morphnormal_vertex: $267b85717c4872ea$var$morphnormal_vertex,
    morphtarget_pars_vertex: $267b85717c4872ea$var$morphtarget_pars_vertex,
    morphtarget_vertex: $267b85717c4872ea$var$morphtarget_vertex,
    normal_fragment_begin: $267b85717c4872ea$var$normal_fragment_begin,
    normal_fragment_maps: $267b85717c4872ea$var$normal_fragment_maps,
    normalmap_pars_fragment: $267b85717c4872ea$var$normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: $267b85717c4872ea$var$clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: $267b85717c4872ea$var$clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: $267b85717c4872ea$var$clearcoat_pars_fragment,
    packing: $267b85717c4872ea$var$packing,
    premultiplied_alpha_fragment: $267b85717c4872ea$var$premultiplied_alpha_fragment,
    project_vertex: $267b85717c4872ea$var$project_vertex,
    dithering_fragment: $267b85717c4872ea$var$dithering_fragment,
    dithering_pars_fragment: $267b85717c4872ea$var$dithering_pars_fragment,
    roughnessmap_fragment: $267b85717c4872ea$var$roughnessmap_fragment,
    roughnessmap_pars_fragment: $267b85717c4872ea$var$roughnessmap_pars_fragment,
    shadowmap_pars_fragment: $267b85717c4872ea$var$shadowmap_pars_fragment,
    shadowmap_pars_vertex: $267b85717c4872ea$var$shadowmap_pars_vertex,
    shadowmap_vertex: $267b85717c4872ea$var$shadowmap_vertex,
    shadowmask_pars_fragment: $267b85717c4872ea$var$shadowmask_pars_fragment,
    skinbase_vertex: $267b85717c4872ea$var$skinbase_vertex,
    skinning_pars_vertex: $267b85717c4872ea$var$skinning_pars_vertex,
    skinning_vertex: $267b85717c4872ea$var$skinning_vertex,
    skinnormal_vertex: $267b85717c4872ea$var$skinnormal_vertex,
    specularmap_fragment: $267b85717c4872ea$var$specularmap_fragment,
    specularmap_pars_fragment: $267b85717c4872ea$var$specularmap_pars_fragment,
    tonemapping_fragment: $267b85717c4872ea$var$tonemapping_fragment,
    tonemapping_pars_fragment: $267b85717c4872ea$var$tonemapping_pars_fragment,
    transmission_fragment: $267b85717c4872ea$var$transmission_fragment,
    transmission_pars_fragment: $267b85717c4872ea$var$transmission_pars_fragment,
    uv_pars_fragment: $267b85717c4872ea$var$uv_pars_fragment,
    uv_pars_vertex: $267b85717c4872ea$var$uv_pars_vertex,
    uv_vertex: $267b85717c4872ea$var$uv_vertex,
    uv2_pars_fragment: $267b85717c4872ea$var$uv2_pars_fragment,
    uv2_pars_vertex: $267b85717c4872ea$var$uv2_pars_vertex,
    uv2_vertex: $267b85717c4872ea$var$uv2_vertex,
    worldpos_vertex: $267b85717c4872ea$var$worldpos_vertex,
    background_frag: $267b85717c4872ea$var$background_frag,
    background_vert: $267b85717c4872ea$var$background_vert,
    cube_frag: $267b85717c4872ea$var$cube_frag,
    cube_vert: $267b85717c4872ea$var$cube_vert,
    depth_frag: $267b85717c4872ea$var$depth_frag,
    depth_vert: $267b85717c4872ea$var$depth_vert,
    distanceRGBA_frag: $267b85717c4872ea$var$distanceRGBA_frag,
    distanceRGBA_vert: $267b85717c4872ea$var$distanceRGBA_vert,
    equirect_frag: $267b85717c4872ea$var$equirect_frag,
    equirect_vert: $267b85717c4872ea$var$equirect_vert,
    linedashed_frag: $267b85717c4872ea$var$linedashed_frag,
    linedashed_vert: $267b85717c4872ea$var$linedashed_vert,
    meshbasic_frag: $267b85717c4872ea$var$meshbasic_frag,
    meshbasic_vert: $267b85717c4872ea$var$meshbasic_vert,
    meshlambert_frag: $267b85717c4872ea$var$meshlambert_frag,
    meshlambert_vert: $267b85717c4872ea$var$meshlambert_vert,
    meshmatcap_frag: $267b85717c4872ea$var$meshmatcap_frag,
    meshmatcap_vert: $267b85717c4872ea$var$meshmatcap_vert,
    meshtoon_frag: $267b85717c4872ea$var$meshtoon_frag,
    meshtoon_vert: $267b85717c4872ea$var$meshtoon_vert,
    meshphong_frag: $267b85717c4872ea$var$meshphong_frag,
    meshphong_vert: $267b85717c4872ea$var$meshphong_vert,
    meshphysical_frag: $267b85717c4872ea$var$meshphysical_frag,
    meshphysical_vert: $267b85717c4872ea$var$meshphysical_vert,
    normal_frag: $267b85717c4872ea$var$normal_frag,
    normal_vert: $267b85717c4872ea$var$normal_vert,
    points_frag: $267b85717c4872ea$var$points_frag,
    points_vert: $267b85717c4872ea$var$points_vert,
    shadow_frag: $267b85717c4872ea$var$shadow_frag,
    shadow_vert: $267b85717c4872ea$var$shadow_vert,
    sprite_frag: $267b85717c4872ea$var$sprite_frag,
    sprite_vert: $267b85717c4872ea$var$sprite_vert
};
/**
 * Uniforms library for shared webgl shaders
 */ const $267b85717c4872ea$export$167843c98993dbe3 = {
    common: {
        diffuse: {
            value: new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new $267b85717c4872ea$export$6b1dbb040148d435()
        },
        uv2Transform: {
            value: new $267b85717c4872ea$export$6b1dbb040148d435()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {
                },
                color: {
                }
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                direction: {
                },
                distance: {
                },
                coneCos: {
                },
                penumbraCos: {
                },
                decay: {
                }
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                decay: {
                },
                distance: {
                }
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                },
                shadowCameraNear: {
                },
                shadowCameraFar: {
                }
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {
                },
                skyColor: {
                },
                groundColor: {
                }
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                width: {
                },
                height: {
                }
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new $267b85717c4872ea$export$6b1dbb040148d435()
        }
    },
    sprite: {
        diffuse: {
            value: new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new $267b85717c4872ea$export$95d9e1e745cc7977(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new $267b85717c4872ea$export$6b1dbb040148d435()
        }
    }
};
const $267b85717c4872ea$export$c8b76cbbe298b27f = {
    basic: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.specularmap,
            $267b85717c4872ea$export$167843c98993dbe3.envmap,
            $267b85717c4872ea$export$167843c98993dbe3.aomap,
            $267b85717c4872ea$export$167843c98993dbe3.lightmap,
            $267b85717c4872ea$export$167843c98993dbe3.fog
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshbasic_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshbasic_frag
    },
    lambert: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.specularmap,
            $267b85717c4872ea$export$167843c98993dbe3.envmap,
            $267b85717c4872ea$export$167843c98993dbe3.aomap,
            $267b85717c4872ea$export$167843c98993dbe3.lightmap,
            $267b85717c4872ea$export$167843c98993dbe3.emissivemap,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            $267b85717c4872ea$export$167843c98993dbe3.lights,
            {
                emissive: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshlambert_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshlambert_frag
    },
    phong: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.specularmap,
            $267b85717c4872ea$export$167843c98993dbe3.envmap,
            $267b85717c4872ea$export$167843c98993dbe3.aomap,
            $267b85717c4872ea$export$167843c98993dbe3.lightmap,
            $267b85717c4872ea$export$167843c98993dbe3.emissivemap,
            $267b85717c4872ea$export$167843c98993dbe3.bumpmap,
            $267b85717c4872ea$export$167843c98993dbe3.normalmap,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            $267b85717c4872ea$export$167843c98993dbe3.lights,
            {
                emissive: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
                },
                specular: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphong_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphong_frag
    },
    standard: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.envmap,
            $267b85717c4872ea$export$167843c98993dbe3.aomap,
            $267b85717c4872ea$export$167843c98993dbe3.lightmap,
            $267b85717c4872ea$export$167843c98993dbe3.emissivemap,
            $267b85717c4872ea$export$167843c98993dbe3.bumpmap,
            $267b85717c4872ea$export$167843c98993dbe3.normalmap,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            $267b85717c4872ea$export$167843c98993dbe3.roughnessmap,
            $267b85717c4872ea$export$167843c98993dbe3.metalnessmap,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            $267b85717c4872ea$export$167843c98993dbe3.lights,
            {
                emissive: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                } // temporary
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphysical_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphysical_frag
    },
    toon: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.aomap,
            $267b85717c4872ea$export$167843c98993dbe3.lightmap,
            $267b85717c4872ea$export$167843c98993dbe3.emissivemap,
            $267b85717c4872ea$export$167843c98993dbe3.bumpmap,
            $267b85717c4872ea$export$167843c98993dbe3.normalmap,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            $267b85717c4872ea$export$167843c98993dbe3.gradientmap,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            $267b85717c4872ea$export$167843c98993dbe3.lights,
            {
                emissive: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshtoon_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshtoon_frag
    },
    matcap: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.bumpmap,
            $267b85717c4872ea$export$167843c98993dbe3.normalmap,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshmatcap_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshmatcap_frag
    },
    points: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.points,
            $267b85717c4872ea$export$167843c98993dbe3.fog
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.points_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.points_frag
    },
    dashed: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.linedashed_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.linedashed_frag
    },
    depth: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.depth_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.depth_frag
    },
    normal: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.bumpmap,
            $267b85717c4872ea$export$167843c98993dbe3.normalmap,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.normal_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.normal_frag
    },
    sprite: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.sprite,
            $267b85717c4872ea$export$167843c98993dbe3.fog
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.sprite_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new $267b85717c4872ea$export$6b1dbb040148d435()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.background_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */ cube: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.cube_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.equirect_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.equirect_frag
    },
    distanceRGBA: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.common,
            $267b85717c4872ea$export$167843c98993dbe3.displacementmap,
            {
                referencePosition: {
                    value: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.distanceRGBA_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.distanceRGBA_frag
    },
    shadow: {
        uniforms: $267b85717c4872ea$var$mergeUniforms([
            $267b85717c4872ea$export$167843c98993dbe3.lights,
            $267b85717c4872ea$export$167843c98993dbe3.fog,
            {
                color: {
                    value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.shadow_vert,
        fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.shadow_frag
    }
};
$267b85717c4872ea$export$c8b76cbbe298b27f.physical = {
    uniforms: $267b85717c4872ea$var$mergeUniforms([
        $267b85717c4872ea$export$c8b76cbbe298b27f.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new $267b85717c4872ea$export$95d9e1e745cc7977()
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new $267b85717c4872ea$export$e4830c8e55b4f80d(0)
            }
        }
    ]),
    vertexShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphysical_vert,
    fragmentShader: $267b85717c4872ea$export$dfbc21f88d2cbdc4.meshphysical_frag
};
function $267b85717c4872ea$var$WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene) {
        let forceClear = false;
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.mapping === $267b85717c4872ea$export$fb3ca8bcae285728)) {
            if (boxMesh === undefined) {
                boxMesh = new $267b85717c4872ea$export$4cdb671a7054bbf9(new $267b85717c4872ea$export$7adcd09f49b1ca3c(1, 1, 1), new $267b85717c4872ea$export$2a77b7c526ae5937({
                    name: 'BackgroundCubeMaterial',
                    uniforms: $267b85717c4872ea$var$cloneUniforms($267b85717c4872ea$export$c8b76cbbe298b27f.cube.uniforms),
                    vertexShader: $267b85717c4872ea$export$c8b76cbbe298b27f.cube.vertexShader,
                    fragmentShader: $267b85717c4872ea$export$c8b76cbbe298b27f.cube.fragmentShader,
                    side: $267b85717c4872ea$export$fbde0e233a2945e1,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer1, scene1, camera) {
                    this.matrixWorld.copyPosition(camera.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new $267b85717c4872ea$export$4cdb671a7054bbf9(new $267b85717c4872ea$export$f5196b7984dc72bd(2, 2), new $267b85717c4872ea$export$2a77b7c526ae5937({
                    name: 'BackgroundMaterial',
                    uniforms: $267b85717c4872ea$var$cloneUniforms($267b85717c4872ea$export$c8b76cbbe298b27f.background.uniforms),
                    vertexShader: $267b85717c4872ea$export$c8b76cbbe298b27f.background.vertexShader,
                    fragmentShader: $267b85717c4872ea$export$c8b76cbbe298b27f.background.fragmentShader,
                    side: $267b85717c4872ea$export$9b320e6c690b4c3e,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color, alpha) {
        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color, alpha = 1) {
            clearColor.set(color);
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
function $267b85717c4872ea$var$WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {
    };
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material1, program, geometry1, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry1, program, material1);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry1, index);
            if (updateBuffers) saveCache(geometry1, index);
        } else {
            const wireframe = material1.wireframe === true;
            if (currentState.geometry !== geometry1.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry1.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes.update(index, 34963);
        if (updateBuffers) {
            setupVertexAttributes(object, material1, program, geometry1);
            if (index !== null) gl.bindBuffer(34963, attributes.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry1, program, material1) {
        const wireframe = material1.wireframe === true;
        let programMap = bindingStates[geometry1.id];
        if (programMap === undefined) {
            programMap = {
            };
            bindingStates[geometry1.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {
            };
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i2 = 0; i2 < maxVertexAttributes; i2++){
            newAttributes[i2] = 0;
            enabledAttributes[i2] = 0;
            attributeDivisors[i2] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {
            },
            index: null
        };
    }
    function needsUpdate(geometry1, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry1.attributes;
        let attributesNum = 0;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
            attributesNum++;
        }
        if (currentState.attributesNum !== attributesNum) return true;
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry1, index) {
        const cache = {
        };
        const attributes1 = geometry1.attributes;
        let attributesNum = 0;
        for(const key in attributes1){
            const attribute = attributes1[key];
            const data = {
            };
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
            attributesNum++;
        }
        currentState.attributes = cache;
        currentState.attributesNum = attributesNum;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i2 = 0, il = newAttributes.length; i2 < il; i2++)newAttributes[i2] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension1 = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension1[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i2 = 0, il = enabledAttributes.length; i2 < il; i2++)if (enabledAttributes[i2] !== newAttributes[i2]) {
            gl.disableVertexAttribArray(i2);
            enabledAttributes[i2] = 0;
        }
    }
    function vertexAttribPointer(index, size1, type2, normalized11, stride, offset) {
        if (capabilities.isWebGL2 === true && (type2 === 5124 || type2 === 5125)) gl.vertexAttribIPointer(index, size1, type2, stride, offset);
        else gl.vertexAttribPointer(index, size1, type2, normalized11, stride, offset);
    }
    function setupVertexAttributes(object, material1, program, geometry1) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry1.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry1.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material1.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized11 = geometryAttribute.normalized;
                    const size1 = geometryAttribute.itemSize;
                    const attribute = attributes.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type2 = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry1._maxInstanceCount === undefined) geometry1._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size1, type2, normalized11, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry1._maxInstanceCount === undefined) geometry1._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(34962, buffer);
                        vertexAttribPointer(programAttribute, size1, type2, normalized11, 0, 0);
                    }
                } else if (name === 'instanceMatrix') {
                    const attribute = attributes.get(object.instanceMatrix);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type2 = attribute.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(34962, buffer);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type2, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type2, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type2, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type2, false, 64, 48);
                } else if (name === 'instanceColor') {
                    const attribute = attributes.get(object.instanceColor);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type2 = attribute.type;
                    enableAttributeAndDivisor(programAttribute, 1);
                    gl.bindBuffer(34962, buffer);
                    gl.vertexAttribPointer(programAttribute, 3, type2, false, 12, 0);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry1) {
        if (bindingStates[geometry1.id] === undefined) return;
        const programMap = bindingStates[geometry1.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry1.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatilibity
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
function $267b85717c4872ea$var$WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count2) {
        gl.drawArrays(mode, start, count2);
        info.update(count2, mode, 1);
    }
    function renderInstances(start, count2, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawArraysInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawArraysInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count2, primcount);
        info.update(count2, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
function $267b85717c4872ea$var$WebGLCapabilities(gl, extensions, parameters2) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
            const extension = extensions.get('EXT_texture_filter_anisotropic');
            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) return 'highp';
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    /* eslint-disable no-undef */ const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    /* eslint-enable no-undef */ let precision = parameters2.precision !== undefined ? parameters2.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
        precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
    const logarithmicDepthBuffer = parameters2.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
        isWebGL2: isWebGL2,
        drawBuffers: drawBuffers,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
function $267b85717c4872ea$var$WebGLClipping(properties) {
    const scope1 = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new $267b85717c4872ea$export$eff7a5260ebddee8(), viewNormalMatrix = new $267b85717c4872ea$export$6b1dbb040148d435(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(material1, camera, useCache) {
        const planes = material1.clippingPlanes, clipIntersection = material1.clipIntersection, clipShadows = material1.clipShadows;
        const materialProperties = properties.get(material1);
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = materialProperties.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
            for(let i2 = 0; i2 !== lGlobal; ++i2)dstArray[i2] = globalState[i2];
            materialProperties.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope1.numPlanes = numGlobalPlanes;
        scope1.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4){
                    plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope1.numPlanes = nPlanes;
        scope1.numIntersection = 0;
        return dstArray;
    }
}
function $267b85717c4872ea$var$WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture2, mapping2) {
        if (mapping2 === $267b85717c4872ea$export$2fcdd5238f6d0712) texture2.mapping = $267b85717c4872ea$export$14b9933b43601226;
        else if (mapping2 === $267b85717c4872ea$export$84dcc0fe92473f5c) texture2.mapping = $267b85717c4872ea$export$2be972fd003606e2;
        return texture2;
    }
    function get(texture2) {
        if (texture2 && texture2.isTexture) {
            const mapping2 = texture2.mapping;
            if (mapping2 === $267b85717c4872ea$export$2fcdd5238f6d0712 || mapping2 === $267b85717c4872ea$export$84dcc0fe92473f5c) {
                if (cubemaps.has(texture2)) {
                    const cubemap = cubemaps.get(texture2).texture;
                    return mapTextureMapping(cubemap, texture2.mapping);
                } else {
                    const image1 = texture2.image;
                    if (image1 && image1.height > 0) {
                        const currentRenderTarget = renderer.getRenderTarget();
                        const renderTarget1 = new $267b85717c4872ea$export$48f3d94ab2a784eb(image1.height / 2);
                        renderTarget1.fromEquirectangularTexture(renderer, texture2);
                        cubemaps.set(texture2, renderTarget1);
                        renderer.setRenderTarget(currentRenderTarget);
                        texture2.addEventListener('dispose', onTextureDispose);
                        return mapTextureMapping(renderTarget1.texture, texture2.mapping);
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture2;
    }
    function onTextureDispose(event) {
        const texture2 = event.target;
        texture2.removeEventListener('dispose', onTextureDispose);
        const cubemap = cubemaps.get(texture2);
        if (cubemap !== undefined) {
            cubemaps.delete(texture2);
            cubemap.dispose();
        }
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function $267b85717c4872ea$var$WebGLExtensions(gl) {
    const extensions = {
    };
    function getExtension(name) {
        if (extensions[name] !== undefined) return extensions[name];
        let extension;
        switch(name){
            case 'WEBGL_depth_texture':
                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                break;
            case 'EXT_texture_filter_anisotropic':
                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                break;
            case 'WEBGL_compressed_texture_s3tc':
                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                break;
            case 'WEBGL_compressed_texture_pvrtc':
                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                break;
            default:
                extension = gl.getExtension(name);
        }
        extensions[name] = extension;
        return extension;
    }
    return {
        has: function(name) {
            return getExtension(name) !== null;
        },
        init: function(capabilities) {
            if (capabilities.isWebGL2) getExtension('EXT_color_buffer_float');
            else {
                getExtension('WEBGL_depth_texture');
                getExtension('OES_texture_float');
                getExtension('OES_texture_half_float');
                getExtension('OES_texture_half_float_linear');
                getExtension('OES_standard_derivatives');
                getExtension('OES_element_index_uint');
                getExtension('OES_vertex_array_object');
                getExtension('ANGLE_instanced_arrays');
            }
            getExtension('OES_texture_float_linear');
            getExtension('EXT_color_buffer_half_float');
        },
        get: function(name) {
            const extension = getExtension(name);
            if (extension === null) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            return extension;
        }
    };
}
function $267b85717c4872ea$var$WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {
    };
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry1 = event.target;
        if (geometry1.index !== null) attributes.remove(geometry1.index);
        for(const name in geometry1.attributes)attributes.remove(geometry1.attributes[name]);
        geometry1.removeEventListener('dispose', onGeometryDispose);
        delete geometries[geometry1.id];
        const attribute = wireframeAttributes.get(geometry1);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(geometry1);
        }
        bindingStates.releaseStatesOfGeometry(geometry1);
        if (geometry1.isInstancedBufferGeometry === true) delete geometry1._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry1) {
        if (geometries[geometry1.id] === true) return geometry1;
        geometry1.addEventListener('dispose', onGeometryDispose);
        geometries[geometry1.id] = true;
        info.memory.geometries++;
        return geometry1;
    }
    function update(geometry1) {
        const geometryAttributes = geometry1.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], 34962);
        // morph targets
        const morphAttributes = geometry1.morphAttributes;
        for(const name1 in morphAttributes){
            const array12 = morphAttributes[name1];
            for(let i2 = 0, l = array12.length; i2 < l; i2++)attributes.update(array12[i2], 34962);
        }
    }
    function updateWireframeAttribute(geometry1) {
        const indices2 = [];
        const geometryIndex = geometry1.index;
        const geometryPosition = geometry1.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array12 = geometryIndex.array;
            version = geometryIndex.version;
            for(let i2 = 0, l = array12.length; i2 < l; i2 += 3){
                const a2 = array12[i2 + 0];
                const b3 = array12[i2 + 1];
                const c2 = array12[i2 + 2];
                indices2.push(a2, b3, b3, c2, c2, a2);
            }
        } else {
            const array12 = geometryPosition.array;
            version = geometryPosition.version;
            for(let i2 = 0, l = array12.length / 3 - 1; i2 < l; i2 += 3){
                const a2 = i2 + 0;
                const b3 = i2 + 1;
                const c2 = i2 + 2;
                indices2.push(a2, b3, b3, c2, c2, a2);
            }
        }
        const attribute = new ($267b85717c4872ea$var$arrayMax(indices2) > 65535 ? $267b85717c4872ea$export$f86c6826769eb286 : $267b85717c4872ea$export$1673be55325c3b52)(indices2, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry1);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry1, attribute);
    }
    function getWireframeAttribute(geometry1) {
        const currentAttribute = wireframeAttributes.get(geometry1);
        if (currentAttribute) {
            const geometryIndex = geometry1.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry1);
            }
        } else updateWireframeAttribute(geometry1);
        return wireframeAttributes.get(geometry1);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
function $267b85717c4872ea$var$WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type2, bytesPerElement;
    function setIndex(value) {
        type2 = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count2) {
        gl.drawElements(mode, count2, type2, start * bytesPerElement);
        info.update(count2, mode, 1);
    }
    function renderInstances(start, count2, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawElementsInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawElementsInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count2, type2, start * bytesPerElement, primcount);
        info.update(count2, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
function $267b85717c4872ea$var$WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count2, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case 4:
                render.triangles += instanceCount * (count2 / 3);
                break;
            case 1:
                render.lines += instanceCount * (count2 / 2);
                break;
            case 3:
                render.lines += instanceCount * (count2 - 1);
                break;
            case 2:
                render.lines += instanceCount * count2;
                break;
            case 0:
                render.points += instanceCount * count2;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
function $267b85717c4872ea$var$numericalSort(a2, b3) {
    return a2[0] - b3[0];
}
function $267b85717c4872ea$var$absNumericalSort(a2, b3) {
    return Math.abs(b3[1]) - Math.abs(a2[1]);
}
function $267b85717c4872ea$var$WebGLMorphtargets(gl) {
    const influencesList = {
    };
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i2 = 0; i2 < 8; i2++)workInfluences[i2] = [
        i2,
        0
    ];
    function update(object, geometry1, material1, program) {
        const objectInfluences = object.morphTargetInfluences;
        // When object doesn't have morph target influences defined, we treat it as a 0-length array
        // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry1.id];
        if (influences === undefined || influences.length !== length) {
            // initialise list
            influences = [];
            for(let i3 = 0; i3 < length; i3++)influences[i3] = [
                i3,
                0
            ];
            influencesList[geometry1.id] = influences;
        }
        // Collect influences
        for(let i3 = 0; i3 < length; i3++){
            const influence = influences[i3];
            influence[0] = i3;
            influence[1] = objectInfluences[i3];
        }
        influences.sort($267b85717c4872ea$var$absNumericalSort);
        for(let i4 = 0; i4 < 8; i4++)if (i4 < length && influences[i4][1]) {
            workInfluences[i4][0] = influences[i4][0];
            workInfluences[i4][1] = influences[i4][1];
        } else {
            workInfluences[i4][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i4][1] = 0;
        }
        workInfluences.sort($267b85717c4872ea$var$numericalSort);
        const morphTargets = material1.morphTargets && geometry1.morphAttributes.position;
        const morphNormals = material1.morphNormals && geometry1.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i5 = 0; i5 < 8; i5++){
            const influence = workInfluences[i5];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry1.getAttribute('morphTarget' + i5) !== morphTargets[index]) geometry1.setAttribute('morphTarget' + i5, morphTargets[index]);
                if (morphNormals && geometry1.getAttribute('morphNormal' + i5) !== morphNormals[index]) geometry1.setAttribute('morphNormal' + i5, morphNormals[index]);
                morphInfluences[i5] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry1.hasAttribute('morphTarget' + i5) === true) geometry1.deleteAttribute('morphTarget' + i5);
                if (morphNormals && geometry1.hasAttribute('morphNormal' + i5) === true) geometry1.deleteAttribute('morphNormal' + i5);
                morphInfluences[i5] = 0;
            }
        }
        // GLSL shader uses formula baseinfluence * base + sum(target * influence)
        // This allows us to switch between absolute morphs and relative morphs without changing shader code
        // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
        const morphBaseInfluence = geometry1.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
function $267b85717c4872ea$var$WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry1 = object.geometry;
        const buffergeometry = geometries.get(object, geometry1);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) object.addEventListener('dispose', onInstancedMeshDispose);
            attributes.update(object.instanceMatrix, 34962);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, 34962);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
        const instancedMesh = event.target;
        instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
        attributes.remove(instancedMesh.instanceMatrix);
        if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
    }
    return {
        update: update,
        dispose: dispose
    };
}
class $267b85717c4872ea$export$9cd8a94f64312883 extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(data2 = null, width6 = 1, height6 = 1, depth2 = 1){
        super(null);
        this.image = {
            data: data2,
            width: width6,
            height: height6,
            depth: depth2
        };
        this.magFilter = $267b85717c4872ea$export$f8b53649f0062e3e;
        this.minFilter = $267b85717c4872ea$export$f8b53649f0062e3e;
        this.wrapR = $267b85717c4872ea$export$73b90a84ed7db63c;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
$267b85717c4872ea$export$9cd8a94f64312883.prototype.isDataTexture2DArray = true;
class $267b85717c4872ea$export$55b418672f00e447 extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(data1 = null, width7 = 1, height7 = 1, depth3 = 1){
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	const texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
        super(null);
        this.image = {
            data: data1,
            width: width7,
            height: height7,
            depth: depth3
        };
        this.magFilter = $267b85717c4872ea$export$f8b53649f0062e3e;
        this.minFilter = $267b85717c4872ea$export$f8b53649f0062e3e;
        this.wrapR = $267b85717c4872ea$export$73b90a84ed7db63c;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
$267b85717c4872ea$export$55b418672f00e447.prototype.isDataTexture3D = true;
/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */ const $267b85717c4872ea$var$emptyTexture = new $267b85717c4872ea$export$1cad442f1a6e549f();
const $267b85717c4872ea$var$emptyTexture2dArray = new $267b85717c4872ea$export$9cd8a94f64312883();
const $267b85717c4872ea$var$emptyTexture3d = new $267b85717c4872ea$export$55b418672f00e447();
const $267b85717c4872ea$var$emptyCubeTexture = new $267b85717c4872ea$export$2093b765bab902d5();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const $267b85717c4872ea$var$arrayCacheF32 = [];
const $267b85717c4872ea$var$arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const $267b85717c4872ea$var$mat4array = new Float32Array(16);
const $267b85717c4872ea$var$mat3array = new Float32Array(9);
const $267b85717c4872ea$var$mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function $267b85717c4872ea$var$flatten(array12, nBlocks, blockSize) {
    const firstElem = array12[0];
    if (firstElem <= 0 || firstElem > 0) return array12;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    const n = nBlocks * blockSize;
    let r2 = $267b85717c4872ea$var$arrayCacheF32[n];
    if (r2 === undefined) {
        r2 = new Float32Array(n);
        $267b85717c4872ea$var$arrayCacheF32[n] = r2;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r2, 0);
        for(let i2 = 1, offset = 0; i2 !== nBlocks; ++i2){
            offset += blockSize;
            array12[i2].toArray(r2, offset);
        }
    }
    return r2;
}
function $267b85717c4872ea$var$arraysEqual(a2, b3) {
    if (a2.length !== b3.length) return false;
    for(let i2 = 0, l = a2.length; i2 < l; i2++){
        if (a2[i2] !== b3[i2]) return false;
    }
    return true;
}
function $267b85717c4872ea$var$copyArray(a2, b3) {
    for(let i2 = 0, l = b3.length; i2 < l; i2++)a2[i2] = b3[i2];
}
// Texture unit allocation
function $267b85717c4872ea$var$allocTexUnits(textures, n) {
    let r2 = $267b85717c4872ea$var$arrayCacheI32[n];
    if (r2 === undefined) {
        r2 = new Int32Array(n);
        $267b85717c4872ea$var$arrayCacheI32[n] = r2;
    }
    for(let i2 = 0; i2 !== n; ++i2)r2[i2] = textures.allocateTextureUnit();
    return r2;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function $267b85717c4872ea$var$setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function $267b85717c4872ea$var$setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    }
}
function $267b85717c4872ea$var$setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    }
}
function $267b85717c4872ea$var$setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    }
}
// Single matrix (from flat array or THREE.MatrixN)
function $267b85717c4872ea$var$setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, elements)) return;
        $267b85717c4872ea$var$mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, $267b85717c4872ea$var$mat2array);
        $267b85717c4872ea$var$copyArray(cache, elements);
    }
}
function $267b85717c4872ea$var$setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, elements)) return;
        $267b85717c4872ea$var$mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, $267b85717c4872ea$var$mat3array);
        $267b85717c4872ea$var$copyArray(cache, elements);
    }
}
function $267b85717c4872ea$var$setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        $267b85717c4872ea$var$copyArray(cache, v);
    } else {
        if ($267b85717c4872ea$var$arraysEqual(cache, elements)) return;
        $267b85717c4872ea$var$mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, $267b85717c4872ea$var$mat4array);
        $267b85717c4872ea$var$copyArray(cache, elements);
    }
}
// Single integer / boolean
function $267b85717c4872ea$var$setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
// Single integer / boolean vector (from flat array)
function $267b85717c4872ea$var$setValueV2i(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
function $267b85717c4872ea$var$setValueV3i(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
function $267b85717c4872ea$var$setValueV4i(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
// Single unsigned integer
function $267b85717c4872ea$var$setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Single unsigned integer vector (from flat array)
function $267b85717c4872ea$var$setValueV2ui(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
function $267b85717c4872ea$var$setValueV3ui(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
function $267b85717c4872ea$var$setValueV4ui(gl, v) {
    const cache = this.cache;
    if ($267b85717c4872ea$var$arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    $267b85717c4872ea$var$copyArray(cache, v);
}
// Single texture (2D / Cube)
function $267b85717c4872ea$var$setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || $267b85717c4872ea$var$emptyTexture, unit);
}
function $267b85717c4872ea$var$setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || $267b85717c4872ea$var$emptyTexture3d, unit);
}
function $267b85717c4872ea$var$setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || $267b85717c4872ea$var$emptyCubeTexture, unit);
}
function $267b85717c4872ea$var$setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || $267b85717c4872ea$var$emptyTexture2dArray, unit);
}
// Helper to pick the right setter for the singular case
function $267b85717c4872ea$var$getSingularSetter(type2) {
    switch(type2){
        case 5126:
            return $267b85717c4872ea$var$setValueV1f; // FLOAT
        case 35664:
            return $267b85717c4872ea$var$setValueV2f; // _VEC2
        case 35665:
            return $267b85717c4872ea$var$setValueV3f; // _VEC3
        case 35666:
            return $267b85717c4872ea$var$setValueV4f; // _VEC4
        case 35674:
            return $267b85717c4872ea$var$setValueM2; // _MAT2
        case 35675:
            return $267b85717c4872ea$var$setValueM3; // _MAT3
        case 35676:
            return $267b85717c4872ea$var$setValueM4; // _MAT4
        case 5124:
        case 35670:
            return $267b85717c4872ea$var$setValueV1i; // INT, BOOL
        case 35667:
        case 35671:
            return $267b85717c4872ea$var$setValueV2i; // _VEC2
        case 35668:
        case 35672:
            return $267b85717c4872ea$var$setValueV3i; // _VEC3
        case 35669:
        case 35673:
            return $267b85717c4872ea$var$setValueV4i; // _VEC4
        case 5125:
            return $267b85717c4872ea$var$setValueV1ui; // UINT
        case 36294:
            return $267b85717c4872ea$var$setValueV2ui; // _VEC2
        case 36295:
            return $267b85717c4872ea$var$setValueV3ui; // _VEC3
        case 36296:
            return $267b85717c4872ea$var$setValueV4ui; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return $267b85717c4872ea$var$setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return $267b85717c4872ea$var$setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return $267b85717c4872ea$var$setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return $267b85717c4872ea$var$setValueT2DArray1;
    }
}
// Array of scalars
function $267b85717c4872ea$var$setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Array of vectors (from flat array or array of THREE.VectorN)
function $267b85717c4872ea$var$setValueV2fArray(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data2);
}
function $267b85717c4872ea$var$setValueV3fArray(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data2);
}
function $267b85717c4872ea$var$setValueV4fArray(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data2);
}
// Array of matrices (from flat array or array of THREE.MatrixN)
function $267b85717c4872ea$var$setValueM2Array(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data2);
}
function $267b85717c4872ea$var$setValueM3Array(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data2);
}
function $267b85717c4872ea$var$setValueM4Array(gl, v) {
    const data2 = $267b85717c4872ea$var$flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data2);
}
// Array of integer / boolean
function $267b85717c4872ea$var$setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
// Array of integer / boolean vectors (from flat array)
function $267b85717c4872ea$var$setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function $267b85717c4872ea$var$setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function $267b85717c4872ea$var$setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of unsigned integer
function $267b85717c4872ea$var$setValueV1uiArray(gl, v) {
    gl.uniform1uiv(this.addr, v);
}
// Array of unsigned integer vectors (from flat array)
function $267b85717c4872ea$var$setValueV2uiArray(gl, v) {
    gl.uniform2uiv(this.addr, v);
}
function $267b85717c4872ea$var$setValueV3uiArray(gl, v) {
    gl.uniform3uiv(this.addr, v);
}
function $267b85717c4872ea$var$setValueV4uiArray(gl, v) {
    gl.uniform4uiv(this.addr, v);
}
// Array of textures (2D / Cube)
function $267b85717c4872ea$var$setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = $267b85717c4872ea$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i2 = 0; i2 !== n; ++i2)textures.safeSetTexture2D(v[i2] || $267b85717c4872ea$var$emptyTexture, units[i2]);
}
function $267b85717c4872ea$var$setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = $267b85717c4872ea$var$allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i2 = 0; i2 !== n; ++i2)textures.safeSetTextureCube(v[i2] || $267b85717c4872ea$var$emptyCubeTexture, units[i2]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function $267b85717c4872ea$var$getPureArraySetter(type2) {
    switch(type2){
        case 5126:
            return $267b85717c4872ea$var$setValueV1fArray; // FLOAT
        case 35664:
            return $267b85717c4872ea$var$setValueV2fArray; // _VEC2
        case 35665:
            return $267b85717c4872ea$var$setValueV3fArray; // _VEC3
        case 35666:
            return $267b85717c4872ea$var$setValueV4fArray; // _VEC4
        case 35674:
            return $267b85717c4872ea$var$setValueM2Array; // _MAT2
        case 35675:
            return $267b85717c4872ea$var$setValueM3Array; // _MAT3
        case 35676:
            return $267b85717c4872ea$var$setValueM4Array; // _MAT4
        case 5124:
        case 35670:
            return $267b85717c4872ea$var$setValueV1iArray; // INT, BOOL
        case 35667:
        case 35671:
            return $267b85717c4872ea$var$setValueV2iArray; // _VEC2
        case 35668:
        case 35672:
            return $267b85717c4872ea$var$setValueV3iArray; // _VEC3
        case 35669:
        case 35673:
            return $267b85717c4872ea$var$setValueV4iArray; // _VEC4
        case 5125:
            return $267b85717c4872ea$var$setValueV1uiArray; // UINT
        case 36294:
            return $267b85717c4872ea$var$setValueV2uiArray; // _VEC2
        case 36295:
            return $267b85717c4872ea$var$setValueV3uiArray; // _VEC3
        case 36296:
            return $267b85717c4872ea$var$setValueV4uiArray; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return $267b85717c4872ea$var$setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return $267b85717c4872ea$var$setValueT6Array;
    }
}
// --- Uniform Classes ---
function $267b85717c4872ea$var$SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = $267b85717c4872ea$var$getSingularSetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
function $267b85717c4872ea$var$PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = $267b85717c4872ea$var$getPureArraySetter(activeInfo.type);
// this.path = activeInfo.name; // DEBUG
}
$267b85717c4872ea$var$PureArrayUniform.prototype.updateCache = function(data2) {
    const cache = this.cache;
    if (data2 instanceof Float32Array && cache.length !== data2.length) this.cache = new Float32Array(data2.length);
    $267b85717c4872ea$var$copyArray(cache, data2);
};
function $267b85717c4872ea$var$StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {
    };
}
$267b85717c4872ea$var$StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i2 = 0, n = seq.length; i2 !== n; ++i2){
        const u = seq[i2];
        u.setValue(gl, value[u.id], textures);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const $267b85717c4872ea$var$RePathPart = /(\w+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function $267b85717c4872ea$var$addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function $267b85717c4872ea$var$parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    $267b85717c4872ea$var$RePathPart.lastIndex = 0;
    while(true){
        const match = $267b85717c4872ea$var$RePathPart.exec(path), matchEnd = $267b85717c4872ea$var$RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            $267b85717c4872ea$var$addUniform(container, subscript === undefined ? new $267b85717c4872ea$var$SingleUniform(id, activeInfo, addr) : new $267b85717c4872ea$var$PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new $267b85717c4872ea$var$StructuredUniform(id);
                $267b85717c4872ea$var$addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function $267b85717c4872ea$var$WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {
    };
    const n = gl.getProgramParameter(program, 35718);
    for(let i2 = 0; i2 < n; ++i2){
        const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
        $267b85717c4872ea$var$parseUniform(info, addr, this);
    }
}
$267b85717c4872ea$var$WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
$267b85717c4872ea$var$WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
$267b85717c4872ea$var$WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i2 = 0, n = seq.length; i2 !== n; ++i2){
        const u = seq[i2], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, textures);
    }
};
$267b85717c4872ea$var$WebGLUniforms.seqWithValue = function(seq, values) {
    const r2 = [];
    for(let i2 = 0, n = seq.length; i2 !== n; ++i2){
        const u = seq[i2];
        if (u.id in values) r2.push(u);
    }
    return r2;
};
function $267b85717c4872ea$var$WebGLShader(gl, type2, string) {
    const shader = gl.createShader(type2);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
let $267b85717c4872ea$var$programIdCount = 0;
function $267b85717c4872ea$var$addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i2 = 0; i2 < lines.length; i2++)lines[i2] = i2 + 1 + ': ' + lines[i2];
    return lines.join('\n');
}
function $267b85717c4872ea$var$getEncodingComponents(encoding2) {
    switch(encoding2){
        case $267b85717c4872ea$export$b2fb0348530d6a72:
            return [
                'Linear',
                '( value )'
            ];
        case $267b85717c4872ea$export$e7c1dc234bb46352:
            return [
                'sRGB',
                '( value )'
            ];
        case $267b85717c4872ea$export$ace080f0744d1804:
            return [
                'RGBE',
                '( value )'
            ];
        case $267b85717c4872ea$export$8a6fae5b6cf692b2:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case $267b85717c4872ea$export$75672e157e360d47:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case $267b85717c4872ea$export$d7502b91b57a25b6:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case $267b85717c4872ea$export$bdceb2aaf414b246:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case $267b85717c4872ea$export$8aafe6ce3e58c0a1:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding2);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function $267b85717c4872ea$var$getShaderErrors(gl, shader, type2) {
    const status = gl.getShaderParameter(shader, 35713);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    const source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type2 + '\n' + log + $267b85717c4872ea$var$addLineNumbers(source);
}
function $267b85717c4872ea$var$getTexelDecodingFunction(functionName, encoding2) {
    const components = $267b85717c4872ea$var$getEncodingComponents(encoding2);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function $267b85717c4872ea$var$getTexelEncodingFunction(functionName, encoding2) {
    const components = $267b85717c4872ea$var$getEncodingComponents(encoding2);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function $267b85717c4872ea$var$getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case $267b85717c4872ea$export$cc6c2a4a6309dd6b:
            toneMappingName = 'Linear';
            break;
        case $267b85717c4872ea$export$474a2b0636ec644b:
            toneMappingName = 'Reinhard';
            break;
        case $267b85717c4872ea$export$dbe5a6b233dae689:
            toneMappingName = 'OptimizedCineon';
            break;
        case $267b85717c4872ea$export$5d789c3b0a082607:
            toneMappingName = 'ACESFilmic';
            break;
        case $267b85717c4872ea$export$931972901eb25928:
            toneMappingName = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
            toneMappingName = 'Linear';
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function $267b85717c4872ea$var$generateExtensions(parameters2) {
    const chunks = [
        parameters2.extensionDerivatives || parameters2.envMapCubeUV || parameters2.bumpMap || parameters2.tangentSpaceNormalMap || parameters2.clearcoatNormalMap || parameters2.flatShading || parameters2.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters2.extensionFragDepth || parameters2.logarithmicDepthBuffer) && parameters2.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters2.extensionDrawBuffers && parameters2.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters2.extensionShaderTextureLOD || parameters2.envMap || parameters2.transmission > 0) && parameters2.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter($267b85717c4872ea$var$filterEmptyLine).join('\n');
}
function $267b85717c4872ea$var$generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function $267b85717c4872ea$var$fetchAttributeLocations(gl, program) {
    const attributes = {
    };
    const n = gl.getProgramParameter(program, 35721);
    for(let i2 = 0; i2 < n; i2++){
        const info = gl.getActiveAttrib(program, i2);
        const name = info.name;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function $267b85717c4872ea$var$filterEmptyLine(string) {
    return string !== '';
}
function $267b85717c4872ea$var$replaceLightNums(string, parameters2) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters2.numPointLightShadows);
}
function $267b85717c4872ea$var$replaceClippingPlaneNums(string, parameters2) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters2.numClippingPlanes - parameters2.numClipIntersection);
}
// Resolve Includes
const $267b85717c4872ea$var$includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function $267b85717c4872ea$var$resolveIncludes(string) {
    return string.replace($267b85717c4872ea$var$includePattern, $267b85717c4872ea$var$includeReplacer);
}
function $267b85717c4872ea$var$includeReplacer(match, include) {
    const string = $267b85717c4872ea$export$dfbc21f88d2cbdc4[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return $267b85717c4872ea$var$resolveIncludes(string);
}
// Unroll Loops
const $267b85717c4872ea$var$deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const $267b85717c4872ea$var$unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function $267b85717c4872ea$var$unrollLoops(string) {
    return string.replace($267b85717c4872ea$var$unrollLoopPattern, $267b85717c4872ea$var$loopReplacer).replace($267b85717c4872ea$var$deprecatedUnrollLoopPattern, $267b85717c4872ea$var$deprecatedLoopReplacer);
}
function $267b85717c4872ea$var$deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return $267b85717c4872ea$var$loopReplacer(match, start, end, snippet);
}
function $267b85717c4872ea$var$loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i2 = parseInt(start); i2 < parseInt(end); i2++)string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i2 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i2);
    return string;
}
//
function $267b85717c4872ea$var$generatePrecision(parameters2) {
    let precisionstring = 'precision ' + parameters2.precision + ' float;\nprecision ' + parameters2.precision + ' int;';
    if (parameters2.precision === 'highp') precisionstring += '\n#define HIGH_PRECISION';
    else if (parameters2.precision === 'mediump') precisionstring += '\n#define MEDIUM_PRECISION';
    else if (parameters2.precision === 'lowp') precisionstring += '\n#define LOW_PRECISION';
    return precisionstring;
}
function $267b85717c4872ea$var$generateShadowMapTypeDefine(parameters2) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters2.shadowMapType === $267b85717c4872ea$export$c49a0658083527ab) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters2.shadowMapType === $267b85717c4872ea$export$8eff1e0d566412fd) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters2.shadowMapType === $267b85717c4872ea$export$b3924b4be61e1947) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function $267b85717c4872ea$var$generateEnvMapTypeDefine(parameters2) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters2.envMap) switch(parameters2.envMapMode){
        case $267b85717c4872ea$export$14b9933b43601226:
        case $267b85717c4872ea$export$2be972fd003606e2:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case $267b85717c4872ea$export$fb3ca8bcae285728:
        case $267b85717c4872ea$export$8be195802fe0213b:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
    }
    return envMapTypeDefine;
}
function $267b85717c4872ea$var$generateEnvMapModeDefine(parameters2) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters2.envMap) switch(parameters2.envMapMode){
        case $267b85717c4872ea$export$2be972fd003606e2:
        case $267b85717c4872ea$export$8be195802fe0213b:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
    }
    return envMapModeDefine;
}
function $267b85717c4872ea$var$generateEnvMapBlendingDefine(parameters2) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters2.envMap) switch(parameters2.combine){
        case $267b85717c4872ea$export$9662028f262f1c9a:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case $267b85717c4872ea$export$684c8e251d1491ba:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case $267b85717c4872ea$export$ef4d269b71829b10:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
    }
    return envMapBlendingDefine;
}
function $267b85717c4872ea$var$WebGLProgram(renderer, cacheKey, parameters2, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters2.defines;
    let vertexShader = parameters2.vertexShader;
    let fragmentShader = parameters2.fragmentShader;
    const shadowMapTypeDefine = $267b85717c4872ea$var$generateShadowMapTypeDefine(parameters2);
    const envMapTypeDefine = $267b85717c4872ea$var$generateEnvMapTypeDefine(parameters2);
    const envMapModeDefine = $267b85717c4872ea$var$generateEnvMapModeDefine(parameters2);
    const envMapBlendingDefine = $267b85717c4872ea$var$generateEnvMapBlendingDefine(parameters2);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters2.isWebGL2 ? '' : $267b85717c4872ea$var$generateExtensions(parameters2);
    const customDefines = $267b85717c4872ea$var$generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters2.glslVersion ? '#version ' + parameters2.glslVersion + '\n' : '';
    if (parameters2.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter($267b85717c4872ea$var$filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter($267b85717c4872ea$var$filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            $267b85717c4872ea$var$generatePrecision(parameters2),
            '#define SHADER_NAME ' + parameters2.shaderName,
            customDefines,
            parameters2.instancing ? '#define USE_INSTANCING' : '',
            parameters2.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            parameters2.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters2.maxBones,
            parameters2.useFog && parameters2.fog ? '#define USE_FOG' : '',
            parameters2.useFog && parameters2.fogExp2 ? '#define FOG_EXP2' : '',
            parameters2.map ? '#define USE_MAP' : '',
            parameters2.envMap ? '#define USE_ENVMAP' : '',
            parameters2.envMap ? '#define ' + envMapModeDefine : '',
            parameters2.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters2.aoMap ? '#define USE_AOMAP' : '',
            parameters2.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters2.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters2.normalMap ? '#define USE_NORMALMAP' : '',
            parameters2.normalMap && parameters2.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters2.normalMap && parameters2.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters2.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters2.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters2.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters2.displacementMap && parameters2.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters2.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters2.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters2.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters2.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters2.transmission ? '#define USE_TRANSMISSION' : '',
            parameters2.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters2.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            parameters2.vertexTangents ? '#define USE_TANGENT' : '',
            parameters2.vertexColors ? '#define USE_COLOR' : '',
            parameters2.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            parameters2.vertexUvs ? '#define USE_UV' : '',
            parameters2.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters2.flatShading ? '#define FLAT_SHADED' : '',
            parameters2.skinning ? '#define USE_SKINNING' : '',
            parameters2.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters2.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters2.morphNormals && parameters2.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters2.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters2.flipSided ? '#define FLIP_SIDED' : '',
            parameters2.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters2.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters2.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters2.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters2.logarithmicDepthBuffer && parameters2.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '	attribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '	attribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '	attribute vec4 tangent;',
            '#endif',
            '#if defined( USE_COLOR_ALPHA )',
            '	attribute vec4 color;',
            '#elif defined( USE_COLOR )',
            '	attribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '	attribute vec3 morphTarget0;',
            '	attribute vec3 morphTarget1;',
            '	attribute vec3 morphTarget2;',
            '	attribute vec3 morphTarget3;',
            '	#ifdef USE_MORPHNORMALS',
            '		attribute vec3 morphNormal0;',
            '		attribute vec3 morphNormal1;',
            '		attribute vec3 morphNormal2;',
            '		attribute vec3 morphNormal3;',
            '	#else',
            '		attribute vec3 morphTarget4;',
            '		attribute vec3 morphTarget5;',
            '		attribute vec3 morphTarget6;',
            '		attribute vec3 morphTarget7;',
            '	#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '	attribute vec4 skinIndex;',
            '	attribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter($267b85717c4872ea$var$filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            $267b85717c4872ea$var$generatePrecision(parameters2),
            '#define SHADER_NAME ' + parameters2.shaderName,
            customDefines,
            parameters2.alphaTest ? '#define ALPHATEST ' + parameters2.alphaTest + (parameters2.alphaTest % 1 ? '' : '.0') : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters2.useFog && parameters2.fog ? '#define USE_FOG' : '',
            parameters2.useFog && parameters2.fogExp2 ? '#define FOG_EXP2' : '',
            parameters2.map ? '#define USE_MAP' : '',
            parameters2.matcap ? '#define USE_MATCAP' : '',
            parameters2.envMap ? '#define USE_ENVMAP' : '',
            parameters2.envMap ? '#define ' + envMapTypeDefine : '',
            parameters2.envMap ? '#define ' + envMapModeDefine : '',
            parameters2.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters2.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters2.aoMap ? '#define USE_AOMAP' : '',
            parameters2.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters2.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters2.normalMap ? '#define USE_NORMALMAP' : '',
            parameters2.normalMap && parameters2.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters2.normalMap && parameters2.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters2.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters2.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters2.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters2.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters2.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters2.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters2.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters2.sheen ? '#define USE_SHEEN' : '',
            parameters2.transmission ? '#define USE_TRANSMISSION' : '',
            parameters2.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters2.thicknessMap ? '#define USE_THICKNESSMAP' : '',
            parameters2.vertexTangents ? '#define USE_TANGENT' : '',
            parameters2.vertexColors || parameters2.instancingColor ? '#define USE_COLOR' : '',
            parameters2.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
            parameters2.vertexUvs ? '#define USE_UV' : '',
            parameters2.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters2.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters2.flatShading ? '#define FLAT_SHADED' : '',
            parameters2.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters2.flipSided ? '#define FLIP_SIDED' : '',
            parameters2.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters2.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters2.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters2.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters2.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters2.logarithmicDepthBuffer && parameters2.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters2.extensionShaderTextureLOD || parameters2.envMap) && parameters2.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters2.toneMapping !== $267b85717c4872ea$export$f1d4bd8fdcc91a4e ? '#define TONE_MAPPING' : '',
            parameters2.toneMapping !== $267b85717c4872ea$export$f1d4bd8fdcc91a4e ? $267b85717c4872ea$export$dfbc21f88d2cbdc4['tonemapping_pars_fragment'] : '',
            parameters2.toneMapping !== $267b85717c4872ea$export$f1d4bd8fdcc91a4e ? $267b85717c4872ea$var$getToneMappingFunction('toneMapping', parameters2.toneMapping) : '',
            parameters2.dithering ? '#define DITHERING' : '',
            $267b85717c4872ea$export$dfbc21f88d2cbdc4['encodings_pars_fragment'],
            parameters2.map ? $267b85717c4872ea$var$getTexelDecodingFunction('mapTexelToLinear', parameters2.mapEncoding) : '',
            parameters2.matcap ? $267b85717c4872ea$var$getTexelDecodingFunction('matcapTexelToLinear', parameters2.matcapEncoding) : '',
            parameters2.envMap ? $267b85717c4872ea$var$getTexelDecodingFunction('envMapTexelToLinear', parameters2.envMapEncoding) : '',
            parameters2.emissiveMap ? $267b85717c4872ea$var$getTexelDecodingFunction('emissiveMapTexelToLinear', parameters2.emissiveMapEncoding) : '',
            parameters2.lightMap ? $267b85717c4872ea$var$getTexelDecodingFunction('lightMapTexelToLinear', parameters2.lightMapEncoding) : '',
            $267b85717c4872ea$var$getTexelEncodingFunction('linearToOutputTexel', parameters2.outputEncoding),
            parameters2.depthPacking ? '#define DEPTH_PACKING ' + parameters2.depthPacking : '',
            '\n'
        ].filter($267b85717c4872ea$var$filterEmptyLine).join('\n');
    }
    vertexShader = $267b85717c4872ea$var$resolveIncludes(vertexShader);
    vertexShader = $267b85717c4872ea$var$replaceLightNums(vertexShader, parameters2);
    vertexShader = $267b85717c4872ea$var$replaceClippingPlaneNums(vertexShader, parameters2);
    fragmentShader = $267b85717c4872ea$var$resolveIncludes(fragmentShader);
    fragmentShader = $267b85717c4872ea$var$replaceLightNums(fragmentShader, parameters2);
    fragmentShader = $267b85717c4872ea$var$replaceClippingPlaneNums(fragmentShader, parameters2);
    vertexShader = $267b85717c4872ea$var$unrollLoops(vertexShader);
    fragmentShader = $267b85717c4872ea$var$unrollLoops(fragmentShader);
    if (parameters2.isWebGL2 && parameters2.isRawShaderMaterial !== true) {
        // GLSL 3.0 conversion for built-in materials and ShaderMaterial
        versionString = '#version 300 es\n';
        prefixVertex = [
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#define varying in',
            parameters2.glslVersion === $267b85717c4872ea$export$48c70045116d2bc9 ? '' : 'out highp vec4 pc_fragColor;',
            parameters2.glslVersion === $267b85717c4872ea$export$48c70045116d2bc9 ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = $267b85717c4872ea$var$WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = $267b85717c4872ea$var$WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters2.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters2.index0AttributeName);
    else if (parameters2.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, 35714) === false) {
            runnable = false;
            const vertexErrors = $267b85717c4872ea$var$getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = $267b85717c4872ea$var$getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new $267b85717c4872ea$var$WebGLUniforms(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = $267b85717c4872ea$var$fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters2.shaderName;
    this.id = $267b85717c4872ea$var$programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
function $267b85717c4872ea$var$WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        'precision',
        'isWebGL2',
        'supportsVertexTextures',
        'outputEncoding',
        'instancing',
        'instancingColor',
        'map',
        'mapEncoding',
        'matcap',
        'matcapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'envMapCubeUV',
        'lightMap',
        'lightMapEncoding',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'objectSpaceNormalMap',
        'tangentSpaceNormalMap',
        'clearcoatMap',
        'clearcoatRoughnessMap',
        'clearcoatNormalMap',
        'displacementMap',
        'specularMap',
        'roughnessMap',
        'metalnessMap',
        'gradientMap',
        'alphaMap',
        'combine',
        'vertexColors',
        'vertexAlphas',
        'vertexTangents',
        'vertexUvs',
        'uvsVertexOnly',
        'fog',
        'useFog',
        'fogExp2',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'numRectAreaLights',
        'numDirLightShadows',
        'numPointLightShadows',
        'numSpotLightShadows',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'alphaTest',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'numClipIntersection',
        'depthPacking',
        'dithering',
        'sheen',
        'transmission',
        'transmissionMap',
        'thicknessMap'
    ];
    function getMaxBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding2;
        if (map && map.isTexture) encoding2 = map.encoding;
        else if (map && map.isWebGLRenderTarget) {
            console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
            encoding2 = map.texture.encoding;
        } else encoding2 = $267b85717c4872ea$export$b2fb0348530d6a72;
        return encoding2;
    }
    function getParameters(material1, lights, shadows, scene, object) {
        const fog = scene.fog;
        const environment = material1.isMeshStandardMaterial ? scene.environment : null;
        const envMap = cubemaps.get(material1.envMap || environment);
        const shaderID = shaderIDs[material1.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
        if (material1.precision !== null) {
            precision = capabilities.getMaxPrecision(material1.precision);
            if (precision !== material1.precision) console.warn('THREE.WebGLProgram.getParameters:', material1.precision, 'not supported, using', precision, 'instead.');
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = $267b85717c4872ea$export$c8b76cbbe298b27f[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material1.vertexShader;
            fragmentShader = material1.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters2 = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material1.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material1.defines,
            isRawShaderMaterial: material1.isRawShaderMaterial === true,
            glslVersion: material1.glslVersion,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material1.map,
            mapEncoding: getTextureEncodingFromMap(material1.map),
            matcap: !!material1.matcap,
            matcapEncoding: getTextureEncodingFromMap(material1.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === $267b85717c4872ea$export$fb3ca8bcae285728 || envMap.mapping === $267b85717c4872ea$export$8be195802fe0213b),
            lightMap: !!material1.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material1.lightMap),
            aoMap: !!material1.aoMap,
            emissiveMap: !!material1.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material1.emissiveMap),
            bumpMap: !!material1.bumpMap,
            normalMap: !!material1.normalMap,
            objectSpaceNormalMap: material1.normalMapType === $267b85717c4872ea$export$f4022e1d647ebcad,
            tangentSpaceNormalMap: material1.normalMapType === $267b85717c4872ea$export$9c3212295f347347,
            clearcoatMap: !!material1.clearcoatMap,
            clearcoatRoughnessMap: !!material1.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material1.clearcoatNormalMap,
            displacementMap: !!material1.displacementMap,
            roughnessMap: !!material1.roughnessMap,
            metalnessMap: !!material1.metalnessMap,
            specularMap: !!material1.specularMap,
            alphaMap: !!material1.alphaMap,
            gradientMap: !!material1.gradientMap,
            sheen: !!material1.sheen,
            transmission: !!material1.transmission,
            transmissionMap: !!material1.transmissionMap,
            thicknessMap: !!material1.thicknessMap,
            combine: material1.combine,
            vertexTangents: material1.normalMap && material1.vertexTangents,
            vertexColors: material1.vertexColors,
            vertexAlphas: material1.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
            vertexUvs: !!material1.map || !!material1.bumpMap || !!material1.normalMap || !!material1.specularMap || !!material1.alphaMap || !!material1.emissiveMap || !!material1.roughnessMap || !!material1.metalnessMap || !!material1.clearcoatMap || !!material1.clearcoatRoughnessMap || !!material1.clearcoatNormalMap || !!material1.displacementMap || !!material1.transmissionMap || !!material1.thicknessMap,
            uvsVertexOnly: !(!!material1.map || !!material1.bumpMap || !!material1.normalMap || !!material1.specularMap || !!material1.alphaMap || !!material1.emissiveMap || !!material1.roughnessMap || !!material1.metalnessMap || !!material1.clearcoatNormalMap || !!material1.transmission || !!material1.transmissionMap || !!material1.thicknessMap) && !!material1.displacementMap,
            fog: !!fog,
            useFog: material1.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: !!material1.flatShading,
            sizeAttenuation: material1.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: object.isSkinnedMesh === true && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material1.morphTargets,
            morphNormals: material1.morphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: clipping.numPlanes,
            numClipIntersection: clipping.numIntersection,
            dithering: material1.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material1.toneMapped ? renderer.toneMapping : $267b85717c4872ea$export$f1d4bd8fdcc91a4e,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material1.premultipliedAlpha,
            alphaTest: material1.alphaTest,
            doubleSided: material1.side === $267b85717c4872ea$export$6c33fb00521864ae,
            flipSided: material1.side === $267b85717c4872ea$export$fbde0e233a2945e1,
            depthPacking: material1.depthPacking !== undefined ? material1.depthPacking : false,
            index0AttributeName: material1.index0AttributeName,
            extensionDerivatives: material1.extensions && material1.extensions.derivatives,
            extensionFragDepth: material1.extensions && material1.extensions.fragDepth,
            extensionDrawBuffers: material1.extensions && material1.extensions.drawBuffers,
            extensionShaderTextureLOD: material1.extensions && material1.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
            rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
            customProgramCacheKey: material1.customProgramCacheKey()
        };
        return parameters2;
    }
    function getProgramCacheKey(parameters2) {
        const array12 = [];
        if (parameters2.shaderID) array12.push(parameters2.shaderID);
        else {
            array12.push(parameters2.fragmentShader);
            array12.push(parameters2.vertexShader);
        }
        if (parameters2.defines !== undefined) for(const name in parameters2.defines){
            array12.push(name);
            array12.push(parameters2.defines[name]);
        }
        if (parameters2.isRawShaderMaterial === false) {
            for(let i2 = 0; i2 < parameterNames.length; i2++)array12.push(parameters2[parameterNames[i2]]);
            array12.push(renderer.outputEncoding);
            array12.push(renderer.gammaFactor);
        }
        array12.push(parameters2.customProgramCacheKey);
        return array12.join();
    }
    function getUniforms(material1) {
        const shaderID = shaderIDs[material1.type];
        let uniforms;
        if (shaderID) {
            const shader = $267b85717c4872ea$export$c8b76cbbe298b27f[shaderID];
            uniforms = $267b85717c4872ea$export$7c3162ea2c0a01b6.clone(shader.uniforms);
        } else uniforms = material1.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters2, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new $267b85717c4872ea$var$WebGLProgram(renderer, cacheKey, parameters2, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if ((--program.usedTimes) === 0) {
            // Remove from unordered set
            const i2 = programs.indexOf(program);
            programs[i2] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs
    };
}
function $267b85717c4872ea$var$WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {
            };
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
function $267b85717c4872ea$var$painterSortStable(a2, b3) {
    if (a2.groupOrder !== b3.groupOrder) return a2.groupOrder - b3.groupOrder;
    else if (a2.renderOrder !== b3.renderOrder) return a2.renderOrder - b3.renderOrder;
    else if (a2.program !== b3.program) return a2.program.id - b3.program.id;
    else if (a2.material.id !== b3.material.id) return a2.material.id - b3.material.id;
    else if (a2.z !== b3.z) return a2.z - b3.z;
    else return a2.id - b3.id;
}
function $267b85717c4872ea$var$reversePainterSortStable(a2, b3) {
    if (a2.groupOrder !== b3.groupOrder) return a2.groupOrder - b3.groupOrder;
    else if (a2.renderOrder !== b3.renderOrder) return a2.renderOrder - b3.renderOrder;
    else if (a2.z !== b3.z) return b3.z - a2.z;
    else return a2.id - b3.id;
}
function $267b85717c4872ea$var$WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transmissive.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry1, material1, groupOrder, z5, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material1);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry1,
                material: material1,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z5,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry1;
            renderItem.material = material1;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z5;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry1, material1, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry1, material1, groupOrder, z5, group);
        if (material1.transmission > 0) transmissive.push(renderItem);
        else if (material1.transparent === true) transparent.push(renderItem);
        else opaque.push(renderItem);
    }
    function unshift(object, geometry1, material1, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry1, material1, groupOrder, z5, group);
        if (material1.transmission > 0) transmissive.unshift(renderItem);
        else if (material1.transparent === true) transparent.unshift(renderItem);
        else opaque.unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || $267b85717c4872ea$var$painterSortStable);
        if (transmissive.length > 1) transmissive.sort(customTransparentSort || $267b85717c4872ea$var$reversePainterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || $267b85717c4872ea$var$reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++){
            const renderItem = renderItems[i2];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transmissive: transmissive,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function $267b85717c4872ea$var$WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, renderCallDepth) {
        let list;
        if (lists.has(scene) === false) {
            list = new $267b85717c4872ea$var$WebGLRenderList(properties);
            lists.set(scene, [
                list
            ]);
        } else if (renderCallDepth >= lists.get(scene).length) {
            list = new $267b85717c4872ea$var$WebGLRenderList(properties);
            lists.get(scene).push(list);
        } else list = lists.get(scene)[renderCallDepth];
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
function $267b85717c4872ea$var$UniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        color: new $267b85717c4872ea$export$e4830c8e55b4f80d()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        direction: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        color: new $267b85717c4872ea$export$e4830c8e55b4f80d(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        color: new $267b85717c4872ea$export$e4830c8e55b4f80d(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        skyColor: new $267b85717c4872ea$export$e4830c8e55b4f80d(),
                        groundColor: new $267b85717c4872ea$export$e4830c8e55b4f80d()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new $267b85717c4872ea$export$e4830c8e55b4f80d(),
                        position: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        halfWidth: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(),
                        halfHeight: new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function $267b85717c4872ea$var$ShadowUniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $267b85717c4872ea$export$95d9e1e745cc7977()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $267b85717c4872ea$export$95d9e1e745cc7977()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new $267b85717c4872ea$export$95d9e1e745cc7977(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let $267b85717c4872ea$var$nextVersion = 0;
function $267b85717c4872ea$var$shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function $267b85717c4872ea$var$WebGLLights(extensions, capabilities) {
    const cache = new $267b85717c4872ea$var$UniformsCache();
    const shadowCache = $267b85717c4872ea$var$ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i2 = 0; i2 < 9; i2++)state.probe.push(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2());
    const vector3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
    const matrix4 = new $267b85717c4872ea$export$960b1460cb9cd6c9();
    const matrix42 = new $267b85717c4872ea$export$960b1460cb9cd6c9();
    function setup(lights) {
        let r2 = 0, g2 = 0, b3 = 0;
        for(let i3 = 0; i3 < 9; i3++)state.probe[i3].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        lights.sort($267b85717c4872ea$var$shadowCastingLightsFirst);
        for(let i4 = 0, l = lights.length; i4 < l; i4++){
            const light = lights[i4];
            const color = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r2 += color.r * intensity;
                g2 += color.g * intensity;
                b3 += color.b * intensity;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color).multiplyScalar(intensity);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        if (rectAreaLength > 0) {
            if (capabilities.isWebGL2) {
                // WebGL 2
                state.rectAreaLTC1 = $267b85717c4872ea$export$167843c98993dbe3.LTC_FLOAT_1;
                state.rectAreaLTC2 = $267b85717c4872ea$export$167843c98993dbe3.LTC_FLOAT_2;
            } else {
                // WebGL 1
                if (extensions.has('OES_texture_float_linear') === true) {
                    state.rectAreaLTC1 = $267b85717c4872ea$export$167843c98993dbe3.LTC_FLOAT_1;
                    state.rectAreaLTC2 = $267b85717c4872ea$export$167843c98993dbe3.LTC_FLOAT_2;
                } else if (extensions.has('OES_texture_half_float_linear') === true) {
                    state.rectAreaLTC1 = $267b85717c4872ea$export$167843c98993dbe3.LTC_HALF_1;
                    state.rectAreaLTC2 = $267b85717c4872ea$export$167843c98993dbe3.LTC_HALF_2;
                } else console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
            }
        }
        state.ambient[0] = r2;
        state.ambient[1] = g2;
        state.ambient[2] = b3;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = $267b85717c4872ea$var$nextVersion++;
        }
    }
    function setupView(lights, camera) {
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        const viewMatrix = camera.matrixWorldInverse;
        for(let i3 = 0, l = lights.length; i3 < l; i3++){
            const light = lights[i3];
            if (light.isDirectionalLight) {
                const uniforms = state.directional[directionalLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = state.spot[spotLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = state.rectArea[rectAreaLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = state.point[pointLength];
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = state.hemi[hemiLength];
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                hemiLength++;
            }
        }
    }
    return {
        setup: setup,
        setupView: setupView,
        state: state
    };
}
function $267b85717c4872ea$var$WebGLRenderState(extensions, capabilities) {
    const lights = new $267b85717c4872ea$var$WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights() {
        lights.setup(lightsArray);
    }
    function setupLightsView(camera) {
        lights.setupView(lightsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        setupLightsView: setupLightsView,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function $267b85717c4872ea$var$WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene, renderCallDepth = 0) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new $267b85717c4872ea$var$WebGLRenderState(extensions, capabilities);
            renderStates.set(scene, [
                renderState
            ]);
        } else if (renderCallDepth >= renderStates.get(scene).length) {
            renderState = new $267b85717c4872ea$var$WebGLRenderState(extensions, capabilities);
            renderStates.get(scene).push(renderState);
        } else renderState = renderStates.get(scene)[renderCallDepth];
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */ class $267b85717c4872ea$export$4153a5007efa303f extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters2){
        super();
        this.type = 'MeshDepthMaterial';
        this.depthPacking = $267b85717c4872ea$export$29e65aaafc98ee9a;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters2);
    }
    copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    }
}
$267b85717c4872ea$export$4153a5007efa303f.prototype.isMeshDepthMaterial = true;
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */ class $267b85717c4872ea$export$1b7bb4a7b69d3a38 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters3){
        super();
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters3);
    }
    copy(source) {
        super.copy(source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    }
}
$267b85717c4872ea$export$1b7bb4a7b69d3a38.prototype.isMeshDistanceMaterial = true;
var $267b85717c4872ea$var$vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var $267b85717c4872ea$var$vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
function $267b85717c4872ea$var$WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new $267b85717c4872ea$export$6ef72105b8c3e2c6();
    const _shadowMapSize = new $267b85717c4872ea$export$95d9e1e745cc7977(), _viewportSize = new $267b85717c4872ea$export$95d9e1e745cc7977(), _viewport = new $267b85717c4872ea$export$14dfcb76afe97063(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {
    }, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = {
        0: $267b85717c4872ea$export$fbde0e233a2945e1,
        1: $267b85717c4872ea$export$9b320e6c690b4c3e,
        2: $267b85717c4872ea$export$6c33fb00521864ae
    };
    const shadowMaterialVertical = new $267b85717c4872ea$export$2a77b7c526ae5937({
        defines: {
            SAMPLE_RATE: 0.25,
            HALF_SAMPLE_RATE: 0.125
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new $267b85717c4872ea$export$95d9e1e745cc7977()
            },
            radius: {
                value: 4
            }
        },
        vertexShader: $267b85717c4872ea$var$vsm_vert,
        fragmentShader: $267b85717c4872ea$var$vsm_frag
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new $267b85717c4872ea$export$84a34b4c8ecb6751();
    fullScreenTri.setAttribute('position', new $267b85717c4872ea$export$3d45483f125de856(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new $267b85717c4872ea$export$4cdb671a7054bbf9(fullScreenTri, shadowMaterialVertical);
    const scope1 = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = $267b85717c4872ea$export$c49a0658083527ab;
    this.render = function(lights, scene, camera) {
        if (scope1.enabled === false) return;
        if (scope1.autoUpdate === false && scope1.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending($267b85717c4872ea$export$8dd1256cd8ee174c);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i2 = 0, il = lights.length; i2 < il; i2++){
            const light = lights[i2];
            const shadow = light.shadow;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                if (_shadowMapSize.x > _maxTextureSize) {
                    _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > _maxTextureSize) {
                    _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === $267b85717c4872ea$export$b3924b4be61e1947) {
                const pars = {
                    minFilter: $267b85717c4872ea$export$d8f3ba475551f5c1,
                    magFilter: $267b85717c4872ea$export$d8f3ba475551f5c1,
                    format: $267b85717c4872ea$export$fdd3489947276d08
                };
                shadow.map = new $267b85717c4872ea$export$aef5a065c75d61ea(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.mapPass = new $267b85717c4872ea$export$aef5a065c75d61ea(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
                    magFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
                    format: $267b85717c4872ea$export$fdd3489947276d08
                };
                shadow.map = new $267b85717c4872ea$export$aef5a065c75d61ea(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + '.shadowMap';
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === $267b85717c4872ea$export$b3924b4be61e1947) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope1.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry1 = _objects.update(fullScreenMesh);
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry1, shadowMaterialVertical, fullScreenMesh, null);
        // horizontal pass
        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry1, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing) {
        const index = useMorphing << 0;
        let material1 = _depthMaterials[index];
        if (material1 === undefined) {
            material1 = new $267b85717c4872ea$export$4153a5007efa303f({
                depthPacking: $267b85717c4872ea$export$a8b736629af114b7,
                morphTargets: useMorphing
            });
            _depthMaterials[index] = material1;
        }
        return material1;
    }
    function getDistanceMaterialVariant(useMorphing) {
        const index = useMorphing << 0;
        let material1 = _distanceMaterials[index];
        if (material1 === undefined) {
            material1 = new $267b85717c4872ea$export$1b7bb4a7b69d3a38({
                morphTargets: useMorphing
            });
            _distanceMaterials[index] = material1;
        }
        return material1;
    }
    function getDepthMaterial(object, geometry1, material1, light, shadowCameraNear, shadowCameraFar, type2) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material1.morphTargets === true) useMorphing = geometry1.morphAttributes && geometry1.morphAttributes.position && geometry1.morphAttributes.position.length > 0;
            result = getMaterialVariant(useMorphing);
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material1.clipShadows === true && material1.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material1.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {
                };
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material1.visible;
        result.wireframe = material1.wireframe;
        if (type2 === $267b85717c4872ea$export$b3924b4be61e1947) result.side = material1.shadowSide !== null ? material1.shadowSide : material1.side;
        else result.side = material1.shadowSide !== null ? material1.shadowSide : shadowSide[material1.side];
        result.clipShadows = material1.clipShadows;
        result.clippingPlanes = material1.clippingPlanes;
        result.clipIntersection = material1.clipIntersection;
        result.wireframeLinewidth = material1.wireframeLinewidth;
        result.linewidth = material1.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type2) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type2 === $267b85717c4872ea$export$b3924b4be61e1947) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry1 = _objects.update(object);
                const material1 = object.material;
                if (Array.isArray(material1)) {
                    const groups = geometry1.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material1[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry1, groupMaterial, light, shadowCamera.near, shadowCamera.far, type2);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry1, depthMaterial, object, group);
                        }
                    }
                } else if (material1.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry1, material1, light, shadowCamera.near, shadowCamera.far, type2);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry1, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)renderObject(children[i2], camera, shadowCamera, light, type2);
    }
}
function $267b85717c4872ea$var$WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color = new $267b85717c4872ea$export$14dfcb76afe97063();
        let currentColorMask = null;
        const currentColorClear = new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r2, g2, b3, a2, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r2 *= a2;
                    g2 *= a2;
                    b3 *= a2;
                }
                color.set(r2, g2, b3, a2);
                if (currentColorClear.equals(color) === false) {
                    gl.clearColor(r2, g2, b3, a2);
                    currentColorClear.copy(color);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(2929);
                else disable(2929);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case $267b85717c4872ea$export$2bb8e8432a9b4ce8:
                            gl.depthFunc(512);
                            break;
                        case $267b85717c4872ea$export$35969032108360b7:
                            gl.depthFunc(519);
                            break;
                        case $267b85717c4872ea$export$83071cabd063cdbc:
                            gl.depthFunc(513);
                            break;
                        case $267b85717c4872ea$export$2ebf14d6a1f62fd5:
                            gl.depthFunc(515);
                            break;
                        case $267b85717c4872ea$export$2414e420c55a2ff:
                            gl.depthFunc(514);
                            break;
                        case $267b85717c4872ea$export$34574d9c49a0e706:
                            gl.depthFunc(518);
                            break;
                        case $267b85717c4872ea$export$2472b4d9932a0cd:
                            gl.depthFunc(516);
                            break;
                        case $267b85717c4872ea$export$ee21baa762b29e5b:
                            gl.depthFunc(517);
                            break;
                        default:
                            gl.depthFunc(515);
                    }
                    else gl.depthFunc(515);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth4) {
                if (currentDepthClear !== depth4) {
                    gl.clearDepth(depth4);
                    currentDepthClear = depth4;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(2960);
                    else disable(2960);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {
    };
    let xrFramebuffer = null;
    let currentBoundFramebuffers = {
    };
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {
    };
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new $267b85717c4872ea$export$14dfcb76afe97063().fromArray(scissorParam);
    const currentViewport = new $267b85717c4872ea$export$14dfcb76afe97063().fromArray(viewportParam);
    function createTexture(type2, target, count2) {
        const data2 = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture2 = gl.createTexture();
        gl.bindTexture(type2, texture2);
        gl.texParameteri(type2, 10241, 9728);
        gl.texParameteri(type2, 10240, 9728);
        for(let i2 = 0; i2 < count2; i2++)gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data2);
        return texture2;
    }
    const emptyTextures = {
    };
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc($267b85717c4872ea$export$2ebf14d6a1f62fd5);
    setFlipSided(false);
    setCullFace($267b85717c4872ea$export$f496fd4f7446e1b0);
    enable(2884);
    setBlending($267b85717c4872ea$export$8dd1256cd8ee174c);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function bindXRFramebuffer(framebuffer) {
        if (framebuffer !== xrFramebuffer) {
            gl.bindFramebuffer(36160, framebuffer);
            xrFramebuffer = framebuffer;
        }
    }
    function bindFramebuffer(target, framebuffer) {
        if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available
        if (currentBoundFramebuffers[target] !== framebuffer) {
            gl.bindFramebuffer(target, framebuffer);
            currentBoundFramebuffers[target] = framebuffer;
            if (isWebGL2) {
                // 36009 is equivalent to 36160
                if (target === 36009) currentBoundFramebuffers[36160] = framebuffer;
                if (target === 36160) currentBoundFramebuffers[36009] = framebuffer;
            }
            return true;
        }
        return false;
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [$267b85717c4872ea$export$fffd413922b3da9]: 32774,
        [$267b85717c4872ea$export$6336208e23eefe4e]: 32778,
        [$267b85717c4872ea$export$8a9f14acf70743d8]: 32779
    };
    if (isWebGL2) {
        equationToGL[$267b85717c4872ea$export$eab936f85fba1d02] = 32775;
        equationToGL[$267b85717c4872ea$export$cf7d66f5a928163] = 32776;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[$267b85717c4872ea$export$eab936f85fba1d02] = extension.MIN_EXT;
            equationToGL[$267b85717c4872ea$export$cf7d66f5a928163] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [$267b85717c4872ea$export$303cbd1773549e65]: 0,
        [$267b85717c4872ea$export$fff2f5cacd5e1e79]: 1,
        [$267b85717c4872ea$export$17e71dd197f07640]: 768,
        [$267b85717c4872ea$export$5b505308e80fcb9a]: 770,
        [$267b85717c4872ea$export$eb0c225fa9c4c2bd]: 776,
        [$267b85717c4872ea$export$6c07c189c269503e]: 774,
        [$267b85717c4872ea$export$2736baa06465ec72]: 772,
        [$267b85717c4872ea$export$eb4508d122da01a5]: 769,
        [$267b85717c4872ea$export$1ce08e87b3183a15]: 771,
        [$267b85717c4872ea$export$28d873cbf0b0b918]: 775,
        [$267b85717c4872ea$export$3cb5715888305d61]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === $267b85717c4872ea$export$8dd1256cd8ee174c) {
            if (currentBlendingEnabled === true) {
                disable(3042);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (currentBlendingEnabled === false) {
            enable(3042);
            currentBlendingEnabled = true;
        }
        if (blending !== $267b85717c4872ea$export$dc2fbdf24590e64f) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== $267b85717c4872ea$export$fffd413922b3da9 || currentBlendEquationAlpha !== $267b85717c4872ea$export$fffd413922b3da9) {
                    gl.blendEquation(32774);
                    currentBlendEquation = $267b85717c4872ea$export$fffd413922b3da9;
                    currentBlendEquationAlpha = $267b85717c4872ea$export$fffd413922b3da9;
                }
                if (premultipliedAlpha) switch(blending){
                    case $267b85717c4872ea$export$d1aa5279bbe89448:
                        gl.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case $267b85717c4872ea$export$602e701c332c9ac2:
                        gl.blendFunc(1, 1);
                        break;
                    case $267b85717c4872ea$export$a1133d0ae81edc93:
                        gl.blendFuncSeparate(0, 0, 769, 771);
                        break;
                    case $267b85717c4872ea$export$a047c2dc4c9f9b57:
                        gl.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case $267b85717c4872ea$export$d1aa5279bbe89448:
                        gl.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case $267b85717c4872ea$export$602e701c332c9ac2:
                        gl.blendFunc(770, 1);
                        break;
                    case $267b85717c4872ea$export$a1133d0ae81edc93:
                        gl.blendFunc(0, 769);
                        break;
                    case $267b85717c4872ea$export$a047c2dc4c9f9b57:
                        gl.blendFunc(0, 768);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material1, frontFaceCW) {
        material1.side === $267b85717c4872ea$export$6c33fb00521864ae ? disable(2884) : enable(2884);
        let flipSided = material1.side === $267b85717c4872ea$export$fbde0e233a2945e1;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material1.blending === $267b85717c4872ea$export$d1aa5279bbe89448 && material1.transparent === false ? setBlending($267b85717c4872ea$export$8dd1256cd8ee174c) : setBlending(material1.blending, material1.blendEquation, material1.blendSrc, material1.blendDst, material1.blendEquationAlpha, material1.blendSrcAlpha, material1.blendDstAlpha, material1.premultipliedAlpha);
        depthBuffer.setFunc(material1.depthFunc);
        depthBuffer.setTest(material1.depthTest);
        depthBuffer.setMask(material1.depthWrite);
        colorBuffer.setMask(material1.colorWrite);
        const stencilWrite = material1.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material1.stencilWriteMask);
            stencilBuffer.setFunc(material1.stencilFunc, material1.stencilRef, material1.stencilFuncMask);
            stencilBuffer.setOp(material1.stencilFail, material1.stencilZFail, material1.stencilZPass);
        }
        setPolygonOffset(material1.polygonOffset, material1.polygonOffsetFactor, material1.polygonOffsetUnits);
        material1.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(2304);
            else gl.frontFace(2305);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== $267b85717c4872ea$export$9e80385aa9c806bb) {
            enable(2884);
            if (cullFace !== currentCullFace) {
                if (cullFace === $267b85717c4872ea$export$f496fd4f7446e1b0) gl.cullFace(1029);
                else if (cullFace === $267b85717c4872ea$export$2a91c9dc6715044b) gl.cullFace(1028);
                else gl.cullFace(1032);
            }
        } else disable(2884);
        currentCullFace = cullFace;
    }
    function setLineWidth(width8) {
        if (width8 !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width8);
            currentLineWidth = width8;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(32823);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(32823);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(3089);
        else disable(3089);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    //
    function scissor(scissor1) {
        if (currentScissor.equals(scissor1) === false) {
            gl.scissor(scissor1.x, scissor1.y, scissor1.z, scissor1.w);
            currentScissor.copy(scissor1);
        }
    }
    function viewport(viewport1) {
        if (currentViewport.equals(viewport1) === false) {
            gl.viewport(viewport1.x, viewport1.y, viewport1.z, viewport1.w);
            currentViewport.copy(viewport1);
        }
    }
    //
    function reset() {
        // reset state
        gl.disable(3042);
        gl.disable(2884);
        gl.disable(2929);
        gl.disable(32823);
        gl.disable(3089);
        gl.disable(2960);
        gl.disable(32926);
        gl.blendEquation(32774);
        gl.blendFunc(1, 0);
        gl.blendFuncSeparate(1, 0, 1, 0);
        gl.colorMask(true, true, true, true);
        gl.clearColor(0, 0, 0, 0);
        gl.depthMask(true);
        gl.depthFunc(513);
        gl.clearDepth(1);
        gl.stencilMask(4294967295);
        gl.stencilFunc(519, 0, 4294967295);
        gl.stencilOp(7680, 7680, 7680);
        gl.clearStencil(0);
        gl.cullFace(1029);
        gl.frontFace(2305);
        gl.polygonOffset(0, 0);
        gl.activeTexture(33984);
        gl.bindFramebuffer(36160, null);
        if (isWebGL2 === true) {
            gl.bindFramebuffer(36009, null);
            gl.bindFramebuffer(36008, null);
        }
        gl.useProgram(null);
        gl.lineWidth(1);
        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // reset internals
        enabledCapabilities = {
        };
        currentTextureSlot = null;
        currentBoundTextures = {
        };
        xrFramebuffer = null;
        currentBoundFramebuffers = {
        };
        currentProgram = null;
        currentBlendingEnabled = false;
        currentBlending = null;
        currentBlendEquation = null;
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendEquationAlpha = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentPremultipledAlpha = false;
        currentFlipSided = null;
        currentCullFace = null;
        currentLineWidth = null;
        currentPolygonOffsetFactor = null;
        currentPolygonOffsetUnits = null;
        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        bindFramebuffer: bindFramebuffer,
        bindXRFramebuffer: bindXRFramebuffer,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
function $267b85717c4872ea$var$WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas;
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
    } catch (err) {
    // Ignore any errors
    }
    function createCanvas(width8, height8) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? new OffscreenCanvas(width8, height8) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image1, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale1 = 1;
        // handle case if texture exceeds max size
        if (image1.width > maxSize || image1.height > maxSize) scale1 = maxSize / Math.max(image1.width, image1.height);
        // only perform resize if necessary
        if (scale1 < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== 'undefined' && image1 instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image1 instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image1 instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? $267b85717c4872ea$var$floorPowerOfTwo : Math.floor;
                const width8 = floor(scale1 * image1.width);
                const height8 = floor(scale1 * image1.height);
                if (_canvas === undefined) _canvas = createCanvas(width8, height8);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width8, height8) : _canvas;
                canvas.width = width8;
                canvas.height = height8;
                const context = canvas.getContext('2d');
                context.drawImage(image1, 0, 0, width8, height8);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image1.width + 'x' + image1.height + ') to (' + width8 + 'x' + height8 + ').');
                return canvas;
            } else {
                if ('data' in image1) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image1.width + 'x' + image1.height + ').');
                return image1;
            }
        }
        return image1;
    }
    function isPowerOfTwo$1(image1) {
        return $267b85717c4872ea$var$isPowerOfTwo(image1.width) && $267b85717c4872ea$var$isPowerOfTwo(image1.height);
    }
    function textureNeedsPowerOfTwo(texture2) {
        if (isWebGL2) return false;
        return texture2.wrapS !== $267b85717c4872ea$export$73b90a84ed7db63c || texture2.wrapT !== $267b85717c4872ea$export$73b90a84ed7db63c || texture2.minFilter !== $267b85717c4872ea$export$f8b53649f0062e3e && texture2.minFilter !== $267b85717c4872ea$export$d8f3ba475551f5c1;
    }
    function textureNeedsGenerateMipmaps(texture2, supportsMips) {
        return texture2.generateMipmaps && supportsMips && texture2.minFilter !== $267b85717c4872ea$export$f8b53649f0062e3e && texture2.minFilter !== $267b85717c4872ea$export$d8f3ba475551f5c1;
    }
    function generateMipmap(target, texture2, width8, height8, depth4 = 1) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture2);
        textureProperties.__maxMipLevel = Math.log2(Math.max(width8, height8, depth4));
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === 6403) {
            if (glType === 5126) internalFormat = 33326;
            if (glType === 5131) internalFormat = 33325;
            if (glType === 5121) internalFormat = 33321;
        }
        if (glFormat === 6407) {
            if (glType === 5126) internalFormat = 34837;
            if (glType === 5131) internalFormat = 34843;
            if (glType === 5121) internalFormat = 32849;
        }
        if (glFormat === 6408) {
            if (glType === 5126) internalFormat = 34836;
            if (glType === 5131) internalFormat = 34842;
            if (glType === 5121) internalFormat = 32856;
        }
        if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === $267b85717c4872ea$export$f8b53649f0062e3e || f === $267b85717c4872ea$export$3d857d6c85506f73 || f === $267b85717c4872ea$export$977236fa8e8d0f1d) return 9728;
        return 9729;
    }
    //
    function onTextureDispose(event) {
        const texture2 = event.target;
        texture2.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture2);
        if (texture2.isVideoTexture) _videoTextures.delete(texture2);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget1 = event.target;
        renderTarget1.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget1);
    }
    //
    function deallocateTexture(texture2) {
        const textureProperties = properties.get(texture2);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture2);
    }
    function deallocateRenderTarget(renderTarget1) {
        const texture2 = renderTarget1.texture;
        const renderTargetProperties = properties.get(renderTarget1);
        const textureProperties = properties.get(texture2);
        if (!renderTarget1) return;
        if (textureProperties.__webglTexture !== undefined) {
            _gl.deleteTexture(textureProperties.__webglTexture);
            info.memory.textures--;
        }
        if (renderTarget1.depthTexture) renderTarget1.depthTexture.dispose();
        if (renderTarget1.isWebGLCubeRenderTarget) for(let i2 = 0; i2 < 6; i2++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        if (renderTarget1.isWebGLMultipleRenderTargets) for(let i3 = 0, il = texture2.length; i3 < il; i3++){
            const attachmentProperties = properties.get(texture2[i3]);
            if (attachmentProperties.__webglTexture) {
                _gl.deleteTexture(attachmentProperties.__webglTexture);
                info.memory.textures--;
            }
            properties.remove(texture2[i3]);
        }
        properties.remove(texture2);
        properties.remove(renderTarget1);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    //
    function setTexture2D(texture2, slot) {
        const textureProperties = properties.get(texture2);
        if (texture2.isVideoTexture) updateVideoTexture(texture2);
        if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
            const image1 = texture2.image;
            if (image1 === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image1.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture2, slot);
                return;
            }
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture2, slot) {
        const textureProperties = properties.get(texture2);
        if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
            uploadTexture(textureProperties, texture2, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture2, slot) {
        const textureProperties = properties.get(texture2);
        if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
            uploadTexture(textureProperties, texture2, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture2, slot) {
        const textureProperties = properties.get(texture2);
        if (texture2.version > 0 && textureProperties.__version !== texture2.version) {
            uploadCubeTexture(textureProperties, texture2, slot);
            return;
        }
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
        [$267b85717c4872ea$export$7e167fb3a9a9867a]: 10497,
        [$267b85717c4872ea$export$73b90a84ed7db63c]: 33071,
        [$267b85717c4872ea$export$2dd54949bff6f96d]: 33648
    };
    const filterToGL = {
        [$267b85717c4872ea$export$f8b53649f0062e3e]: 9728,
        [$267b85717c4872ea$export$3d857d6c85506f73]: 9984,
        [$267b85717c4872ea$export$977236fa8e8d0f1d]: 9986,
        [$267b85717c4872ea$export$d8f3ba475551f5c1]: 9729,
        [$267b85717c4872ea$export$f8cffbbc87915209]: 9985,
        [$267b85717c4872ea$export$f4f4190ac785556]: 9987
    };
    function setTextureParameters(textureType, texture2, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, 10242, wrappingToGL[texture2.wrapS]);
            _gl.texParameteri(textureType, 10243, wrappingToGL[texture2.wrapT]);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, wrappingToGL[texture2.wrapR]);
            _gl.texParameteri(textureType, 10240, filterToGL[texture2.magFilter]);
            _gl.texParameteri(textureType, 10241, filterToGL[texture2.minFilter]);
        } else {
            _gl.texParameteri(textureType, 10242, 33071);
            _gl.texParameteri(textureType, 10243, 33071);
            if (textureType === 32879 || textureType === 35866) _gl.texParameteri(textureType, 32882, 33071);
            if (texture2.wrapS !== $267b85717c4872ea$export$73b90a84ed7db63c || texture2.wrapT !== $267b85717c4872ea$export$73b90a84ed7db63c) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, 10240, filterFallback(texture2.magFilter));
            _gl.texParameteri(textureType, 10241, filterFallback(texture2.minFilter));
            if (texture2.minFilter !== $267b85717c4872ea$export$f8b53649f0062e3e && texture2.minFilter !== $267b85717c4872ea$export$d8f3ba475551f5c1) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
            const extension = extensions.get('EXT_texture_filter_anisotropic');
            if (texture2.type === $267b85717c4872ea$export$64bd8724f3c14b98 && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2
            if (isWebGL2 === false && texture2.type === $267b85717c4872ea$export$c22551bc1ee2a31d && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only
            if (texture2.anisotropy > 1 || properties.get(texture2).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture2.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture2).__currentAnisotropy = texture2.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture2) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture2.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture2, slot) {
        let textureType = 3553;
        if (texture2.isDataTexture2DArray) textureType = 35866;
        if (texture2.isDataTexture3D) textureType = 32879;
        initTexture(textureProperties, texture2);
        state.activeTexture(33984 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture2.flipY);
        _gl.pixelStorei(37441, texture2.premultiplyAlpha);
        _gl.pixelStorei(3317, texture2.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture2) && isPowerOfTwo$1(texture2.image) === false;
        const image1 = resizeImage(texture2.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo$1(image1) || isWebGL2, glFormat = utils.convert(texture2.format);
        let glType = utils.convert(texture2.type), glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture2, supportsMips);
        let mipmap;
        const mipmaps = texture2.mipmaps;
        if (texture2.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = 6402;
            if (isWebGL2) {
                if (texture2.type === $267b85717c4872ea$export$64bd8724f3c14b98) glInternalFormat = 36012;
                else if (texture2.type === $267b85717c4872ea$export$fb395af353fbcc10) glInternalFormat = 33190;
                else if (texture2.type === $267b85717c4872ea$export$2773efb061bfa2af) glInternalFormat = 35056;
                else glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
            } else if (texture2.type === $267b85717c4872ea$export$64bd8724f3c14b98) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            // validation checks for WebGL 1
            if (texture2.format === $267b85717c4872ea$export$9e7c899e9114cafe && glInternalFormat === 6402) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture2.type !== $267b85717c4872ea$export$4a825e20fda0d845 && texture2.type !== $267b85717c4872ea$export$fb395af353fbcc10) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture2.type = $267b85717c4872ea$export$4a825e20fda0d845;
                    glType = utils.convert(texture2.type);
                }
            }
            if (texture2.format === $267b85717c4872ea$export$4db2359531a79852 && glInternalFormat === 6402) {
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                glInternalFormat = 34041;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture2.type !== $267b85717c4872ea$export$2773efb061bfa2af) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture2.type = $267b85717c4872ea$export$2773efb061bfa2af;
                    glType = utils.convert(texture2.type);
                }
            }
            //
            state.texImage2D(3553, 0, glInternalFormat, image1.width, image1.height, 0, glFormat, glType, null);
        } else if (texture2.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(let i2 = 0, il = mipmaps.length; i2 < il; i2++){
                    mipmap = mipmaps[i2];
                    state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture2.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(3553, 0, glInternalFormat, image1.width, image1.height, 0, glFormat, glType, image1.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture2.isCompressedTexture) {
            for(let i2 = 0, il = mipmaps.length; i2 < il; i2++){
                mipmap = mipmaps[i2];
                if (texture2.format !== $267b85717c4872ea$export$fdd3489947276d08 && texture2.format !== $267b85717c4872ea$export$cb1f224ebfa17eab) {
                    if (glFormat !== null) state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture2.isDataTexture2DArray) {
            state.texImage3D(35866, 0, glInternalFormat, image1.width, image1.height, image1.depth, 0, glFormat, glType, image1.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture2.isDataTexture3D) {
            state.texImage3D(32879, 0, glInternalFormat, image1.width, image1.height, image1.depth, 0, glFormat, glType, image1.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
            for(let i2 = 0, il = mipmaps.length; i2 < il; i2++){
                mipmap = mipmaps[i2];
                state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
            texture2.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image1);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture2, supportsMips)) generateMipmap(textureType, texture2, image1.width, image1.height);
        textureProperties.__version = texture2.version;
        if (texture2.onUpdate) texture2.onUpdate(texture2);
    }
    function uploadCubeTexture(textureProperties, texture2, slot) {
        if (texture2.image.length !== 6) return;
        initTexture(textureProperties, texture2);
        state.activeTexture(33984 + slot);
        state.bindTexture(34067, textureProperties.__webglTexture);
        _gl.pixelStorei(37440, texture2.flipY);
        _gl.pixelStorei(37441, texture2.premultiplyAlpha);
        _gl.pixelStorei(3317, texture2.unpackAlignment);
        _gl.pixelStorei(37443, 0);
        const isCompressed = texture2 && (texture2.isCompressedTexture || texture2.image[0].isCompressedTexture);
        const isDataTexture = texture2.image[0] && texture2.image[0].isDataTexture;
        const cubeImage = [];
        for(let i2 = 0; i2 < 6; i2++)if (!isCompressed && !isDataTexture) cubeImage[i2] = resizeImage(texture2.image[i2], false, true, maxCubemapSize);
        else cubeImage[i2] = isDataTexture ? texture2.image[i2].image : texture2.image[i2];
        const image1 = cubeImage[0], supportsMips = isPowerOfTwo$1(image1) || isWebGL2, glFormat = utils.convert(texture2.format), glType = utils.convert(texture2.type), glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType);
        setTextureParameters(34067, texture2, supportsMips);
        let mipmaps;
        if (isCompressed) {
            for(let i3 = 0; i3 < 6; i3++){
                mipmaps = cubeImage[i3].mipmaps;
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    if (texture2.format !== $267b85717c4872ea$export$fdd3489947276d08 && texture2.format !== $267b85717c4872ea$export$cb1f224ebfa17eab) {
                        if (glFormat !== null) state.compressedTexImage2D(34069 + i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                        else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                    } else state.texImage2D(34069 + i3, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            mipmaps = texture2.mipmaps;
            for(let i3 = 0; i3 < 6; i3++)if (isDataTexture) {
                state.texImage2D(34069 + i3, 0, glInternalFormat, cubeImage[i3].width, cubeImage[i3].height, 0, glFormat, glType, cubeImage[i3].data);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    const mipmapImage = mipmap.image[i3].image;
                    state.texImage2D(34069 + i3, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                }
            } else {
                state.texImage2D(34069 + i3, 0, glInternalFormat, glFormat, glType, cubeImage[i3]);
                for(let j = 0; j < mipmaps.length; j++){
                    const mipmap = mipmaps[j];
                    state.texImage2D(34069 + i3, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i3]);
                }
            }
            textureProperties.__maxMipLevel = mipmaps.length;
        }
        if (textureNeedsGenerateMipmaps(texture2, supportsMips)) // We assume images for cube map have the same size.
        generateMipmap(34067, texture2, image1.width, image1.height);
        textureProperties.__version = texture2.version;
        if (texture2.onUpdate) texture2.onUpdate(texture2);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget1, texture2, attachment, textureTarget) {
        const glFormat = utils.convert(texture2.format);
        const glType = utils.convert(texture2.type);
        const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType);
        if (textureTarget === 32879 || textureTarget === 35866) state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget1.width, renderTarget1.height, renderTarget1.depth, 0, glFormat, glType, null);
        else state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget1.width, renderTarget1.height, 0, glFormat, glType, null);
        state.bindFramebuffer(36160, framebuffer);
        _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture2).__webglTexture, 0);
        state.bindFramebuffer(36160, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget1, isMultisample) {
        _gl.bindRenderbuffer(36161, renderbuffer);
        if (renderTarget1.depthBuffer && !renderTarget1.stencilBuffer) {
            let glInternalFormat = 33189;
            if (isMultisample) {
                const depthTexture = renderTarget1.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === $267b85717c4872ea$export$64bd8724f3c14b98) glInternalFormat = 36012;
                    else if (depthTexture.type === $267b85717c4872ea$export$fb395af353fbcc10) glInternalFormat = 33190;
                }
                const samples = getRenderTargetSamples(renderTarget1);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget1.width, renderTarget1.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget1.width, renderTarget1.height);
            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
        } else if (renderTarget1.depthBuffer && renderTarget1.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget1);
                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget1.width, renderTarget1.height);
            } else _gl.renderbufferStorage(36161, 34041, renderTarget1.width, renderTarget1.height);
            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
        } else {
            // Use the first texture for MRT so far
            const texture2 = renderTarget1.isWebGLMultipleRenderTargets === true ? renderTarget1.texture[0] : renderTarget1.texture;
            const glFormat = utils.convert(texture2.format);
            const glType = utils.convert(texture2.type);
            const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget1);
                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget1.width, renderTarget1.height);
            } else _gl.renderbufferStorage(36161, glInternalFormat, renderTarget1.width, renderTarget1.height);
        }
        _gl.bindRenderbuffer(36161, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget1) {
        const isCube = renderTarget1 && renderTarget1.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        state.bindFramebuffer(36160, framebuffer);
        if (!(renderTarget1.depthTexture && renderTarget1.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget1.depthTexture).__webglTexture || renderTarget1.depthTexture.image.width !== renderTarget1.width || renderTarget1.depthTexture.image.height !== renderTarget1.height) {
            renderTarget1.depthTexture.image.width = renderTarget1.width;
            renderTarget1.depthTexture.image.height = renderTarget1.height;
            renderTarget1.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget1.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget1.depthTexture).__webglTexture;
        if (renderTarget1.depthTexture.format === $267b85717c4872ea$export$9e7c899e9114cafe) _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
        else if (renderTarget1.depthTexture.format === $267b85717c4872ea$export$4db2359531a79852) _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget1) {
        const renderTargetProperties = properties.get(renderTarget1);
        const isCube = renderTarget1.isWebGLCubeRenderTarget === true;
        if (renderTarget1.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget1);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i2 = 0; i2 < 6; i2++){
                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
                renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget1, false);
            }
        } else {
            state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget1, false);
        }
        state.bindFramebuffer(36160, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget1) {
        const texture2 = renderTarget1.texture;
        const renderTargetProperties = properties.get(renderTarget1);
        const textureProperties = properties.get(texture2);
        renderTarget1.addEventListener('dispose', onRenderTargetDispose);
        if (renderTarget1.isWebGLMultipleRenderTargets !== true) {
            textureProperties.__webglTexture = _gl.createTexture();
            textureProperties.__version = texture2.version;
            info.memory.textures++;
        }
        const isCube = renderTarget1.isWebGLCubeRenderTarget === true;
        const isMultipleRenderTargets = renderTarget1.isWebGLMultipleRenderTargets === true;
        const isMultisample = renderTarget1.isWebGLMultisampleRenderTarget === true;
        const isRenderTarget3D = texture2.isDataTexture3D || texture2.isDataTexture2DArray;
        const supportsMips = isPowerOfTwo$1(renderTarget1) || isWebGL2;
        // Handles WebGL2 RGBFormat fallback - #18858
        if (isWebGL2 && texture2.format === $267b85717c4872ea$export$cb1f224ebfa17eab && (texture2.type === $267b85717c4872ea$export$64bd8724f3c14b98 || texture2.type === $267b85717c4872ea$export$c22551bc1ee2a31d)) {
            texture2.format = $267b85717c4872ea$export$fdd3489947276d08;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i2 = 0; i2 < 6; i2++)renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultipleRenderTargets) {
                if (capabilities.drawBuffers) {
                    const textures = renderTarget1.texture;
                    for(let i2 = 0, il = textures.length; i2 < il; i2++){
                        const attachmentProperties = properties.get(textures[i2]);
                        if (attachmentProperties.__webglTexture === undefined) {
                            attachmentProperties.__webglTexture = _gl.createTexture();
                            info.memory.textures++;
                        }
                    }
                } else console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
            } else if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(texture2.format);
                    const glType = utils.convert(texture2.type);
                    const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget1);
                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget1.width, renderTarget1.height);
                    state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(36161, null);
                    if (renderTarget1.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget1, true);
                    }
                    state.bindFramebuffer(36160, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(34067, textureProperties.__webglTexture);
            setTextureParameters(34067, texture2, supportsMips);
            for(let i2 = 0; i2 < 6; i2++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget1, texture2, 36064, 34069 + i2);
            if (textureNeedsGenerateMipmaps(texture2, supportsMips)) generateMipmap(34067, texture2, renderTarget1.width, renderTarget1.height);
            state.bindTexture(34067, null);
        } else if (isMultipleRenderTargets) {
            const textures = renderTarget1.texture;
            for(let i2 = 0, il = textures.length; i2 < il; i2++){
                const attachment = textures[i2];
                const attachmentProperties = properties.get(attachment);
                state.bindTexture(3553, attachmentProperties.__webglTexture);
                setTextureParameters(3553, attachment, supportsMips);
                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget1, attachment, 36064 + i2, 3553);
                if (textureNeedsGenerateMipmaps(attachment, supportsMips)) generateMipmap(3553, attachment, renderTarget1.width, renderTarget1.height);
            }
            state.bindTexture(3553, null);
        } else {
            let glTextureType = 3553;
            if (isRenderTarget3D) {
                // Render targets containing layers, i.e: Texture 3D and 2d arrays
                if (isWebGL2) {
                    const isTexture3D = texture2.isDataTexture3D;
                    glTextureType = isTexture3D ? 32879 : 35866;
                } else console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
            }
            state.bindTexture(glTextureType, textureProperties.__webglTexture);
            setTextureParameters(glTextureType, texture2, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget1, texture2, 36064, glTextureType);
            if (textureNeedsGenerateMipmaps(texture2, supportsMips)) generateMipmap(glTextureType, texture2, renderTarget1.width, renderTarget1.height, renderTarget1.depth);
            state.bindTexture(glTextureType, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget1.depthBuffer) setupDepthRenderbuffer(renderTarget1);
    }
    function updateRenderTargetMipmap(renderTarget1) {
        const supportsMips = isPowerOfTwo$1(renderTarget1) || isWebGL2;
        const textures = renderTarget1.isWebGLMultipleRenderTargets === true ? renderTarget1.texture : [
            renderTarget1.texture
        ];
        for(let i2 = 0, il = textures.length; i2 < il; i2++){
            const texture2 = textures[i2];
            if (textureNeedsGenerateMipmaps(texture2, supportsMips)) {
                const target = renderTarget1.isWebGLCubeRenderTarget ? 34067 : 3553;
                const webglTexture = properties.get(texture2).__webglTexture;
                state.bindTexture(target, webglTexture);
                generateMipmap(target, texture2, renderTarget1.width, renderTarget1.height);
                state.bindTexture(target, null);
            }
        }
    }
    function updateMultisampleRenderTarget(renderTarget1) {
        if (renderTarget1.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const width8 = renderTarget1.width;
                const height8 = renderTarget1.height;
                let mask = 16384;
                if (renderTarget1.depthBuffer) mask |= 256;
                if (renderTarget1.stencilBuffer) mask |= 1024;
                const renderTargetProperties = properties.get(renderTarget1);
                state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                _gl.blitFramebuffer(0, 0, width8, height8, 0, 0, width8, height8, mask, 9728);
                state.bindFramebuffer(36008, null);
                state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget1) {
        return isWebGL2 && renderTarget1.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget1.samples) : 0;
    }
    function updateVideoTexture(texture2) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture2) !== frame) {
            _videoTextures.set(texture2, frame);
            texture2.update();
        }
    }
    // backwards compatibility
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture2, slot) {
        if (texture2 && texture2.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
                warnedTexture2D = true;
            }
            texture2 = texture2.texture;
        }
        setTexture2D(texture2, slot);
    }
    function safeSetTextureCube(texture2, slot) {
        if (texture2 && texture2.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
                warnedTextureCube = true;
            }
            texture2 = texture2.texture;
        }
        setTextureCube(texture2, slot);
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
function $267b85717c4872ea$export$f04c3186dcb1ccf2(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === $267b85717c4872ea$export$33b8d64de134adc1) return 5121;
        if (p === $267b85717c4872ea$export$e8900341e7540f8c) return 32819;
        if (p === $267b85717c4872ea$export$9690850d69171577) return 32820;
        if (p === $267b85717c4872ea$export$5da3b78b085b401d) return 33635;
        if (p === $267b85717c4872ea$export$5d43c8adb415a88a) return 5120;
        if (p === $267b85717c4872ea$export$6781601bc435a716) return 5122;
        if (p === $267b85717c4872ea$export$4a825e20fda0d845) return 5123;
        if (p === $267b85717c4872ea$export$c9de5d5e5b970ad5) return 5124;
        if (p === $267b85717c4872ea$export$fb395af353fbcc10) return 5125;
        if (p === $267b85717c4872ea$export$64bd8724f3c14b98) return 5126;
        if (p === $267b85717c4872ea$export$c22551bc1ee2a31d) {
            if (isWebGL2) return 5131;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === $267b85717c4872ea$export$f38bccefee451eaa) return 6406;
        if (p === $267b85717c4872ea$export$cb1f224ebfa17eab) return 6407;
        if (p === $267b85717c4872ea$export$fdd3489947276d08) return 6408;
        if (p === $267b85717c4872ea$export$999f557d3c8c3681) return 6409;
        if (p === $267b85717c4872ea$export$5710a603f99ec06e) return 6410;
        if (p === $267b85717c4872ea$export$9e7c899e9114cafe) return 6402;
        if (p === $267b85717c4872ea$export$4db2359531a79852) return 34041;
        if (p === $267b85717c4872ea$export$f0d5000ba8a776ea) return 6403;
        // WebGL2 formats.
        if (p === $267b85717c4872ea$export$6381e580c6532e0a) return 36244;
        if (p === $267b85717c4872ea$export$bb4542cbc0b0fcb4) return 33319;
        if (p === $267b85717c4872ea$export$7eaf8c0128a45eb7) return 33320;
        if (p === $267b85717c4872ea$export$6c64a16ae53bc40a) return 36248;
        if (p === $267b85717c4872ea$export$d9ae70be7e9145b5) return 36249;
        if (p === $267b85717c4872ea$export$47de5e258251f386 || p === $267b85717c4872ea$export$543f9c07fd164b56 || p === $267b85717c4872ea$export$b324179473ee2beb || p === $267b85717c4872ea$export$a92d2910884454c2) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === $267b85717c4872ea$export$47de5e258251f386) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === $267b85717c4872ea$export$543f9c07fd164b56) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === $267b85717c4872ea$export$b324179473ee2beb) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === $267b85717c4872ea$export$a92d2910884454c2) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === $267b85717c4872ea$export$2ff26eb41f992be7 || p === $267b85717c4872ea$export$3908ca1f09c8af6d || p === $267b85717c4872ea$export$ec2a0d199cb4688d || p === $267b85717c4872ea$export$1f64ee88d8c1b79d) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === $267b85717c4872ea$export$2ff26eb41f992be7) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === $267b85717c4872ea$export$3908ca1f09c8af6d) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === $267b85717c4872ea$export$ec2a0d199cb4688d) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === $267b85717c4872ea$export$1f64ee88d8c1b79d) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === $267b85717c4872ea$export$311582cb92b9f0ce) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === $267b85717c4872ea$export$54e325746e5af855 || p === $267b85717c4872ea$export$e4dd60eba5a0f51d) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === $267b85717c4872ea$export$54e325746e5af855) return extension.COMPRESSED_RGB8_ETC2;
                if (p === $267b85717c4872ea$export$e4dd60eba5a0f51d) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === $267b85717c4872ea$export$6f46e5a91a34b69f || p === $267b85717c4872ea$export$d3526ab43ceb959d || p === $267b85717c4872ea$export$7c39c8281574170 || p === $267b85717c4872ea$export$b3da099ba6df5e6d || p === $267b85717c4872ea$export$72c0cb4bed2648f5 || p === $267b85717c4872ea$export$e7504f3f6a0d8461 || p === $267b85717c4872ea$export$b1b6a0fb53a81093 || p === $267b85717c4872ea$export$9fa5145c61535f3c || p === $267b85717c4872ea$export$767a9de51290e906 || p === $267b85717c4872ea$export$ddc7e5bbcc2a758d || p === $267b85717c4872ea$export$640456ee42ded39e || p === $267b85717c4872ea$export$b3e2613a5c8f1fb5 || p === $267b85717c4872ea$export$e17495e09dc978d1 || p === $267b85717c4872ea$export$64c98186ccc95178 || p === $267b85717c4872ea$export$e0b7643d13ca1a09 || p === $267b85717c4872ea$export$e18c9d1306bf8de9 || p === $267b85717c4872ea$export$7c38c998ae4be8e4 || p === $267b85717c4872ea$export$583370b2d6bc81b1 || p === $267b85717c4872ea$export$68ac1a00d1685202 || p === $267b85717c4872ea$export$9f354c8a98a199aa || p === $267b85717c4872ea$export$6924f47271244951 || p === $267b85717c4872ea$export$270e187d8e261ee7 || p === $267b85717c4872ea$export$b365e692b627d538 || p === $267b85717c4872ea$export$35e73e04c104281 || p === $267b85717c4872ea$export$9622f924286f6aad || p === $267b85717c4872ea$export$9d29e480b5b4e442 || p === $267b85717c4872ea$export$23e303fe9ae2bdaf || p === $267b85717c4872ea$export$2a7a787eb5fd19b0) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === $267b85717c4872ea$export$2fc72d562acdcc34) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === $267b85717c4872ea$export$2773efb061bfa2af) {
            if (isWebGL2) return 34042;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
class $267b85717c4872ea$export$d779f9097869a610 extends $267b85717c4872ea$export$95bab1c599905cc4 {
    constructor(array12 = []){
        super();
        this.cameras = array12;
    }
}
$267b85717c4872ea$export$d779f9097869a610.prototype.isArrayCamera = true;
class $267b85717c4872ea$export$a145e63780346cea extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this.type = 'Group';
    }
}
$267b85717c4872ea$export$a145e63780346cea.prototype.isGroup = true;
const $267b85717c4872ea$var$_moveEvent = {
    type: 'move'
};
class $267b85717c4872ea$var$WebXRController {
    constructor(){
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
    }
    getHandSpace() {
        if (this._hand === null) {
            this._hand = new $267b85717c4872ea$export$a145e63780346cea();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {
            };
            this._hand.inputState = {
                pinching: false
            };
        }
        return this._hand;
    }
    getTargetRaySpace() {
        if (this._targetRay === null) {
            this._targetRay = new $267b85717c4872ea$export$a145e63780346cea();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        }
        return this._targetRay;
    }
    getGripSpace() {
        if (this._grip === null) {
            this._grip = new $267b85717c4872ea$export$a145e63780346cea();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        }
        return this._grip;
    }
    dispatchEvent(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    }
    disconnect(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    }
    update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
            if (targetRay !== null) {
                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                if (inputPose !== null) {
                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    if (inputPose.linearVelocity) {
                        targetRay.hasLinearVelocity = true;
                        targetRay.linearVelocity.copy(inputPose.linearVelocity);
                    } else targetRay.hasLinearVelocity = false;
                    if (inputPose.angularVelocity) {
                        targetRay.hasAngularVelocity = true;
                        targetRay.angularVelocity.copy(inputPose.angularVelocity);
                    } else targetRay.hasAngularVelocity = false;
                    this.dispatchEvent($267b85717c4872ea$var$_moveEvent);
                }
            }
            if (hand && inputSource.hand) {
                handPose = true;
                for (const inputjoint of inputSource.hand.values()){
                    // Update the joints groups with the XRJoint poses
                    const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                    if (hand.joints[inputjoint.jointName] === undefined) {
                        // The transform of this joint will be updated with the joint pose on each frame
                        const joint = new $267b85717c4872ea$export$a145e63780346cea();
                        joint.matrixAutoUpdate = false;
                        joint.visible = false;
                        hand.joints[inputjoint.jointName] = joint;
                        // ??
                        hand.add(joint);
                    }
                    const joint = hand.joints[inputjoint.jointName];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                }
                // Custom events
                // Check pinchz
                const indexTip = hand.joints['index-finger-tip'];
                const thumbTip = hand.joints['thumb-tip'];
                const distance = indexTip.position.distanceTo(thumbTip.position);
                const distanceToPinch = 0.02;
                const threshold = 0.005;
                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                    hand.inputState.pinching = false;
                    this.dispatchEvent({
                        type: 'pinchend',
                        handedness: inputSource.handedness,
                        target: this
                    });
                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                    hand.inputState.pinching = true;
                    this.dispatchEvent({
                        type: 'pinchstart',
                        handedness: inputSource.handedness,
                        target: this
                    });
                }
            } else if (grip !== null && inputSource.gripSpace) {
                gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                if (gripPose !== null) {
                    grip.matrix.fromArray(gripPose.transform.matrix);
                    grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    if (gripPose.linearVelocity) {
                        grip.hasLinearVelocity = true;
                        grip.linearVelocity.copy(gripPose.linearVelocity);
                    } else grip.hasLinearVelocity = false;
                    if (gripPose.angularVelocity) {
                        grip.hasAngularVelocity = true;
                        grip.angularVelocity.copy(gripPose.angularVelocity);
                    } else grip.hasAngularVelocity = false;
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
}
class $267b85717c4872ea$var$WebXRManager extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(renderer, gl){
        super();
        const scope1 = this;
        const state = renderer.state;
        let session = null;
        let framebufferScaleFactor = 1;
        let referenceSpace = null;
        let referenceSpaceType = 'local-floor';
        let pose = null;
        let glBinding = null;
        let glFramebuffer = null;
        let glProjLayer = null;
        const controllers = [];
        const inputSourcesMap = new Map();
        //
        const cameraL = new $267b85717c4872ea$export$95bab1c599905cc4();
        cameraL.layers.enable(1);
        cameraL.viewport = new $267b85717c4872ea$export$14dfcb76afe97063();
        const cameraR = new $267b85717c4872ea$export$95bab1c599905cc4();
        cameraR.layers.enable(2);
        cameraR.viewport = new $267b85717c4872ea$export$14dfcb76afe97063();
        const cameras = [
            cameraL,
            cameraR
        ];
        const cameraVR = new $267b85717c4872ea$export$d779f9097869a610();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        //
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $267b85717c4872ea$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $267b85717c4872ea$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getGripSpace();
        };
        this.getHand = function(index) {
            let controller = controllers[index];
            if (controller === undefined) {
                controller = new $267b85717c4872ea$var$WebXRController();
                controllers[index] = controller;
            }
            return controller.getHandSpace();
        };
        //
        function onSessionEvent(event) {
            const controller = inputSourcesMap.get(event.inputSource);
            if (controller) controller.dispatchEvent({
                type: event.type,
                data: event.inputSource
            });
        }
        function onSessionEnd() {
            inputSourcesMap.forEach(function(controller, inputSource) {
                controller.disconnect(inputSource);
            });
            inputSourcesMap.clear();
            _currentDepthNear = null;
            _currentDepthFar = null;
            // restore framebuffer/rendering state
            state.bindXRFramebuffer(null);
            renderer.setRenderTarget(renderer.getRenderTarget());
            //
            animation1.stop();
            scope1.isPresenting = false;
            scope1.dispatchEvent({
                type: 'sessionend'
            });
        }
        this.setFramebufferScaleFactor = function(value) {
            framebufferScaleFactor = value;
            if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
        };
        this.setReferenceSpaceType = function(value) {
            referenceSpaceType = value;
            if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
        };
        this.getReferenceSpace = function() {
            return referenceSpace;
        };
        this.getSession = function() {
            return session;
        };
        this.setSession = async function(value) {
            session = value;
            if (session !== null) {
                session.addEventListener('select', onSessionEvent);
                session.addEventListener('selectstart', onSessionEvent);
                session.addEventListener('selectend', onSessionEvent);
                session.addEventListener('squeeze', onSessionEvent);
                session.addEventListener('squeezestart', onSessionEvent);
                session.addEventListener('squeezeend', onSessionEvent);
                session.addEventListener('end', onSessionEnd);
                session.addEventListener('inputsourceschange', onInputSourcesChange);
                const attributes = gl.getContextAttributes();
                if (attributes.xrCompatible !== true) await gl.makeXRCompatible();
                if (session.renderState.layers === undefined) {
                    const layerInit = {
                        antialias: attributes.antialias,
                        alpha: attributes.alpha,
                        depth: attributes.depth,
                        stencil: attributes.stencil,
                        framebufferScaleFactor: framebufferScaleFactor
                    };
                    // eslint-disable-next-line no-undef
                    const baseLayer = new XRWebGLLayer(session, gl, layerInit);
                    session.updateRenderState({
                        baseLayer: baseLayer
                    });
                } else {
                    let depthFormat = 0;
                    if (attributes.depth) depthFormat = attributes.stencil ? 34041 : 6402;
                    const projectionlayerInit = {
                        colorFormat: attributes.alpha ? 6408 : 6407,
                        depthFormat: depthFormat,
                        scaleFactor: framebufferScaleFactor
                    };
                    // eslint-disable-next-line no-undef
                    glBinding = new XRWebGLBinding(session, gl);
                    glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                    glFramebuffer = gl.createFramebuffer();
                    session.updateRenderState({
                        layers: [
                            glProjLayer
                        ]
                    });
                }
                referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
                animation1.setContext(session);
                animation1.start();
                scope1.isPresenting = true;
                scope1.dispatchEvent({
                    type: 'sessionstart'
                });
            }
        };
        function onInputSourcesChange(event) {
            const inputSources = session.inputSources;
            // Assign inputSources to available controllers
            for(let i2 = 0; i2 < controllers.length; i2++)inputSourcesMap.set(inputSources[i2], controllers[i2]);
            // Notify disconnected
            for(let i3 = 0; i3 < event.removed.length; i3++){
                const inputSource = event.removed[i3];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) {
                    controller.dispatchEvent({
                        type: 'disconnected',
                        data: inputSource
                    });
                    inputSourcesMap.delete(inputSource);
                }
            }
            // Notify connected
            for(let i4 = 0; i4 < event.added.length; i4++){
                const inputSource = event.added[i4];
                const controller = inputSourcesMap.get(inputSource);
                if (controller) controller.dispatchEvent({
                    type: 'connected',
                    data: inputSource
                });
            }
        }
        //
        const cameraLPos = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const cameraRPos = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        /**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */ function setProjectionFromUnion(camera, cameraL1, cameraR1) {
            cameraLPos.setFromMatrixPosition(cameraL1.matrixWorld);
            cameraRPos.setFromMatrixPosition(cameraR1.matrixWorld);
            const ipd = cameraLPos.distanceTo(cameraRPos);
            const projL = cameraL1.projectionMatrix.elements;
            const projR = cameraR1.projectionMatrix.elements;
            // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            const near2 = projL[14] / (projL[10] - 1);
            const far2 = projL[14] / (projL[10] + 1);
            const topFov = (projL[9] + 1) / projL[5];
            const bottomFov = (projL[9] - 1) / projL[5];
            const leftFov = (projL[8] - 1) / projL[0];
            const rightFov = (projR[8] + 1) / projR[0];
            const left = near2 * leftFov;
            const right = near2 * rightFov;
            // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            const zOffset = ipd / (-leftFov + rightFov);
            const xOffset = zOffset * -leftFov;
            // TODO: Better way to apply this offset?
            cameraL1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
            camera.translateX(xOffset);
            camera.translateZ(zOffset);
            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            const near21 = near2 + zOffset;
            const far21 = far2 + zOffset;
            const left2 = left - xOffset;
            const right2 = right + (ipd - xOffset);
            const top2 = topFov * far2 / far21 * near21;
            const bottom2 = bottomFov * far2 / far21 * near21;
            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near21, far21);
        }
        function updateCamera(camera, parent) {
            if (parent === null) camera.matrixWorld.copy(camera.matrix);
            else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
            if (session === null) return;
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                // Note that the new renderState won't apply until the next frame. See #18320
                session.updateRenderState({
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                });
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
            }
            const parent = camera.parent;
            const cameras1 = cameraVR.cameras;
            updateCamera(cameraVR, parent);
            for(let i2 = 0; i2 < cameras1.length; i2++)updateCamera(cameras1[i2], parent);
            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
            // update user camera and its children
            camera.position.copy(cameraVR.position);
            camera.quaternion.copy(cameraVR.quaternion);
            camera.scale.copy(cameraVR.scale);
            camera.matrix.copy(cameraVR.matrix);
            camera.matrixWorld.copy(cameraVR.matrixWorld);
            const children = camera.children;
            for(let i3 = 0, l = children.length; i3 < l; i3++)children[i3].updateMatrixWorld(true);
            // update projection matrix for proper view frustum culling
            if (cameras1.length === 2) setProjectionFromUnion(cameraVR, cameraL, cameraR);
            else // assume single camera setup (AR)
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        };
        this.getCamera = function() {
            return cameraVR;
        };
        // Animation Loop
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
            pose = frame.getViewerPose(referenceSpace);
            if (pose !== null) {
                const views = pose.views;
                const baseLayer = session.renderState.baseLayer;
                if (session.renderState.layers === undefined) state.bindXRFramebuffer(baseLayer.framebuffer);
                let cameraVRNeedsUpdate = false;
                // check if it's necessary to rebuild cameraVR's camera list
                if (views.length !== cameraVR.cameras.length) {
                    cameraVR.cameras.length = 0;
                    cameraVRNeedsUpdate = true;
                }
                for(let i2 = 0; i2 < views.length; i2++){
                    const view = views[i2];
                    let viewport = null;
                    if (session.renderState.layers === undefined) viewport = baseLayer.getViewport(view);
                    else {
                        const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                        state.bindXRFramebuffer(glFramebuffer);
                        gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
                        if (glSubImage.depthStencilTexture !== undefined) gl.framebufferTexture2D(36160, 36096, 3553, glSubImage.depthStencilTexture, 0);
                        viewport = glSubImage.viewport;
                    }
                    const camera = cameras[i2];
                    camera.matrix.fromArray(view.transform.matrix);
                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                    if (i2 === 0) cameraVR.matrix.copy(camera.matrix);
                    if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
                }
            }
            //
            const inputSources = session.inputSources;
            for(let i2 = 0; i2 < controllers.length; i2++){
                const controller = controllers[i2];
                const inputSource = inputSources[i2];
                controller.update(inputSource, frame, referenceSpace);
            }
            if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
        }
        const animation1 = new $267b85717c4872ea$var$WebGLAnimation();
        animation1.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
            onAnimationFrameCallback = callback;
        };
        this.dispose = function() {
        };
    }
}
function $267b85717c4872ea$var$WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material1, pixelRatio, height8, transmissionRenderTarget) {
        if (material1.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material1);
        else if (material1.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsLambert(uniforms, material1);
        } else if (material1.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsToon(uniforms, material1);
        } else if (material1.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsPhong(uniforms, material1);
        } else if (material1.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material1);
            if (material1.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material1, transmissionRenderTarget);
            else refreshUniformsStandard(uniforms, material1);
        } else if (material1.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsMatcap(uniforms, material1);
        } else if (material1.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsDepth(uniforms, material1);
        } else if (material1.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsDistance(uniforms, material1);
        } else if (material1.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material1);
            refreshUniformsNormal(uniforms, material1);
        } else if (material1.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material1);
            if (material1.isLineDashedMaterial) refreshUniformsDash(uniforms, material1);
        } else if (material1.isPointsMaterial) refreshUniformsPoints(uniforms, material1, pixelRatio, height8);
        else if (material1.isSpriteMaterial) refreshUniformsSprites(uniforms, material1);
        else if (material1.isShadowMaterial) {
            uniforms.color.value.copy(material1.color);
            uniforms.opacity.value = material1.opacity;
        } else if (material1.isShaderMaterial) material1.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material1) {
        uniforms.opacity.value = material1.opacity;
        if (material1.color) uniforms.diffuse.value.copy(material1.color);
        if (material1.emissive) uniforms.emissive.value.copy(material1.emissive).multiplyScalar(material1.emissiveIntensity);
        if (material1.map) uniforms.map.value = material1.map;
        if (material1.alphaMap) uniforms.alphaMap.value = material1.alphaMap;
        if (material1.specularMap) uniforms.specularMap.value = material1.specularMap;
        const envMap = properties.get(material1).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;
            uniforms.reflectivity.value = material1.reflectivity;
            uniforms.refractionRatio.value = material1.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
        }
        if (material1.lightMap) {
            uniforms.lightMap.value = material1.lightMap;
            uniforms.lightMapIntensity.value = material1.lightMapIntensity;
        }
        if (material1.aoMap) {
            uniforms.aoMap.value = material1.aoMap;
            uniforms.aoMapIntensity.value = material1.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. displacementMap map
        // 4. normal map
        // 5. bump map
        // 6. roughnessMap map
        // 7. metalnessMap map
        // 8. alphaMap map
        // 9. emissiveMap map
        // 10. clearcoat map
        // 11. clearcoat normal map
        // 12. clearcoat roughnessMap map
        let uvScaleMap;
        if (material1.map) uvScaleMap = material1.map;
        else if (material1.specularMap) uvScaleMap = material1.specularMap;
        else if (material1.displacementMap) uvScaleMap = material1.displacementMap;
        else if (material1.normalMap) uvScaleMap = material1.normalMap;
        else if (material1.bumpMap) uvScaleMap = material1.bumpMap;
        else if (material1.roughnessMap) uvScaleMap = material1.roughnessMap;
        else if (material1.metalnessMap) uvScaleMap = material1.metalnessMap;
        else if (material1.alphaMap) uvScaleMap = material1.alphaMap;
        else if (material1.emissiveMap) uvScaleMap = material1.emissiveMap;
        else if (material1.clearcoatMap) uvScaleMap = material1.clearcoatMap;
        else if (material1.clearcoatNormalMap) uvScaleMap = material1.clearcoatNormalMap;
        else if (material1.clearcoatRoughnessMap) uvScaleMap = material1.clearcoatRoughnessMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material1.aoMap) uv2ScaleMap = material1.aoMap;
        else if (material1.lightMap) uv2ScaleMap = material1.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material1) {
        uniforms.diffuse.value.copy(material1.color);
        uniforms.opacity.value = material1.opacity;
    }
    function refreshUniformsDash(uniforms, material1) {
        uniforms.dashSize.value = material1.dashSize;
        uniforms.totalSize.value = material1.dashSize + material1.gapSize;
        uniforms.scale.value = material1.scale;
    }
    function refreshUniformsPoints(uniforms, material1, pixelRatio, height8) {
        uniforms.diffuse.value.copy(material1.color);
        uniforms.opacity.value = material1.opacity;
        uniforms.size.value = material1.size * pixelRatio;
        uniforms.scale.value = height8 * 0.5;
        if (material1.map) uniforms.map.value = material1.map;
        if (material1.alphaMap) uniforms.alphaMap.value = material1.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material1.map) uvScaleMap = material1.map;
        else if (material1.alphaMap) uvScaleMap = material1.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material1) {
        uniforms.diffuse.value.copy(material1.color);
        uniforms.opacity.value = material1.opacity;
        uniforms.rotation.value = material1.rotation;
        if (material1.map) uniforms.map.value = material1.map;
        if (material1.alphaMap) uniforms.alphaMap.value = material1.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material1.map) uvScaleMap = material1.map;
        else if (material1.alphaMap) uvScaleMap = material1.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material1) {
        if (material1.emissiveMap) uniforms.emissiveMap.value = material1.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material1) {
        uniforms.specular.value.copy(material1.specular);
        uniforms.shininess.value = Math.max(material1.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
        if (material1.emissiveMap) uniforms.emissiveMap.value = material1.emissiveMap;
        if (material1.bumpMap) {
            uniforms.bumpMap.value = material1.bumpMap;
            uniforms.bumpScale.value = material1.bumpScale;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.bumpScale.value *= -1;
        }
        if (material1.normalMap) {
            uniforms.normalMap.value = material1.normalMap;
            uniforms.normalScale.value.copy(material1.normalScale);
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.normalScale.value.negate();
        }
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material1) {
        if (material1.gradientMap) uniforms.gradientMap.value = material1.gradientMap;
        if (material1.emissiveMap) uniforms.emissiveMap.value = material1.emissiveMap;
        if (material1.bumpMap) {
            uniforms.bumpMap.value = material1.bumpMap;
            uniforms.bumpScale.value = material1.bumpScale;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.bumpScale.value *= -1;
        }
        if (material1.normalMap) {
            uniforms.normalMap.value = material1.normalMap;
            uniforms.normalScale.value.copy(material1.normalScale);
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.normalScale.value.negate();
        }
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material1) {
        uniforms.roughness.value = material1.roughness;
        uniforms.metalness.value = material1.metalness;
        if (material1.roughnessMap) uniforms.roughnessMap.value = material1.roughnessMap;
        if (material1.metalnessMap) uniforms.metalnessMap.value = material1.metalnessMap;
        if (material1.emissiveMap) uniforms.emissiveMap.value = material1.emissiveMap;
        if (material1.bumpMap) {
            uniforms.bumpMap.value = material1.bumpMap;
            uniforms.bumpScale.value = material1.bumpScale;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.bumpScale.value *= -1;
        }
        if (material1.normalMap) {
            uniforms.normalMap.value = material1.normalMap;
            uniforms.normalScale.value.copy(material1.normalScale);
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.normalScale.value.negate();
        }
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
        const envMap = properties.get(material1).envMap;
        if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material1.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material1, transmissionRenderTarget) {
        refreshUniformsStandard(uniforms, material1);
        uniforms.reflectivity.value = material1.reflectivity; // also part of uniforms common
        uniforms.clearcoat.value = material1.clearcoat;
        uniforms.clearcoatRoughness.value = material1.clearcoatRoughness;
        if (material1.sheen) uniforms.sheen.value.copy(material1.sheen);
        if (material1.clearcoatMap) uniforms.clearcoatMap.value = material1.clearcoatMap;
        if (material1.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material1.clearcoatRoughnessMap;
        if (material1.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material1.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material1.clearcoatNormalMap;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.clearcoatNormalScale.value.negate();
        }
        uniforms.transmission.value = material1.transmission;
        if (material1.transmissionMap) uniforms.transmissionMap.value = material1.transmissionMap;
        if (material1.transmission > 0) {
            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        }
        uniforms.thickness.value = material1.thickness;
        if (material1.thicknessMap) uniforms.thicknessMap.value = material1.thicknessMap;
        uniforms.attenuationDistance.value = material1.attenuationDistance;
        uniforms.attenuationColor.value.copy(material1.attenuationColor);
    }
    function refreshUniformsMatcap(uniforms, material1) {
        if (material1.matcap) uniforms.matcap.value = material1.matcap;
        if (material1.bumpMap) {
            uniforms.bumpMap.value = material1.bumpMap;
            uniforms.bumpScale.value = material1.bumpScale;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.bumpScale.value *= -1;
        }
        if (material1.normalMap) {
            uniforms.normalMap.value = material1.normalMap;
            uniforms.normalScale.value.copy(material1.normalScale);
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.normalScale.value.negate();
        }
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material1) {
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material1) {
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
        uniforms.referencePosition.value.copy(material1.referencePosition);
        uniforms.nearDistance.value = material1.nearDistance;
        uniforms.farDistance.value = material1.farDistance;
    }
    function refreshUniformsNormal(uniforms, material1) {
        if (material1.bumpMap) {
            uniforms.bumpMap.value = material1.bumpMap;
            uniforms.bumpScale.value = material1.bumpScale;
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.bumpScale.value *= -1;
        }
        if (material1.normalMap) {
            uniforms.normalMap.value = material1.normalMap;
            uniforms.normalScale.value.copy(material1.normalScale);
            if (material1.side === $267b85717c4872ea$export$fbde0e233a2945e1) uniforms.normalScale.value.negate();
        }
        if (material1.displacementMap) {
            uniforms.displacementMap.value = material1.displacementMap;
            uniforms.displacementScale.value = material1.displacementScale;
            uniforms.displacementBias.value = material1.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
function $267b85717c4872ea$var$createCanvasElement() {
    const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    canvas.style.display = 'block';
    return canvas;
}
function $267b85717c4872ea$export$55c403e650ad28d0(parameters4 = {
}) {
    const _canvas = parameters4.canvas !== undefined ? parameters4.canvas : $267b85717c4872ea$var$createCanvasElement(), _context = parameters4.context !== undefined ? parameters4.context : null, _alpha = parameters4.alpha !== undefined ? parameters4.alpha : false, _depth = parameters4.depth !== undefined ? parameters4.depth : true, _stencil = parameters4.stencil !== undefined ? parameters4.stencil : true, _antialias = parameters4.antialias !== undefined ? parameters4.antialias : false, _premultipliedAlpha = parameters4.premultipliedAlpha !== undefined ? parameters4.premultipliedAlpha : true, _preserveDrawingBuffer = parameters4.preserveDrawingBuffer !== undefined ? parameters4.preserveDrawingBuffer : false, _powerPreference = parameters4.powerPreference !== undefined ? parameters4.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters4.failIfMajorPerformanceCaveat !== undefined ? parameters4.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    // render() can be called from within a callback triggered by another render.
    // We track this so that the nested render call gets its list and state isolated from the parent render call.
    const renderListStack = [];
    const renderStateStack = [];
    // public properties
    this.domElement = _canvas;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */ checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2; // for backwards compatibility
    this.outputEncoding = $267b85717c4872ea$export$b2fb0348530d6a72;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = $267b85717c4872ea$export$f1d4bd8fdcc91a4e;
    this.toneMappingExposure = 1;
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new $267b85717c4872ea$export$14dfcb76afe97063();
    const _currentScissor = new $267b85717c4872ea$export$14dfcb76afe97063();
    let _currentScissorTest = null;
    //
    let _width = _canvas.width;
    let _height = _canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, _width, _height);
    const _scissor = new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, _width, _height);
    let _scissorTest = false;
    //
    const _currentDrawBuffers = [];
    // frustum
    const _frustum = new $267b85717c4872ea$export$6ef72105b8c3e2c6();
    // clipping
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // transmission
    let _transmissionRenderTarget = null;
    // camera matrices cache
    const _projScreenMatrix = new $267b85717c4872ea$export$960b1460cb9cd6c9();
    const _vector3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
        for(let i2 = 0; i2 < contextNames.length; i2++){
            const contextName = contextNames[i2];
            const context = _canvas.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas.addEventListener('webglcontextlost', onContextLost, false);
        _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state1, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new $267b85717c4872ea$var$WebGLExtensions(_gl);
        capabilities = new $267b85717c4872ea$var$WebGLCapabilities(_gl, extensions, parameters4);
        extensions.init(capabilities);
        utils = new $267b85717c4872ea$export$f04c3186dcb1ccf2(_gl, extensions, capabilities);
        state1 = new $267b85717c4872ea$var$WebGLState(_gl, extensions, capabilities);
        _currentDrawBuffers[0] = 1029;
        info = new $267b85717c4872ea$var$WebGLInfo(_gl);
        properties = new $267b85717c4872ea$var$WebGLProperties();
        textures = new $267b85717c4872ea$var$WebGLTextures(_gl, extensions, state1, properties, capabilities, utils, info);
        cubemaps = new $267b85717c4872ea$var$WebGLCubeMaps(_this);
        attributes = new $267b85717c4872ea$var$WebGLAttributes(_gl, capabilities);
        bindingStates = new $267b85717c4872ea$var$WebGLBindingStates(_gl, extensions, attributes, capabilities);
        geometries = new $267b85717c4872ea$var$WebGLGeometries(_gl, attributes, info, bindingStates);
        objects = new $267b85717c4872ea$var$WebGLObjects(_gl, geometries, attributes, info);
        morphtargets = new $267b85717c4872ea$var$WebGLMorphtargets(_gl);
        clipping = new $267b85717c4872ea$var$WebGLClipping(properties);
        programCache = new $267b85717c4872ea$var$WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);
        materials = new $267b85717c4872ea$var$WebGLMaterials(properties);
        renderLists = new $267b85717c4872ea$var$WebGLRenderLists(properties);
        renderStates = new $267b85717c4872ea$var$WebGLRenderStates(extensions, capabilities);
        background = new $267b85717c4872ea$var$WebGLBackground(_this, cubemaps, state1, objects, _premultipliedAlpha);
        shadowMap = new $267b85717c4872ea$var$WebGLShadowMap(_this, objects, capabilities);
        bufferRenderer = new $267b85717c4872ea$var$WebGLBufferRenderer(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new $267b85717c4872ea$var$WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.shadowMap = shadowMap;
        _this.state = state1;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new $267b85717c4872ea$var$WebXRManager(_this, _gl);
    this.xr = xr;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        return target.set(_width, _height);
    };
    this.setSize = function(width8, height8, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width8;
        _height = height8;
        _canvas.width = Math.floor(width8 * _pixelRatio);
        _canvas.height = Math.floor(height8 * _pixelRatio);
        if (updateStyle !== false) {
            _canvas.style.width = width8 + 'px';
            _canvas.style.height = height8 + 'px';
        }
        this.setViewport(0, 0, width8, height8);
    };
    this.getDrawingBufferSize = function(target) {
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width8, height8, pixelRatio) {
        _width = width8;
        _height = height8;
        _pixelRatio = pixelRatio;
        _canvas.width = Math.floor(width8 * pixelRatio);
        _canvas.height = Math.floor(height8 * pixelRatio);
        this.setViewport(0, 0, width8, height8);
    };
    this.getCurrentViewport = function(target) {
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x6, y6, width8, height8) {
        if (x6.isVector4) _viewport.set(x6.x, x6.y, x6.z, x6.w);
        else _viewport.set(x6, y6, width8, height8);
        state1.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x6, y6, width8, height8) {
        if (x6.isVector4) _scissor.set(x6.x, x6.y, x6.z, x6.w);
        else _scissor.set(x6, y6, width8, height8);
        state1.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state1.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function(target) {
        return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth4, stencil) {
        let bits = 0;
        if (color === undefined || color) bits |= 16384;
        if (depth4 === undefined || depth4) bits |= 256;
        if (stencil === undefined || stencil) bits |= 1024;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        xr.removeEventListener('sessionstart', onXRSessionStart);
        xr.removeEventListener('sessionend', onXRSessionEnd);
        if (_transmissionRenderTarget) {
            _transmissionRenderTarget.dispose();
            _transmissionRenderTarget = null;
        }
        animation2.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        const infoAutoReset = info.autoReset;
        const shadowMapEnabled = shadowMap.enabled;
        const shadowMapAutoUpdate = shadowMap.autoUpdate;
        const shadowMapNeedsUpdate = shadowMap.needsUpdate;
        const shadowMapType = shadowMap.type;
        initGLContext();
        info.autoReset = infoAutoReset;
        shadowMap.enabled = shadowMapEnabled;
        shadowMap.autoUpdate = shadowMapAutoUpdate;
        shadowMap.needsUpdate = shadowMapNeedsUpdate;
        shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
        const material1 = event.target;
        material1.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material1);
    }
    // Buffer deallocation
    function deallocateMaterial(material1) {
        releaseMaterialProgramReferences(material1);
        properties.remove(material1);
    }
    function releaseMaterialProgramReferences(material1) {
        const programs = properties.get(material1).programs;
        if (programs !== undefined) programs.forEach(function(program) {
            programCache.releaseProgram(program);
        });
    }
    // Buffer rendering
    function renderObjectImmediate(object, program) {
        object.render(function(object1) {
            _this.renderBufferImmediate(object1, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(34962, buffers.position);
            _gl.bufferData(34962, object.positionArray, 35048);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(34962, buffers.normal);
            _gl.bufferData(34962, object.normalArray, 35048);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(34962, buffers.uv);
            _gl.bufferData(34962, object.uvArray, 35048);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(34962, buffers.color);
            _gl.bufferData(34962, object.colorArray, 35048);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(4, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry1, material1, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material1, object);
        state1.setMaterial(material1, frontFaceCW);
        //
        let index = geometry1.index;
        const position1 = geometry1.attributes.position;
        //
        if (index === null) {
            if (position1 === undefined || position1.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material1.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry1);
            rangeFactor = 2;
        }
        if (material1.morphTargets || material1.morphNormals) morphtargets.update(object, geometry1, material1, program);
        bindingStates.setup(object, material1, program, geometry1, index);
        let attribute;
        let renderer1 = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer1 = indexedBufferRenderer;
            renderer1.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position1.count;
        const rangeStart = geometry1.drawRange.start * rangeFactor;
        const rangeCount = geometry1.drawRange.count * rangeFactor;
        const groupStart1 = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart1);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart1 + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material1.wireframe === true) {
                state1.setLineWidth(material1.wireframeLinewidth * getTargetPixelRatio());
                renderer1.setMode(1);
            } else renderer1.setMode(4);
        } else if (object.isLine) {
            let lineWidth = material1.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state1.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer1.setMode(1);
            else if (object.isLineLoop) renderer1.setMode(2);
            else renderer1.setMode(3);
        } else if (object.isPoints) renderer1.setMode(0);
        else if (object.isSprite) renderer1.setMode(4);
        if (object.isInstancedMesh) renderer1.renderInstances(drawStart, drawCount, object.count);
        else if (geometry1.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry1.instanceCount, geometry1._maxInstanceCount);
            renderer1.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer1.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene);
        currentRenderState.init();
        scene.traverseVisible(function(object) {
            if (object.isLight && object.layers.test(camera.layers)) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights();
        scene.traverse(function(object) {
            const material1 = object.material;
            if (material1) {
                if (Array.isArray(material1)) for(let i2 = 0; i2 < material1.length; i2++){
                    const material2 = material1[i2];
                    getProgram(material2, scene, object);
                }
                else getProgram(material1, scene, object);
            }
        });
    };
    // Animation Loop
    let onAnimationFrameCallback1 = null;
    function onAnimationFrame1(time) {
        if (onAnimationFrameCallback1) onAnimationFrameCallback1(time);
    }
    function onXRSessionStart() {
        animation2.stop();
    }
    function onXRSessionEnd() {
        animation2.start();
    }
    const animation2 = new $267b85717c4872ea$var$WebGLAnimation();
    animation2.setAnimationLoop(onAnimationFrame1);
    if (typeof window !== 'undefined') animation2.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback1 = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation2.stop() : animation2.start();
    };
    xr.addEventListener('sessionstart', onXRSessionStart);
    xr.addEventListener('sessionend', onXRSessionEnd);
    // Rendering
    this.render = function(scene, camera) {
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) {
            if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
            camera = xr.getCamera(); // use XR camera for rendering
        }
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
        currentRenderState = renderStates.get(scene, renderStateStack.length);
        currentRenderState.init();
        renderStateStack.push(currentRenderState);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, renderListStack.length);
        currentRenderList.init();
        renderListStack.push(currentRenderList);
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights();
        currentRenderState.setupLightsView(camera);
        if (_clippingEnabled === true) clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        //
        background.render(currentRenderList, scene);
        // render scene
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
            // Generate mipmap if we're using any kind of mipmap filtering
            textures.updateRenderTargetMipmap(_currentRenderTarget);
        }
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state1.buffers.depth.setTest(true);
        state1.buffers.depth.setMask(true);
        state1.buffers.color.setMask(true);
        state1.setPolygonOffset(false);
        // _gl.finish();
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        renderStateStack.pop();
        if (renderStateStack.length > 0) currentRenderState = renderStateStack[renderStateStack.length - 1];
        else currentRenderState = null;
        renderListStack.pop();
        if (renderListStack.length > 0) currentRenderList = renderListStack[renderListStack.length - 1];
        else currentRenderList = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry1 = objects.update(object);
                    const material1 = object.material;
                    if (material1.visible) currentRenderList.push(object, geometry1, material1, groupOrder, _vector3.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry1 = objects.update(object);
                    const material1 = object.material;
                    if (Array.isArray(material1)) {
                        const groups = geometry1.groups;
                        for(let i2 = 0, l = groups.length; i2 < l; i2++){
                            const group = groups[i2];
                            const groupMaterial = material1[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry1, groupMaterial, groupOrder, _vector3.z, group);
                        }
                    } else if (material1.visible) currentRenderList.push(object, geometry1, material1, groupOrder, _vector3.z, null);
                }
            }
        }
        const children = object.children;
        for(let i2 = 0, l = children.length; i2 < l; i2++)projectObject(children[i2], camera, groupOrder, sortObjects);
    }
    function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
        if (_transmissionRenderTarget === null) {
            const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
            const renderTargetType = needsAntialias ? $267b85717c4872ea$export$2d31aa8271a06773 : $267b85717c4872ea$export$aef5a065c75d61ea;
            _transmissionRenderTarget = new renderTargetType(1024, 1024, {
                generateMipmaps: true,
                type: utils.convert($267b85717c4872ea$export$c22551bc1ee2a31d) !== null ? $267b85717c4872ea$export$c22551bc1ee2a31d : $267b85717c4872ea$export$33b8d64de134adc1,
                minFilter: $267b85717c4872ea$export$f4f4190ac785556,
                magFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
                wrapS: $267b85717c4872ea$export$73b90a84ed7db63c,
                wrapT: $267b85717c4872ea$export$73b90a84ed7db63c
            });
        }
        const currentRenderTarget = _this.getRenderTarget();
        _this.setRenderTarget(_transmissionRenderTarget);
        _this.clear();
        // Turn off the features which can affect the frag color for opaque objects pass.
        // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
        const currentToneMapping = _this.toneMapping;
        _this.toneMapping = $267b85717c4872ea$export$f1d4bd8fdcc91a4e;
        renderObjects(opaqueObjects, scene, camera);
        _this.toneMapping = currentToneMapping;
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
        _this.setRenderTarget(currentRenderTarget);
        renderObjects(transmissiveObjects, scene, camera);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i2 = 0, l = renderList.length; i2 < l; i2++){
            const renderItem = renderList[i2];
            const object = renderItem.object;
            const geometry1 = renderItem.geometry;
            const material1 = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                const cameras1 = camera.cameras;
                for(let j = 0, jl = cameras1.length; j < jl; j++){
                    const camera2 = cameras1[j];
                    if (object.layers.test(camera2.layers)) {
                        state1.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLightsView(camera2);
                        renderObject(object, scene, camera2, geometry1, material1, group);
                    }
                }
            } else renderObject(object, scene, camera, geometry1, material1, group);
        }
    }
    function renderObject(object, scene, camera, geometry1, material1, group) {
        object.onBeforeRender(_this, scene, camera, geometry1, material1, group);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material1, object);
            state1.setMaterial(material1);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else if (material1.transparent === true && material1.side === $267b85717c4872ea$export$6c33fb00521864ae) {
            material1.side = $267b85717c4872ea$export$fbde0e233a2945e1;
            material1.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry1, material1, object, group);
            material1.side = $267b85717c4872ea$export$9b320e6c690b4c3e;
            material1.needsUpdate = true;
            _this.renderBufferDirect(camera, scene, geometry1, material1, object, group);
            material1.side = $267b85717c4872ea$export$6c33fb00521864ae;
        } else _this.renderBufferDirect(camera, scene, geometry1, material1, object, group);
        object.onAfterRender(_this, scene, camera, geometry1, material1, group);
    }
    function getProgram(material1, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material1);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters5 = programCache.getParameters(material1, lights.state, shadowsArray, scene, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters5);
        let programs = materialProperties.programs;
        // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
        materialProperties.environment = material1.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = cubemaps.get(material1.envMap || materialProperties.environment);
        if (programs === undefined) {
            // new material
            material1.addEventListener('dispose', onMaterialDispose);
            programs = new Map();
            materialProperties.programs = programs;
        }
        let program = programs.get(programCacheKey);
        if (program !== undefined) // early out if program and light state is identical
        {
            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                updateCommonMaterialProperties(material1, parameters5);
                return program;
            }
        } else {
            parameters5.uniforms = programCache.getUniforms(material1);
            material1.onBuild(parameters5, _this);
            material1.onBeforeCompile(parameters5, _this);
            program = programCache.acquireProgram(parameters5, programCacheKey);
            programs.set(programCacheKey, program);
            materialProperties.uniforms = parameters5.uniforms;
        }
        const uniforms = materialProperties.uniforms;
        if (!material1.isShaderMaterial && !material1.isRawShaderMaterial || material1.clipping === true) uniforms.clippingPlanes = clipping.uniform;
        updateCommonMaterialProperties(material1, parameters5);
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material1);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        // TODO (abelnation): add area lights shadow info to uniforms
        }
        const progUniforms = program.getUniforms();
        const uniformsList = $267b85717c4872ea$var$WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.currentProgram = program;
        materialProperties.uniformsList = uniformsList;
        return program;
    }
    function updateCommonMaterialProperties(material1, parameters5) {
        const materialProperties = properties.get(material1);
        materialProperties.outputEncoding = parameters5.outputEncoding;
        materialProperties.instancing = parameters5.instancing;
        materialProperties.skinning = parameters5.skinning;
        materialProperties.numClippingPlanes = parameters5.numClippingPlanes;
        materialProperties.numIntersection = parameters5.numClipIntersection;
        materialProperties.vertexAlphas = parameters5.vertexAlphas;
    }
    function setProgram(camera, scene, material1, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material1.isMeshStandardMaterial ? scene.environment : null;
        const encoding2 = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material1.envMap || environment);
        const vertexAlphas = material1.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
        const materialProperties = properties.get(material1);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material1.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                clipping.setState(material1, camera, useCache);
            }
        }
        //
        let needsProgramChange = false;
        if (material1.version === materialProperties.__version) {
            if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) needsProgramChange = true;
            else if (materialProperties.outputEncoding !== encoding2) needsProgramChange = true;
            else if (object.isInstancedMesh && materialProperties.instancing === false) needsProgramChange = true;
            else if (!object.isInstancedMesh && materialProperties.instancing === true) needsProgramChange = true;
            else if (object.isSkinnedMesh && materialProperties.skinning === false) needsProgramChange = true;
            else if (!object.isSkinnedMesh && materialProperties.skinning === true) needsProgramChange = true;
            else if (materialProperties.envMap !== envMap) needsProgramChange = true;
            else if (material1.fog && materialProperties.fog !== fog) needsProgramChange = true;
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) needsProgramChange = true;
            else if (materialProperties.vertexAlphas !== vertexAlphas) needsProgramChange = true;
        } else {
            needsProgramChange = true;
            materialProperties.__version = material1.version;
        }
        //
        let program = materialProperties.currentProgram;
        if (needsProgramChange === true) program = getProgram(material1, scene, object);
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state1.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material1.id !== _currentMaterialId) {
            _currentMaterialId = material1.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material1.isShaderMaterial || material1.isMeshPhongMaterial || material1.isMeshToonMaterial || material1.isMeshStandardMaterial || material1.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material1.isMeshPhongMaterial || material1.isMeshToonMaterial || material1.isMeshLambertMaterial || material1.isMeshBasicMaterial || material1.isMeshStandardMaterial || material1.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material1.isMeshPhongMaterial || material1.isMeshToonMaterial || material1.isMeshLambertMaterial || material1.isMeshBasicMaterial || material1.isMeshStandardMaterial || material1.isShaderMaterial || material1.isShadowMaterial || object.isSkinnedMesh) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // otherwise textures used for skinning can take over texture units reserved for other material textures
        if (object.isSkinnedMesh) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material1.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material1, _pixelRatio, _height, _transmissionRenderTarget);
            $267b85717c4872ea$var$WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material1.isShaderMaterial && material1.uniformsNeedUpdate === true) {
            $267b85717c4872ea$var$WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material1.uniformsNeedUpdate = false;
        }
        if (material1.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        // common matrices
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material1) {
        return material1.isMeshLambertMaterial || material1.isMeshToonMaterial || material1.isMeshPhongMaterial || material1.isMeshStandardMaterial || material1.isShadowMaterial || material1.isShaderMaterial && material1.lights === true;
    }
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget1, activeCubeFace = 0, activeMipmapLevel = 0) {
        _currentRenderTarget = renderTarget1;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget1 && properties.get(renderTarget1).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget1);
        let framebuffer = null;
        let isCube = false;
        let isRenderTarget3D = false;
        if (renderTarget1) {
            const texture2 = renderTarget1.texture;
            if (texture2.isDataTexture3D || texture2.isDataTexture2DArray) isRenderTarget3D = true;
            const __webglFramebuffer = properties.get(renderTarget1).__webglFramebuffer;
            if (renderTarget1.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace];
                isCube = true;
            } else if (renderTarget1.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget1).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget1.viewport);
            _currentScissor.copy(renderTarget1.scissor);
            _currentScissorTest = renderTarget1.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        const framebufferBound = state1.bindFramebuffer(36160, framebuffer);
        if (framebufferBound && capabilities.drawBuffers) {
            let needsUpdate = false;
            if (renderTarget1) {
                if (renderTarget1.isWebGLMultipleRenderTargets) {
                    const textures1 = renderTarget1.texture;
                    if (_currentDrawBuffers.length !== textures1.length || _currentDrawBuffers[0] !== 36064) {
                        for(let i2 = 0, il = textures1.length; i2 < il; i2++)_currentDrawBuffers[i2] = 36064 + i2;
                        _currentDrawBuffers.length = textures1.length;
                        needsUpdate = true;
                    }
                } else if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
                    _currentDrawBuffers[0] = 36064;
                    _currentDrawBuffers.length = 1;
                    needsUpdate = true;
                }
            } else if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
                _currentDrawBuffers[0] = 1029;
                _currentDrawBuffers.length = 1;
                needsUpdate = true;
            }
            if (needsUpdate) {
                if (capabilities.isWebGL2) _gl.drawBuffers(_currentDrawBuffers);
                else extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
            }
        }
        state1.viewport(_currentViewport);
        state1.scissor(_currentScissor);
        state1.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget1.texture);
            _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
        } else if (isRenderTarget3D) {
            const textureProperties = properties.get(renderTarget1.texture);
            const layer = activeCubeFace || 0;
            _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
        }
    };
    this.readRenderTargetPixels = function(renderTarget1, x6, y6, width8, height8, buffer, activeCubeFaceIndex) {
        if (!(renderTarget1 && renderTarget1.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget1).__webglFramebuffer;
        if (renderTarget1.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            state1.bindFramebuffer(36160, framebuffer);
            try {
                const texture2 = renderTarget1.texture;
                const textureFormat = texture2.format;
                const textureType = texture2.type;
                if (textureFormat !== $267b85717c4872ea$export$fdd3489947276d08 && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                const halfFloatSupportedByExt = textureType === $267b85717c4872ea$export$c22551bc1ee2a31d && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));
                if (textureType !== $267b85717c4872ea$export$33b8d64de134adc1 && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === $267b85717c4872ea$export$64bd8724f3c14b98 && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && !halfFloatSupportedByExt) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(36160) === 36053) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x6 >= 0 && x6 <= renderTarget1.width - width8 && y6 >= 0 && y6 <= renderTarget1.height - height8) _gl.readPixels(x6, y6, width8, height8, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                // restore framebuffer of current render target if necessary
                const framebuffer1 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                state1.bindFramebuffer(36160, framebuffer1);
            }
        }
    };
    this.copyFramebufferToTexture = function(position1, texture2, level = 0) {
        const levelScale = Math.pow(2, -level);
        const width8 = Math.floor(texture2.image.width * levelScale);
        const height8 = Math.floor(texture2.image.height * levelScale);
        let glFormat = utils.convert(texture2.format);
        if (capabilities.isWebGL2) {
            // Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
            // Not needed in Chrome 93+
            if (glFormat === 6407) glFormat = 32849;
            if (glFormat === 6408) glFormat = 32856;
        }
        textures.setTexture2D(texture2, 0);
        _gl.copyTexImage2D(3553, level, glFormat, position1.x, position1.y, width8, height8, 0);
        state1.unbindTexture();
    };
    this.copyTextureToTexture = function(position1, srcTexture, dstTexture, level = 0) {
        const width8 = srcTexture.image.width;
        const height8 = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(3553, level, position1.x, position1.y, width8, height8, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(3553, level, position1.x, position1.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(3553, level, position1.x, position1.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
        state1.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position1, srcTexture, dstTexture, level = 0) {
        if (_this.isWebGL1Renderer) {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
            return;
        }
        const width8 = sourceBox.max.x - sourceBox.min.x + 1;
        const height8 = sourceBox.max.y - sourceBox.min.y + 1;
        const depth4 = sourceBox.max.z - sourceBox.min.z + 1;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        let glTarget;
        if (dstTexture.isDataTexture3D) {
            textures.setTexture3D(dstTexture, 0);
            glTarget = 32879;
        } else if (dstTexture.isDataTexture2DArray) {
            textures.setTexture2DArray(dstTexture, 0);
            glTarget = 35866;
        } else {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
            return;
        }
        _gl.pixelStorei(37440, dstTexture.flipY);
        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
        const unpackRowLen = _gl.getParameter(3314);
        const unpackImageHeight = _gl.getParameter(32878);
        const unpackSkipPixels = _gl.getParameter(3316);
        const unpackSkipRows = _gl.getParameter(3315);
        const unpackSkipImages = _gl.getParameter(32877);
        const image1 = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
        _gl.pixelStorei(3314, image1.width);
        _gl.pixelStorei(32878, image1.height);
        _gl.pixelStorei(3316, sourceBox.min.x);
        _gl.pixelStorei(3315, sourceBox.min.y);
        _gl.pixelStorei(32877, sourceBox.min.z);
        if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) _gl.texSubImage3D(glTarget, level, position1.x, position1.y, position1.z, width8, height8, depth4, glFormat, glType, image1.data);
        else if (srcTexture.isCompressedTexture) {
            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
            _gl.compressedTexSubImage3D(glTarget, level, position1.x, position1.y, position1.z, width8, height8, depth4, glFormat, image1.data);
        } else _gl.texSubImage3D(glTarget, level, position1.x, position1.y, position1.z, width8, height8, depth4, glFormat, glType, image1);
        _gl.pixelStorei(3314, unpackRowLen);
        _gl.pixelStorei(32878, unpackImageHeight);
        _gl.pixelStorei(3316, unpackSkipPixels);
        _gl.pixelStorei(3315, unpackSkipRows);
        _gl.pixelStorei(32877, unpackSkipImages);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
        state1.unbindTexture();
    };
    this.initTexture = function(texture2) {
        textures.setTexture2D(texture2, 0);
        state1.unbindTexture();
    };
    this.resetState = function() {
        _currentActiveCubeFace = 0;
        _currentActiveMipmapLevel = 0;
        _currentRenderTarget = null;
        state1.reset();
        bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
class $267b85717c4872ea$export$a314bf7babcebc68 extends $267b85717c4872ea$export$55c403e650ad28d0 {
}
$267b85717c4872ea$export$a314bf7babcebc68.prototype.isWebGL1Renderer = true;
class $267b85717c4872ea$export$1a5869459dddfad8 {
    constructor(color2, density = 0.00025){
        this.name = '';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(color2);
        this.density = density;
    }
    clone() {
        return new $267b85717c4872ea$export$1a5869459dddfad8(this.color, this.density);
    }
    toJSON() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
}
$267b85717c4872ea$export$1a5869459dddfad8.prototype.isFogExp2 = true;
class $267b85717c4872ea$export$2b17e0dd8f1837fc {
    constructor(color1, near2 = 1, far2 = 1000){
        this.name = '';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(color1);
        this.near = near2;
        this.far = far2;
    }
    clone() {
        return new $267b85717c4872ea$export$2b17e0dd8f1837fc(this.color, this.near, this.far);
    }
    toJSON() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
}
$267b85717c4872ea$export$2b17e0dd8f1837fc.prototype.isFog = true;
class $267b85717c4872ea$export$df6b198c079ba70b extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this.type = 'Scene';
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true; // checked by the renderer
        if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
            detail: this
        })); // eslint-disable-line no-undef
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    }
    toJSON(meta) {
        const data2 = super.toJSON(meta);
        if (this.fog !== null) data2.object.fog = this.fog.toJSON();
        return data2;
    }
}
$267b85717c4872ea$export$df6b198c079ba70b.prototype.isScene = true;
class $267b85717c4872ea$export$a310785f1020d6c0 {
    constructor(array13, stride1){
        this.array = array13;
        this.stride = stride1;
        this.count = array13 !== undefined ? array13.length / stride1 : 0;
        this.usage = $267b85717c4872ea$export$ec469a709bf33b5b;
        this.updateRange = {
            offset: 0,
            count: -1
        };
        this.version = 0;
        this.uuid = $267b85717c4872ea$var$generateUUID();
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setUsage(value) {
        this.usage = value;
        return this;
    }
    copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    }
    copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i2 = 0, l = this.stride; i2 < l; i2++)this.array[index1 + i2] = attribute.array[index2 + i2];
        return this;
    }
    set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
    }
    clone(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = $267b85717c4872ea$var$generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array14 = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array14, this.stride);
        ib.setUsage(this.usage);
        return ib;
    }
    onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
    }
    toJSON(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = $267b85717c4872ea$var$generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
}
$267b85717c4872ea$export$a310785f1020d6c0.prototype.isInterleavedBuffer = true;
const $267b85717c4872ea$var$_vector$6 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$4f3b28b17d7a2b98 {
    constructor(interleavedBuffer, itemSize11, offset1, normalized11 = false){
        this.name = '';
        this.data = interleavedBuffer;
        this.itemSize = itemSize11;
        this.offset = offset1;
        this.normalized = normalized11 === true;
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(value) {
        this.data.needsUpdate = value;
    }
    applyMatrix4(m) {
        for(let i2 = 0, l = this.data.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$6.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$6.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$6.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$6.applyMatrix4(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$6.x, $267b85717c4872ea$var$_vector$6.y, $267b85717c4872ea$var$_vector$6.z);
        }
        return this;
    }
    applyNormalMatrix(m) {
        for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$6.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$6.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$6.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$6.applyNormalMatrix(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$6.x, $267b85717c4872ea$var$_vector$6.y, $267b85717c4872ea$var$_vector$6.z);
        }
        return this;
    }
    transformDirection(m) {
        for(let i2 = 0, l = this.count; i2 < l; i2++){
            $267b85717c4872ea$var$_vector$6.x = this.getX(i2);
            $267b85717c4872ea$var$_vector$6.y = this.getY(i2);
            $267b85717c4872ea$var$_vector$6.z = this.getZ(i2);
            $267b85717c4872ea$var$_vector$6.transformDirection(m);
            this.setXYZ(i2, $267b85717c4872ea$var$_vector$6.x, $267b85717c4872ea$var$_vector$6.y, $267b85717c4872ea$var$_vector$6.z);
        }
        return this;
    }
    setX(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
    }
    setY(index, y) {
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
    }
    setZ(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
    }
    setW(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
    }
    getX(index) {
        return this.data.array[index * this.data.stride + this.offset];
    }
    getY(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    }
    getZ(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    }
    getW(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    }
    setXY(index, x, y) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
    }
    setXYZ(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
    }
    setXYZW(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
    }
    clone(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array14 = [];
            for(let i2 = 0; i2 < this.count; i2++){
                const index = i2 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array14.push(this.data.array[index + j]);
            }
            return new $267b85717c4872ea$export$3d45483f125de856(new this.array.constructor(array14), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new $267b85717c4872ea$export$4f3b28b17d7a2b98(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    }
    toJSON(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array14 = [];
            for(let i2 = 0; i2 < this.count; i2++){
                const index = i2 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array14.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array14,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
}
$267b85717c4872ea$export$4f3b28b17d7a2b98.prototype.isInterleavedBufferAttribute = true;
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */ class $267b85717c4872ea$export$84b903c68a869d64 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters4){
        super();
        this.type = 'SpriteMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters4);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    }
}
$267b85717c4872ea$export$84b903c68a869d64.prototype.isSpriteMaterial = true;
let $267b85717c4872ea$var$_geometry;
const $267b85717c4872ea$var$_intersectPoint = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_worldScale = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_mvPosition = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_alignedPosition = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_rotatedPosition = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_viewWorldMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_vA = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vB = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_vC = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_uvA = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_uvB = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
const $267b85717c4872ea$var$_uvC = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
class $267b85717c4872ea$export$c01017fc2f0e32a2 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(material1){
        super();
        this.type = 'Sprite';
        if ($267b85717c4872ea$var$_geometry === undefined) {
            $267b85717c4872ea$var$_geometry = new $267b85717c4872ea$export$84a34b4c8ecb6751();
            const float32Array = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                0.5,
                -0.5,
                0,
                1,
                0,
                0.5,
                0.5,
                0,
                1,
                1,
                -0.5,
                0.5,
                0,
                0,
                1
            ]);
            const interleavedBuffer1 = new $267b85717c4872ea$export$a310785f1020d6c0(float32Array, 5);
            $267b85717c4872ea$var$_geometry.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]);
            $267b85717c4872ea$var$_geometry.setAttribute('position', new $267b85717c4872ea$export$4f3b28b17d7a2b98(interleavedBuffer1, 3, 0, false));
            $267b85717c4872ea$var$_geometry.setAttribute('uv', new $267b85717c4872ea$export$4f3b28b17d7a2b98(interleavedBuffer1, 2, 3, false));
        }
        this.geometry = $267b85717c4872ea$var$_geometry;
        this.material = material1 !== undefined ? material1 : new $267b85717c4872ea$export$84b903c68a869d64();
        this.center = new $267b85717c4872ea$export$95d9e1e745cc7977(0.5, 0.5);
    }
    raycast(raycaster, intersects) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        $267b85717c4872ea$var$_worldScale.setFromMatrixScale(this.matrixWorld);
        $267b85717c4872ea$var$_viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        $267b85717c4872ea$var$_mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) $267b85717c4872ea$var$_worldScale.multiplyScalar(-$267b85717c4872ea$var$_mvPosition.z);
        const rotation1 = this.material.rotation;
        let sin, cos;
        if (rotation1 !== 0) {
            cos = Math.cos(rotation1);
            sin = Math.sin(rotation1);
        }
        const center2 = this.center;
        $267b85717c4872ea$var$transformVertex($267b85717c4872ea$var$_vA.set(-0.5, -0.5, 0), $267b85717c4872ea$var$_mvPosition, center2, $267b85717c4872ea$var$_worldScale, sin, cos);
        $267b85717c4872ea$var$transformVertex($267b85717c4872ea$var$_vB.set(0.5, -0.5, 0), $267b85717c4872ea$var$_mvPosition, center2, $267b85717c4872ea$var$_worldScale, sin, cos);
        $267b85717c4872ea$var$transformVertex($267b85717c4872ea$var$_vC.set(0.5, 0.5, 0), $267b85717c4872ea$var$_mvPosition, center2, $267b85717c4872ea$var$_worldScale, sin, cos);
        $267b85717c4872ea$var$_uvA.set(0, 0);
        $267b85717c4872ea$var$_uvB.set(1, 0);
        $267b85717c4872ea$var$_uvC.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle($267b85717c4872ea$var$_vA, $267b85717c4872ea$var$_vB, $267b85717c4872ea$var$_vC, false, $267b85717c4872ea$var$_intersectPoint);
        if (intersect === null) {
            // check second triangle
            $267b85717c4872ea$var$transformVertex($267b85717c4872ea$var$_vB.set(-0.5, 0.5, 0), $267b85717c4872ea$var$_mvPosition, center2, $267b85717c4872ea$var$_worldScale, sin, cos);
            $267b85717c4872ea$var$_uvB.set(0, 1);
            intersect = raycaster.ray.intersectTriangle($267b85717c4872ea$var$_vA, $267b85717c4872ea$var$_vC, $267b85717c4872ea$var$_vB, false, $267b85717c4872ea$var$_intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo($267b85717c4872ea$var$_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            point: $267b85717c4872ea$var$_intersectPoint.clone(),
            uv: $267b85717c4872ea$export$cc2ce4c411239af4.getUV($267b85717c4872ea$var$_intersectPoint, $267b85717c4872ea$var$_vA, $267b85717c4872ea$var$_vB, $267b85717c4872ea$var$_vC, $267b85717c4872ea$var$_uvA, $267b85717c4872ea$var$_uvB, $267b85717c4872ea$var$_uvC, new $267b85717c4872ea$export$95d9e1e745cc7977()),
            face: null,
            object: this
        });
    }
    copy(source) {
        super.copy(source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
}
$267b85717c4872ea$export$c01017fc2f0e32a2.prototype.isSprite = true;
function $267b85717c4872ea$var$transformVertex(vertexPosition, mvPosition, center2, scale1, sin, cos) {
    // compute position in camera space
    $267b85717c4872ea$var$_alignedPosition.subVectors(vertexPosition, center2).addScalar(0.5).multiply(scale1);
    // to check if rotation is not zero
    if (sin !== undefined) {
        $267b85717c4872ea$var$_rotatedPosition.x = cos * $267b85717c4872ea$var$_alignedPosition.x - sin * $267b85717c4872ea$var$_alignedPosition.y;
        $267b85717c4872ea$var$_rotatedPosition.y = sin * $267b85717c4872ea$var$_alignedPosition.x + cos * $267b85717c4872ea$var$_alignedPosition.y;
    } else $267b85717c4872ea$var$_rotatedPosition.copy($267b85717c4872ea$var$_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += $267b85717c4872ea$var$_rotatedPosition.x;
    vertexPosition.y += $267b85717c4872ea$var$_rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4($267b85717c4872ea$var$_viewWorldMatrix);
}
const $267b85717c4872ea$var$_v1$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v2$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$1174c10a60977fe1 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this._currentLevel = 0;
        this.type = 'LOD';
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            },
            isLOD: {
                value: true
            }
        });
        this.autoUpdate = true;
    }
    copy(source) {
        super.copy(source, false);
        const levels = source.levels;
        for(let i2 = 0, l = levels.length; i2 < l; i2++){
            const level = levels[i2];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    }
    addLevel(object, distance = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++){
            if (distance < levels[l].distance) break;
        }
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    }
    getCurrentLevel() {
        return this._currentLevel;
    }
    getObjectForDistance(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i2, l;
            for(i2 = 1, l = levels.length; i2 < l; i2++){
                if (distance < levels[i2].distance) break;
            }
            return levels[i2 - 1].object;
        }
        return null;
    }
    raycast(raycaster, intersects) {
        const levels = this.levels;
        if (levels.length > 0) {
            $267b85717c4872ea$var$_v1$2.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo($267b85717c4872ea$var$_v1$2);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
    }
    update(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            $267b85717c4872ea$var$_v1$2.setFromMatrixPosition(camera.matrixWorld);
            $267b85717c4872ea$var$_v2$1.setFromMatrixPosition(this.matrixWorld);
            const distance = $267b85717c4872ea$var$_v1$2.distanceTo($267b85717c4872ea$var$_v2$1) / camera.zoom;
            levels[0].object.visible = true;
            let i2, l;
            for(i2 = 1, l = levels.length; i2 < l; i2++){
                if (distance >= levels[i2].distance) {
                    levels[i2 - 1].object.visible = false;
                    levels[i2].object.visible = true;
                } else break;
            }
            this._currentLevel = i2 - 1;
            for(; i2 < l; i2++)levels[i2].object.visible = false;
        }
    }
    toJSON(meta) {
        const data3 = super.toJSON(meta);
        if (this.autoUpdate === false) data3.object.autoUpdate = false;
        data3.object.levels = [];
        const levels = this.levels;
        for(let i2 = 0, l = levels.length; i2 < l; i2++){
            const level = levels[i2];
            data3.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data3;
    }
}
const $267b85717c4872ea$var$_basePosition = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_skinIndex = /*@__PURE__*/ new $267b85717c4872ea$export$14dfcb76afe97063();
const $267b85717c4872ea$var$_skinWeight = /*@__PURE__*/ new $267b85717c4872ea$export$14dfcb76afe97063();
const $267b85717c4872ea$var$_vector$5 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_matrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
class $267b85717c4872ea$export$5d42c2f029f93672 extends $267b85717c4872ea$export$4cdb671a7054bbf9 {
    constructor(geometry1, material2){
        super(geometry1, material2);
        this.type = 'SkinnedMesh';
        this.bindMode = 'attached';
        this.bindMatrix = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.bindMatrixInverse = new $267b85717c4872ea$export$960b1460cb9cd6c9();
    }
    copy(source) {
        super.copy(source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    }
    bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const vector = new $267b85717c4872ea$export$14dfcb76afe97063();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i2 = 0, l = skinWeight.count; i2 < l; i2++){
            vector.x = skinWeight.getX(i2);
            vector.y = skinWeight.getY(i2);
            vector.z = skinWeight.getZ(i2);
            vector.w = skinWeight.getW(i2);
            const scale1 = 1 / vector.manhattanLength();
            if (scale1 !== Infinity) vector.multiplyScalar(scale1);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === 'attached') this.bindMatrixInverse.copy(this.matrixWorld).invert();
        else if (this.bindMode === 'detached') this.bindMatrixInverse.copy(this.bindMatrix).invert();
        else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
    boneTransform(index, target) {
        const skeleton = this.skeleton;
        const geometry2 = this.geometry;
        $267b85717c4872ea$var$_skinIndex.fromBufferAttribute(geometry2.attributes.skinIndex, index);
        $267b85717c4872ea$var$_skinWeight.fromBufferAttribute(geometry2.attributes.skinWeight, index);
        $267b85717c4872ea$var$_basePosition.fromBufferAttribute(geometry2.attributes.position, index).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for(let i2 = 0; i2 < 4; i2++){
            const weight = $267b85717c4872ea$var$_skinWeight.getComponent(i2);
            if (weight !== 0) {
                const boneIndex = $267b85717c4872ea$var$_skinIndex.getComponent(i2);
                $267b85717c4872ea$var$_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                target.addScaledVector($267b85717c4872ea$var$_vector$5.copy($267b85717c4872ea$var$_basePosition).applyMatrix4($267b85717c4872ea$var$_matrix), weight);
            }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
    }
}
$267b85717c4872ea$export$5d42c2f029f93672.prototype.isSkinnedMesh = true;
class $267b85717c4872ea$export$bb2c3ec0717e2c8c extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this.type = 'Bone';
    }
}
$267b85717c4872ea$export$bb2c3ec0717e2c8c.prototype.isBone = true;
class $267b85717c4872ea$export$2c21e84929b149b4 extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(data3 = null, width8 = 1, height8 = 1, format2, type2, mapping2, wrapS2, wrapT2, magFilter2 = $267b85717c4872ea$export$f8b53649f0062e3e, minFilter2 = $267b85717c4872ea$export$f8b53649f0062e3e, anisotropy2, encoding2){
        super(null, mapping2, wrapS2, wrapT2, magFilter2, minFilter2, format2, type2, anisotropy2, encoding2);
        this.image = {
            data: data3,
            width: width8,
            height: height8
        };
        this.magFilter = magFilter2;
        this.minFilter = minFilter2;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
        this.needsUpdate = true;
    }
}
$267b85717c4872ea$export$2c21e84929b149b4.prototype.isDataTexture = true;
const $267b85717c4872ea$var$_offsetMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_identityMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
class $267b85717c4872ea$export$5f835f44a1f55563 {
    constructor(bones1 = [], boneInverses = []){
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.bones = bones1.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
    }
    init() {
        const bones1 = this.bones;
        const boneInverses1 = this.boneInverses;
        this.boneMatrices = new Float32Array(bones1.length * 16);
        // calculate inverse bone matrices if necessary
        if (boneInverses1.length === 0) this.calculateInverses();
        else // handle special case
        if (bones1.length !== boneInverses1.length) {
            console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
            this.boneInverses = [];
            for(let i2 = 0, il = this.bones.length; i2 < il; i2++)this.boneInverses.push(new $267b85717c4872ea$export$960b1460cb9cd6c9());
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for(let i2 = 0, il = this.bones.length; i2 < il; i2++){
            const inverse = new $267b85717c4872ea$export$960b1460cb9cd6c9();
            if (this.bones[i2]) inverse.copy(this.bones[i2].matrixWorld).invert();
            this.boneInverses.push(inverse);
        }
    }
    pose() {
        // recover the bind-time world matrices
        for(let i2 = 0, il = this.bones.length; i2 < il; i2++){
            const bone = this.bones[i2];
            if (bone) bone.matrixWorld.copy(this.boneInverses[i2]).invert();
        }
        // compute the local matrices, positions, rotations and scales
        for(let i3 = 0, il1 = this.bones.length; i3 < il1; i3++){
            const bone = this.bones[i3];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    }
    update() {
        const bones1 = this.bones;
        const boneInverses1 = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i2 = 0, il = bones1.length; i2 < il; i2++){
            // compute the offset between the current and the original transform
            const matrix = bones1[i2] ? bones1[i2].matrixWorld : $267b85717c4872ea$var$_identityMatrix;
            $267b85717c4872ea$var$_offsetMatrix.multiplyMatrices(matrix, boneInverses1[i2]);
            $267b85717c4872ea$var$_offsetMatrix.toArray(boneMatrices, i2 * 16);
        }
        if (boneTexture !== null) boneTexture.needsUpdate = true;
    }
    clone() {
        return new $267b85717c4872ea$export$5f835f44a1f55563(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
        let size1 = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
        size1 = $267b85717c4872ea$var$ceilPowerOfTwo(size1);
        size1 = Math.max(size1, 4);
        const boneMatrices = new Float32Array(size1 * size1 * 4); // 4 floats per RGBA pixel
        boneMatrices.set(this.boneMatrices); // copy current values
        const boneTexture = new $267b85717c4872ea$export$2c21e84929b149b4(boneMatrices, size1, size1, $267b85717c4872ea$export$fdd3489947276d08, $267b85717c4872ea$export$64bd8724f3c14b98);
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        this.boneTextureSize = size1;
        return this;
    }
    getBoneByName(name) {
        for(let i2 = 0, il = this.bones.length; i2 < il; i2++){
            const bone = this.bones[i2];
            if (bone.name === name) return bone;
        }
        return undefined;
    }
    dispose() {
        if (this.boneTexture !== null) {
            this.boneTexture.dispose();
            this.boneTexture = null;
        }
    }
    fromJSON(json, bones) {
        this.uuid = json.uuid;
        for(let i2 = 0, l = json.bones.length; i2 < l; i2++){
            const uuid = json.bones[i2];
            let bone = bones[uuid];
            if (bone === undefined) {
                console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                bone = new $267b85717c4872ea$export$bb2c3ec0717e2c8c();
            }
            this.bones.push(bone);
            this.boneInverses.push(new $267b85717c4872ea$export$960b1460cb9cd6c9().fromArray(json.boneInverses[i2]));
        }
        this.init();
        return this;
    }
    toJSON() {
        const data4 = {
            metadata: {
                version: 4.5,
                type: 'Skeleton',
                generator: 'Skeleton.toJSON'
            },
            bones: [],
            boneInverses: []
        };
        data4.uuid = this.uuid;
        const bones2 = this.bones;
        const boneInverses1 = this.boneInverses;
        for(let i2 = 0, l = bones2.length; i2 < l; i2++){
            const bone = bones2[i2];
            data4.bones.push(bone.uuid);
            const boneInverse = boneInverses1[i2];
            data4.boneInverses.push(boneInverse.toArray());
        }
        return data4;
    }
}
const $267b85717c4872ea$var$_instanceLocalMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_instanceWorldMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_instanceIntersects = [];
const $267b85717c4872ea$var$_mesh = /*@__PURE__*/ new $267b85717c4872ea$export$4cdb671a7054bbf9();
class $267b85717c4872ea$export$7e23ced5e91bc59e extends $267b85717c4872ea$export$4cdb671a7054bbf9 {
    constructor(geometry2, material3, count2){
        super(geometry2, material3);
        this.instanceMatrix = new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(count2 * 16), 16);
        this.instanceColor = null;
        this.count = count2;
        this.frustumCulled = false;
    }
    copy(source) {
        super.copy(source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
    }
    getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
    }
    getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
    raycast(raycaster, intersects) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        $267b85717c4872ea$var$_mesh.geometry = this.geometry;
        $267b85717c4872ea$var$_mesh.material = this.material;
        if ($267b85717c4872ea$var$_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, $267b85717c4872ea$var$_instanceLocalMatrix);
            $267b85717c4872ea$var$_instanceWorldMatrix.multiplyMatrices(matrixWorld, $267b85717c4872ea$var$_instanceLocalMatrix);
            // the mesh represents this single instance
            $267b85717c4872ea$var$_mesh.matrixWorld = $267b85717c4872ea$var$_instanceWorldMatrix;
            $267b85717c4872ea$var$_mesh.raycast(raycaster, $267b85717c4872ea$var$_instanceIntersects);
            // process the result of raycast
            for(let i2 = 0, l = $267b85717c4872ea$var$_instanceIntersects.length; i2 < l; i2++){
                const intersect = $267b85717c4872ea$var$_instanceIntersects[i2];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects.push(intersect);
            }
            $267b85717c4872ea$var$_instanceIntersects.length = 0;
        }
    }
    setColorAt(index, color) {
        if (this.instanceColor === null) this.instanceColor = new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(this.count * 3), 3);
        color.toArray(this.instanceColor.array, index * 3);
    }
    setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    }
    updateMorphTargets() {
    }
    dispose() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
}
$267b85717c4872ea$export$7e23ced5e91bc59e.prototype.isInstancedMesh = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */ class $267b85717c4872ea$export$9dd1d6697fbc79f6 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters5){
        super();
        this.type = 'LineBasicMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.morphTargets = false;
        this.setValues(parameters5);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.morphTargets = source.morphTargets;
        return this;
    }
}
$267b85717c4872ea$export$9dd1d6697fbc79f6.prototype.isLineBasicMaterial = true;
const $267b85717c4872ea$var$_start$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_end$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_inverseMatrix$1 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_ray$1 = /*@__PURE__*/ new $267b85717c4872ea$export$c0bfd01633e732a2();
const $267b85717c4872ea$var$_sphere$1 = /*@__PURE__*/ new $267b85717c4872ea$export$48b052fa5734fd42();
class $267b85717c4872ea$export$2034040bfbe12f9 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(geometry3 = new $267b85717c4872ea$export$84a34b4c8ecb6751(), material4 = new $267b85717c4872ea$export$9dd1d6697fbc79f6()){
        super();
        this.type = 'Line';
        this.geometry = geometry3;
        this.material = material4;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    computeLineDistances() {
        const geometry4 = this.geometry;
        if (geometry4.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry4.index === null) {
                const positionAttribute = geometry4.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i2 = 1, l = positionAttribute.count; i2 < l; i2++){
                    $267b85717c4872ea$var$_start$1.fromBufferAttribute(positionAttribute, i2 - 1);
                    $267b85717c4872ea$var$_end$1.fromBufferAttribute(positionAttribute, i2);
                    lineDistances[i2] = lineDistances[i2 - 1];
                    lineDistances[i2] += $267b85717c4872ea$var$_start$1.distanceTo($267b85717c4872ea$var$_end$1);
                }
                geometry4.setAttribute('lineDistance', new $267b85717c4872ea$export$8af155dd3ccd7773(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry4.isGeometry) console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    }
    raycast(raycaster, intersects) {
        const geometry4 = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry4.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry4.boundingSphere === null) geometry4.computeBoundingSphere();
        $267b85717c4872ea$var$_sphere$1.copy(geometry4.boundingSphere);
        $267b85717c4872ea$var$_sphere$1.applyMatrix4(matrixWorld);
        $267b85717c4872ea$var$_sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere($267b85717c4872ea$var$_sphere$1) === false) return;
        //
        $267b85717c4872ea$var$_inverseMatrix$1.copy(matrixWorld).invert();
        $267b85717c4872ea$var$_ray$1.copy(raycaster.ray).applyMatrix4($267b85717c4872ea$var$_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const vEnd = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const interSegment = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const interRay = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry4.isBufferGeometry) {
            const index = geometry4.index;
            const attributes = geometry4.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for(let i2 = start, l = end - 1; i2 < l; i2 += step){
                    const a2 = index.getX(i2);
                    const b3 = index.getX(i2 + 1);
                    vStart.fromBufferAttribute(positionAttribute, a2);
                    vEnd.fromBufferAttribute(positionAttribute, b3);
                    const distSq = $267b85717c4872ea$var$_ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i2,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for(let i2 = start, l = end - 1; i2 < l; i2 += step){
                    vStart.fromBufferAttribute(positionAttribute, i2);
                    vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
                    const distSq = $267b85717c4872ea$var$_ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i2,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            }
        } else if (geometry4.isGeometry) console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    updateMorphTargets() {
        const geometry4 = this.geometry;
        if (geometry4.isBufferGeometry) {
            const morphAttributes = geometry4.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry4.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
}
$267b85717c4872ea$export$2034040bfbe12f9.prototype.isLine = true;
const $267b85717c4872ea$var$_start = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_end = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$705b5dac58c594af extends $267b85717c4872ea$export$2034040bfbe12f9 {
    constructor(geometry4, material5){
        super(geometry4, material5);
        this.type = 'LineSegments';
    }
    computeLineDistances() {
        const geometry5 = this.geometry;
        if (geometry5.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry5.index === null) {
                const positionAttribute = geometry5.attributes.position;
                const lineDistances = [];
                for(let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2){
                    $267b85717c4872ea$var$_start.fromBufferAttribute(positionAttribute, i2);
                    $267b85717c4872ea$var$_end.fromBufferAttribute(positionAttribute, i2 + 1);
                    lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
                    lineDistances[i2 + 1] = lineDistances[i2] + $267b85717c4872ea$var$_start.distanceTo($267b85717c4872ea$var$_end);
                }
                geometry5.setAttribute('lineDistance', new $267b85717c4872ea$export$8af155dd3ccd7773(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry5.isGeometry) console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        return this;
    }
}
$267b85717c4872ea$export$705b5dac58c594af.prototype.isLineSegments = true;
class $267b85717c4872ea$export$46bbc9ce4fba3102 extends $267b85717c4872ea$export$2034040bfbe12f9 {
    constructor(geometry5, material6){
        super(geometry5, material6);
        this.type = 'LineLoop';
    }
}
$267b85717c4872ea$export$46bbc9ce4fba3102.prototype.isLineLoop = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */ class $267b85717c4872ea$export$5e855264a077e9f extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters6){
        super();
        this.type = 'PointsMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.setValues(parameters6);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
    }
}
$267b85717c4872ea$export$5e855264a077e9f.prototype.isPointsMaterial = true;
const $267b85717c4872ea$var$_inverseMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_ray = /*@__PURE__*/ new $267b85717c4872ea$export$c0bfd01633e732a2();
const $267b85717c4872ea$var$_sphere = /*@__PURE__*/ new $267b85717c4872ea$export$48b052fa5734fd42();
const $267b85717c4872ea$var$_position$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$fd24d21d3cd7fd59 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(geometry6 = new $267b85717c4872ea$export$84a34b4c8ecb6751(), material7 = new $267b85717c4872ea$export$5e855264a077e9f()){
        super();
        this.type = 'Points';
        this.geometry = geometry6;
        this.material = material7;
        this.updateMorphTargets();
    }
    copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    }
    raycast(raycaster, intersects) {
        const geometry7 = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry7.drawRange;
        // Checking boundingSphere distance to ray
        if (geometry7.boundingSphere === null) geometry7.computeBoundingSphere();
        $267b85717c4872ea$var$_sphere.copy(geometry7.boundingSphere);
        $267b85717c4872ea$var$_sphere.applyMatrix4(matrixWorld);
        $267b85717c4872ea$var$_sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere($267b85717c4872ea$var$_sphere) === false) return;
        //
        $267b85717c4872ea$var$_inverseMatrix.copy(matrixWorld).invert();
        $267b85717c4872ea$var$_ray.copy(raycaster.ray).applyMatrix4($267b85717c4872ea$var$_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry7.isBufferGeometry) {
            const index = geometry7.index;
            const attributes = geometry7.attributes;
            const positionAttribute = attributes.position;
            if (index !== null) {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(index.count, drawRange.start + drawRange.count);
                for(let i2 = start, il = end; i2 < il; i2++){
                    const a2 = index.getX(i2);
                    $267b85717c4872ea$var$_position$2.fromBufferAttribute(positionAttribute, a2);
                    $267b85717c4872ea$var$testPoint($267b85717c4872ea$var$_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else {
                const start = Math.max(0, drawRange.start);
                const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
                for(let i2 = start, l = end; i2 < l; i2++){
                    $267b85717c4872ea$var$_position$2.fromBufferAttribute(positionAttribute, i2);
                    $267b85717c4872ea$var$testPoint($267b85717c4872ea$var$_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            }
        } else console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    }
    updateMorphTargets() {
        const geometry7 = this.geometry;
        if (geometry7.isBufferGeometry) {
            const morphAttributes = geometry7.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry7.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
}
$267b85717c4872ea$export$fd24d21d3cd7fd59.prototype.isPoints = true;
function $267b85717c4872ea$var$testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = $267b85717c4872ea$var$_ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        $267b85717c4872ea$var$_ray.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
class $267b85717c4872ea$export$4574d422822ac7fa extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(video, mapping3, wrapS3, wrapT3, magFilter3, minFilter3, format3, type3, anisotropy3){
        super(video, mapping3, wrapS3, wrapT3, magFilter3, minFilter3, format3, type3, anisotropy3);
        this.format = format3 !== undefined ? format3 : $267b85717c4872ea$export$cb1f224ebfa17eab;
        this.minFilter = minFilter3 !== undefined ? minFilter3 : $267b85717c4872ea$export$d8f3ba475551f5c1;
        this.magFilter = magFilter3 !== undefined ? magFilter3 : $267b85717c4872ea$export$d8f3ba475551f5c1;
        this.generateMipmaps = false;
        const scope2 = this;
        function updateVideo() {
            scope2.needsUpdate = true;
            video.requestVideoFrameCallback(updateVideo);
        }
        if ('requestVideoFrameCallback' in video) video.requestVideoFrameCallback(updateVideo);
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const video1 = this.image;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in video1;
        if (hasVideoFrameCallback === false && video1.readyState >= video1.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
}
$267b85717c4872ea$export$4574d422822ac7fa.prototype.isVideoTexture = true;
class $267b85717c4872ea$export$be0b28729ca1f6c0 extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(mipmaps, width9, height9, format4, type4, mapping4, wrapS4, wrapT4, magFilter4, minFilter4, anisotropy4, encoding3){
        super(null, mapping4, wrapS4, wrapT4, magFilter4, minFilter4, format4, type4, anisotropy4, encoding3);
        this.image = {
            width: width9,
            height: height9
        };
        this.mipmaps = mipmaps;
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
        this.flipY = false;
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
        this.generateMipmaps = false;
    }
}
$267b85717c4872ea$export$be0b28729ca1f6c0.prototype.isCompressedTexture = true;
class $267b85717c4872ea$export$a319e925d2bf68ee extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(canvas, mapping5, wrapS5, wrapT5, magFilter5, minFilter5, format5, type5, anisotropy5){
        super(canvas, mapping5, wrapS5, wrapT5, magFilter5, minFilter5, format5, type5, anisotropy5);
        this.needsUpdate = true;
    }
}
$267b85717c4872ea$export$a319e925d2bf68ee.prototype.isCanvasTexture = true;
class $267b85717c4872ea$export$d8cc2f376f0181ff extends $267b85717c4872ea$export$1cad442f1a6e549f {
    constructor(width10, height10, type6, mapping6, wrapS6, wrapT6, magFilter6, minFilter6, anisotropy6, format6){
        format6 = format6 !== undefined ? format6 : $267b85717c4872ea$export$9e7c899e9114cafe;
        if (format6 !== $267b85717c4872ea$export$9e7c899e9114cafe && format6 !== $267b85717c4872ea$export$4db2359531a79852) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
        if (type6 === undefined && format6 === $267b85717c4872ea$export$9e7c899e9114cafe) type6 = $267b85717c4872ea$export$4a825e20fda0d845;
        if (type6 === undefined && format6 === $267b85717c4872ea$export$4db2359531a79852) type6 = $267b85717c4872ea$export$2773efb061bfa2af;
        super(null, mapping6, wrapS6, wrapT6, magFilter6, minFilter6, format6, type6, anisotropy6);
        this.image = {
            width: width10,
            height: height10
        };
        this.magFilter = magFilter6 !== undefined ? magFilter6 : $267b85717c4872ea$export$f8b53649f0062e3e;
        this.minFilter = minFilter6 !== undefined ? minFilter6 : $267b85717c4872ea$export$f8b53649f0062e3e;
        this.flipY = false;
        this.generateMipmaps = false;
    }
}
$267b85717c4872ea$export$d8cc2f376f0181ff.prototype.isDepthTexture = true;
class $267b85717c4872ea$export$7d8d1abfdf118042 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(radius2 = 1, segments1 = 8, thetaStart = 0, thetaLength = Math.PI * 2){
        super();
        this.type = 'CircleGeometry';
        this.parameters = {
            radius: radius2,
            segments: segments1,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        segments1 = Math.max(3, segments1);
        // buffers
        const indices2 = [];
        const vertices2 = [];
        const normals2 = [];
        const uvs2 = [];
        // helper variables
        const vertex = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const uv = new $267b85717c4872ea$export$95d9e1e745cc7977();
        // center point
        vertices2.push(0, 0, 0);
        normals2.push(0, 0, 1);
        uvs2.push(0.5, 0.5);
        for(let s1 = 0, i2 = 3; s1 <= segments1; s1++, i2 += 3){
            const segment = thetaStart + s1 / segments1 * thetaLength;
            // vertex
            vertex.x = radius2 * Math.cos(segment);
            vertex.y = radius2 * Math.sin(segment);
            vertices2.push(vertex.x, vertex.y, vertex.z);
            // normal
            normals2.push(0, 0, 1);
            // uvs
            uv.x = (vertices2[i2] / radius2 + 1) / 2;
            uv.y = (vertices2[i2 + 1] / radius2 + 1) / 2;
            uvs2.push(uv.x, uv.y);
        }
        // indices
        for(let i3 = 1; i3 <= segments1; i3++)indices2.push(i3, i3 + 1, 0);
        // build geometry
        this.setIndex(indices2);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices2, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals2, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs2, 2));
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$7d8d1abfdf118042(data.radius, data.segments, data.thetaStart, data.thetaLength);
    }
}
class $267b85717c4872ea$export$94c6884a61a1e52e extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(radiusTop = 1, radiusBottom = 1, height11 = 1, radialSegments = 8, heightSegments2 = 1, openEnded = false, thetaStart1 = 0, thetaLength1 = Math.PI * 2){
        super();
        this.type = 'CylinderGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height11,
            radialSegments: radialSegments,
            heightSegments: heightSegments2,
            openEnded: openEnded,
            thetaStart: thetaStart1,
            thetaLength: thetaLength1
        };
        const scope3 = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments2 = Math.floor(heightSegments2);
        // buffers
        const indices3 = [];
        const vertices3 = [];
        const normals3 = [];
        const uvs3 = [];
        // helper variables
        let index2 = 0;
        const indexArray = [];
        const halfHeight = height11 / 2;
        let groupStart1 = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        // build geometry
        this.setIndex(indices3);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices3, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals3, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs3, 2));
        function generateTorso() {
            const normal2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const vertex1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            let groupCount = 0;
            // this will be used to calculate the normal
            const slope = (radiusBottom - radiusTop) / height11;
            // generate vertices, normals and uvs
            for(let y6 = 0; y6 <= heightSegments2; y6++){
                const indexRow = [];
                const v = y6 / heightSegments2;
                // calculate the radius of the current row
                const radius3 = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x6 = 0; x6 <= radialSegments; x6++){
                    const u = x6 / radialSegments;
                    const theta = u * thetaLength1 + thetaStart1;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex1.x = radius3 * sinTheta;
                    vertex1.y = -v * height11 + halfHeight;
                    vertex1.z = radius3 * cosTheta;
                    vertices3.push(vertex1.x, vertex1.y, vertex1.z);
                    // normal
                    normal2.set(sinTheta, slope, cosTheta).normalize();
                    normals3.push(normal2.x, normal2.y, normal2.z);
                    // uv
                    uvs3.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index2++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for(let x6 = 0; x6 < radialSegments; x6++)for(let y7 = 0; y7 < heightSegments2; y7++){
                // we use the index array to access the correct indices
                const a2 = indexArray[y7][x6];
                const b3 = indexArray[y7 + 1][x6];
                const c2 = indexArray[y7 + 1][x6 + 1];
                const d = indexArray[y7][x6 + 1];
                // faces
                indices3.push(a2, b3, d);
                indices3.push(b3, c2, d);
                // update group counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope3.addGroup(groupStart1, groupCount, 0);
            // calculate new start value for groups
            groupStart1 += groupCount;
        }
        function generateCap(top) {
            // save the index of the first center vertex
            const centerIndexStart = index2;
            const uv1 = new $267b85717c4872ea$export$95d9e1e745cc7977();
            const vertex1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            let groupCount = 0;
            const radius3 = top === true ? radiusTop : radiusBottom;
            const sign = top === true ? 1 : -1;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for(let x6 = 1; x6 <= radialSegments; x6++){
                // vertex
                vertices3.push(0, halfHeight * sign, 0);
                // normal
                normals3.push(0, sign, 0);
                // uv
                uvs3.push(0.5, 0.5);
                // increase index
                index2++;
            }
            // save the index of the last center vertex
            const centerIndexEnd = index2;
            // now we generate the surrounding vertices, normals and uvs
            for(let x7 = 0; x7 <= radialSegments; x7++){
                const u = x7 / radialSegments;
                const theta = u * thetaLength1 + thetaStart1;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                // vertex
                vertex1.x = radius3 * sinTheta;
                vertex1.y = halfHeight * sign;
                vertex1.z = radius3 * cosTheta;
                vertices3.push(vertex1.x, vertex1.y, vertex1.z);
                // normal
                normals3.push(0, sign, 0);
                // uv
                uv1.x = cosTheta * 0.5 + 0.5;
                uv1.y = sinTheta * 0.5 * sign + 0.5;
                uvs3.push(uv1.x, uv1.y);
                // increase index
                index2++;
            }
            // generate indices
            for(let x8 = 0; x8 < radialSegments; x8++){
                const c2 = centerIndexStart + x8;
                const i4 = centerIndexEnd + x8;
                if (top === true) // face top
                indices3.push(i4, i4 + 1, c2);
                else // face bottom
                indices3.push(i4 + 1, i4, c2);
                groupCount += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope3.addGroup(groupStart1, groupCount, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart1 += groupCount;
        }
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$94c6884a61a1e52e(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class $267b85717c4872ea$export$1f850d89f6c8d5b3 extends $267b85717c4872ea$export$94c6884a61a1e52e {
    constructor(radius3 = 1, height12 = 1, radialSegments1 = 8, heightSegments3 = 1, openEnded1 = false, thetaStart2 = 0, thetaLength2 = Math.PI * 2){
        super(0, radius3, height12, radialSegments1, heightSegments3, openEnded1, thetaStart2, thetaLength2);
        this.type = 'ConeGeometry';
        this.parameters = {
            radius: radius3,
            height: height12,
            radialSegments: radialSegments1,
            heightSegments: heightSegments3,
            openEnded: openEnded1,
            thetaStart: thetaStart2,
            thetaLength: thetaLength2
        };
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$1f850d89f6c8d5b3(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
    }
}
class $267b85717c4872ea$export$1c1772a16308eaa1 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(vertices4, indices4, radius4 = 1, detail = 0){
        super();
        this.type = 'PolyhedronGeometry';
        this.parameters = {
            vertices: vertices4,
            indices: indices4,
            radius: radius4,
            detail: detail
        };
        // default buffer data
        const vertexBuffer = [];
        const uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius4);
        // finally, create the uv data
        generateUVs1();
        // build non-indexed geometry
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertexBuffer, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(vertexBuffer.slice(), 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvBuffer, 2));
        if (detail === 0) this.computeVertexNormals(); // flat normals
        else this.normalizeNormals(); // smooth normals
        // helper functions
        function subdivide(detail1) {
            const a2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const b3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const c2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            // iterate over all faces and apply a subdivison with the given detail value
            for(let i4 = 0; i4 < indices4.length; i4 += 3){
                // get the vertices of the face
                getVertexByIndex(indices4[i4 + 0], a2);
                getVertexByIndex(indices4[i4 + 1], b3);
                getVertexByIndex(indices4[i4 + 2], c2);
                // perform subdivision
                subdivideFace(a2, b3, c2, detail1);
            }
        }
        function subdivideFace(a2, b3, c2, detail1) {
            const cols = detail1 + 1;
            // we use this multidimensional array as a data structure for creating the subdivision
            const v = [];
            // construct all of the vertices for this subdivision
            for(let i4 = 0; i4 <= cols; i4++){
                v[i4] = [];
                const aj = a2.clone().lerp(c2, i4 / cols);
                const bj = b3.clone().lerp(c2, i4 / cols);
                const rows = cols - i4;
                for(let j = 0; j <= rows; j++)if (j === 0 && i4 === cols) v[i4][j] = aj;
                else v[i4][j] = aj.clone().lerp(bj, j / rows);
            }
            // construct all of the faces
            for(let i5 = 0; i5 < cols; i5++)for(let j = 0; j < 2 * (cols - i5) - 1; j++){
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    pushVertex(v[i5][k + 1]);
                    pushVertex(v[i5 + 1][k]);
                    pushVertex(v[i5][k]);
                } else {
                    pushVertex(v[i5][k + 1]);
                    pushVertex(v[i5 + 1][k + 1]);
                    pushVertex(v[i5 + 1][k]);
                }
            }
        }
        function applyRadius(radius5) {
            const vertex1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            // iterate over the entire buffer and apply the radius to each vertex
            for(let i4 = 0; i4 < vertexBuffer.length; i4 += 3){
                vertex1.x = vertexBuffer[i4 + 0];
                vertex1.y = vertexBuffer[i4 + 1];
                vertex1.z = vertexBuffer[i4 + 2];
                vertex1.normalize().multiplyScalar(radius5);
                vertexBuffer[i4 + 0] = vertex1.x;
                vertexBuffer[i4 + 1] = vertex1.y;
                vertexBuffer[i4 + 2] = vertex1.z;
            }
        }
        function generateUVs1() {
            const vertex1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            for(let i4 = 0; i4 < vertexBuffer.length; i4 += 3){
                vertex1.x = vertexBuffer[i4 + 0];
                vertex1.y = vertexBuffer[i4 + 1];
                vertex1.z = vertexBuffer[i4 + 2];
                const u = azimuth(vertex1) / 2 / Math.PI + 0.5;
                const v = inclination(vertex1) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for(let i4 = 0; i4 < uvBuffer.length; i4 += 6){
                // uv data of a single face
                const x0 = uvBuffer[i4 + 0];
                const x11 = uvBuffer[i4 + 2];
                const x21 = uvBuffer[i4 + 4];
                const max2 = Math.max(x0, x11, x21);
                const min2 = Math.min(x0, x11, x21);
                // 0.9 is somewhat arbitrary
                if (max2 > 0.9 && min2 < 0.1) {
                    if (x0 < 0.2) uvBuffer[i4 + 0] += 1;
                    if (x11 < 0.2) uvBuffer[i4 + 2] += 1;
                    if (x21 < 0.2) uvBuffer[i4 + 4] += 1;
                }
            }
        }
        function pushVertex(vertex1) {
            vertexBuffer.push(vertex1.x, vertex1.y, vertex1.z);
        }
        function getVertexByIndex(index1, vertex1) {
            const stride1 = index1 * 3;
            vertex1.x = vertices4[stride1 + 0];
            vertex1.y = vertices4[stride1 + 1];
            vertex1.z = vertices4[stride1 + 2];
        }
        function correctUVs() {
            const a2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const b3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const c2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const centroid = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const uvA = new $267b85717c4872ea$export$95d9e1e745cc7977();
            const uvB = new $267b85717c4872ea$export$95d9e1e745cc7977();
            const uvC = new $267b85717c4872ea$export$95d9e1e745cc7977();
            for(let i4 = 0, j = 0; i4 < vertexBuffer.length; i4 += 9, j += 6){
                a2.set(vertexBuffer[i4 + 0], vertexBuffer[i4 + 1], vertexBuffer[i4 + 2]);
                b3.set(vertexBuffer[i4 + 3], vertexBuffer[i4 + 4], vertexBuffer[i4 + 5]);
                c2.set(vertexBuffer[i4 + 6], vertexBuffer[i4 + 7], vertexBuffer[i4 + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a2).add(b3).add(c2).divideScalar(3);
                const azi = azimuth(centroid);
                correctUV(uvA, j + 0, a2, azi);
                correctUV(uvB, j + 2, b3, azi);
                correctUV(uvC, j + 4, c2, azi);
            }
        }
        function correctUV(uv1, stride1, vector, azimuth) {
            if (azimuth < 0 && uv1.x === 1) uvBuffer[stride1] = uv1.x - 1;
            if (vector.x === 0 && vector.z === 0) uvBuffer[stride1] = azimuth / 2 / Math.PI + 0.5;
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$1c1772a16308eaa1(data.vertices, data.indices, data.radius, data.details);
    }
}
class $267b85717c4872ea$export$b268e5ba415841ce extends $267b85717c4872ea$export$1c1772a16308eaa1 {
    constructor(radius5 = 1, detail1 = 0){
        const t1 = (1 + Math.sqrt(5)) / 2;
        const r2 = 1 / t1;
        const vertices5 = [
            // (±1, ±1, ±1)
            -1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            1,
            1,
            1,
            // (0, ±1/φ, ±φ)
            0,
            -r2,
            -t1,
            0,
            -r2,
            t1,
            0,
            r2,
            -t1,
            0,
            r2,
            t1,
            // (±1/φ, ±φ, 0)
            -r2,
            -t1,
            0,
            -r2,
            t1,
            0,
            r2,
            -t1,
            0,
            r2,
            t1,
            0,
            // (±φ, 0, ±1/φ)
            -t1,
            0,
            -r2,
            t1,
            0,
            -r2,
            -t1,
            0,
            r2,
            t1,
            0,
            r2
        ];
        const indices5 = [
            3,
            11,
            7,
            3,
            7,
            15,
            3,
            15,
            13,
            7,
            19,
            17,
            7,
            17,
            6,
            7,
            6,
            15,
            17,
            4,
            8,
            17,
            8,
            10,
            17,
            10,
            6,
            8,
            0,
            16,
            8,
            16,
            2,
            8,
            2,
            10,
            0,
            12,
            1,
            0,
            1,
            18,
            0,
            18,
            16,
            6,
            10,
            2,
            6,
            2,
            13,
            6,
            13,
            15,
            2,
            16,
            18,
            2,
            18,
            3,
            2,
            3,
            13,
            18,
            1,
            9,
            18,
            9,
            11,
            18,
            11,
            3,
            4,
            14,
            12,
            4,
            12,
            0,
            4,
            0,
            8,
            11,
            9,
            5,
            11,
            5,
            19,
            11,
            19,
            7,
            19,
            5,
            14,
            19,
            14,
            4,
            19,
            4,
            17,
            1,
            12,
            14,
            1,
            14,
            5,
            1,
            5,
            9
        ];
        super(vertices5, indices5, radius5, detail1);
        this.type = 'DodecahedronGeometry';
        this.parameters = {
            radius: radius5,
            detail: detail1
        };
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$b268e5ba415841ce(data.radius, data.detail);
    }
}
const $267b85717c4872ea$var$_v0 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v1$1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_normal = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_triangle = new $267b85717c4872ea$export$cc2ce4c411239af4();
class $267b85717c4872ea$export$2042389ca5695441 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(geometry7, thresholdAngle){
        super();
        this.type = 'EdgesGeometry';
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
        thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
        if (geometry7.isGeometry === true) {
            console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        const thresholdDot = Math.cos($267b85717c4872ea$var$DEG2RAD * thresholdAngle);
        const indexAttr = geometry7.getIndex();
        const positionAttr = geometry7.getAttribute('position');
        const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        const indexArr = [
            0,
            0,
            0
        ];
        const vertKeys = [
            'a',
            'b',
            'c'
        ];
        const hashes = new Array(3);
        const edgeData = {
        };
        const vertices6 = [];
        for(let i4 = 0; i4 < indexCount; i4 += 3){
            if (indexAttr) {
                indexArr[0] = indexAttr.getX(i4);
                indexArr[1] = indexAttr.getX(i4 + 1);
                indexArr[2] = indexAttr.getX(i4 + 2);
            } else {
                indexArr[0] = i4;
                indexArr[1] = i4 + 1;
                indexArr[2] = i4 + 2;
            }
            const { a: a2 , b: b3 , c: c2  } = $267b85717c4872ea$var$_triangle;
            a2.fromBufferAttribute(positionAttr, indexArr[0]);
            b3.fromBufferAttribute(positionAttr, indexArr[1]);
            c2.fromBufferAttribute(positionAttr, indexArr[2]);
            $267b85717c4872ea$var$_triangle.getNormal($267b85717c4872ea$var$_normal);
            // create hashes for the edge from the vertices
            hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
            hashes[1] = `${Math.round(b3.x * precision)},${Math.round(b3.y * precision)},${Math.round(b3.z * precision)}`;
            hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
            // skip degenerate triangles
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) continue;
            // iterate over every edge
            for(let j = 0; j < 3; j++){
                // get the first and next vertex making up the edge
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = $267b85717c4872ea$var$_triangle[vertKeys[j]];
                const v1 = $267b85717c4872ea$var$_triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                    // if we found a sibling edge add it into the vertex array if
                    // it meets the angle threshold and delete the edge from the map.
                    if ($267b85717c4872ea$var$_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                        vertices6.push(v0.x, v0.y, v0.z);
                        vertices6.push(v1.x, v1.y, v1.z);
                    }
                    edgeData[reverseHash] = null;
                } else if (!(hash in edgeData)) // if we've already got an edge here then skip adding a new one
                edgeData[hash] = {
                    index0: indexArr[j],
                    index1: indexArr[jNext],
                    normal: $267b85717c4872ea$var$_normal.clone()
                };
            }
        }
        // iterate over all remaining, unmatched edges and add them to the vertex array
        for(const key in edgeData)if (edgeData[key]) {
            const { index0: index0 , index1: index1  } = edgeData[key];
            $267b85717c4872ea$var$_v0.fromBufferAttribute(positionAttr, index0);
            $267b85717c4872ea$var$_v1$1.fromBufferAttribute(positionAttr, index1);
            vertices6.push($267b85717c4872ea$var$_v0.x, $267b85717c4872ea$var$_v0.y, $267b85717c4872ea$var$_v0.z);
            vertices6.push($267b85717c4872ea$var$_v1$1.x, $267b85717c4872ea$var$_v1$1.y, $267b85717c4872ea$var$_v1$1.z);
        }
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices6, 3));
    }
}
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ class $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(){
        this.type = 'Curve';
        this.arcLengthDivisions = 200;
    }
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    }
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt(u, optionalTarget) {
        const t1 = this.getUtoTmapping(u);
        return this.getPoint(t1, optionalTarget);
    }
    // Get sequence of points using getPoint( t )
    getPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPoint(d / divisions));
        return points;
    }
    // Get sequence of points using getPointAt( u )
    getSpacedPoints(divisions = 5) {
        const points = [];
        for(let d = 0; d <= divisions; d++)points.push(this.getPointAt(d / divisions));
        return points;
    }
    // Get total curve arc length
    getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    }
    // Get list of cumulative segment lengths
    getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p = 1; p <= divisions; p++){
            current = this.getPoint(p / divisions);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    }
    updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
    }
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping(u, distance) {
        const arcLengths = this.getLengths();
        let i5 = 0;
        const il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i5 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i5] - targetArcLength;
            if (comparison < 0) low = i5 + 1;
            else if (comparison > 0) high = i5 - 1;
            else {
                high = i5;
                break;
            // DONE
            }
        }
        i5 = high;
        if (arcLengths[i5] === targetArcLength) return i5 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i5];
        const lengthAfter = arcLengths[i5 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t1 = (i5 + segmentFraction) / (il - 1);
        return t1;
    }
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent(t, optionalTarget) {
        const delta = 0.0001;
        let t11 = t - delta;
        let t2 = t + delta;
        // Capping in case of danger
        if (t11 < 0) t11 = 0;
        if (t2 > 1) t2 = 1;
        const pt1 = this.getPoint(t11);
        const pt2 = this.getPoint(t2);
        const tangent = optionalTarget || (pt1.isVector2 ? new $267b85717c4872ea$export$95d9e1e745cc7977() : new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    }
    getTangentAt(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getTangent(t2, optionalTarget);
    }
    computeFrenetFrames(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const tangents = [];
        const normals4 = [];
        const binormals = [];
        const vec = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const mat = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        // compute the tangent vectors for each segment on the curve
        for(let i5 = 0; i5 <= segments; i5++){
            const u = i5 / segments;
            tangents[i5] = this.getTangentAt(u, new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2());
            tangents[i5].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals4[0] = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        binormals[0] = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        let min2 = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min2) {
            min2 = tx;
            normal2.set(1, 0, 0);
        }
        if (ty <= min2) {
            min2 = ty;
            normal2.set(0, 1, 0);
        }
        if (tz <= min2) normal2.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal2).normalize();
        normals4[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals4[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i6 = 1; i6 <= segments; i6++){
            normals4[i6] = normals4[i6 - 1].clone();
            binormals[i6] = binormals[i6 - 1].clone();
            vec.crossVectors(tangents[i6 - 1], tangents[i6]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta = Math.acos($267b85717c4872ea$var$clamp(tangents[i6 - 1].dot(tangents[i6]), -1, 1)); // clamp for floating pt errors
                normals4[i6].applyMatrix4(mat.makeRotationAxis(vec, theta));
            }
            binormals[i6].crossVectors(tangents[i6], normals4[i6]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed === true) {
            let theta = Math.acos($267b85717c4872ea$var$clamp(normals4[0].dot(normals4[segments]), -1, 1));
            theta /= segments;
            if (tangents[0].dot(vec.crossVectors(normals4[0], normals4[segments])) > 0) theta = -theta;
            for(let i7 = 1; i7 <= segments; i7++){
                // twist a little...
                normals4[i7].applyMatrix4(mat.makeRotationAxis(tangents[i7], theta * i7));
                binormals[i7].crossVectors(tangents[i7], normals4[i7]);
            }
        }
        return {
            tangents: tangents,
            normals: normals4,
            binormals: binormals
        };
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    }
    toJSON() {
        const data4 = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data4.arcLengthDivisions = this.arcLengthDivisions;
        data4.type = this.type;
        return data4;
    }
    fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
}
class $267b85717c4872ea$export$fd6fa092b321e4ba extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(aX2 = 0, aY2 = 0, xRadius1 = 1, yRadius1 = 1, aStartAngle2 = 0, aEndAngle2 = Math.PI * 2, aClockwise2 = false, aRotation1 = 0){
        super();
        this.type = 'EllipseCurve';
        this.aX = aX2;
        this.aY = aY2;
        this.xRadius = xRadius1;
        this.yRadius = yRadius1;
        this.aStartAngle = aStartAngle2;
        this.aEndAngle = aEndAngle2;
        this.aClockwise = aClockwise2;
        this.aRotation = aRotation1;
    }
    getPoint(t, optionalTarget) {
        const point = optionalTarget || new $267b85717c4872ea$export$95d9e1e745cc7977();
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        // ensures that deltaAngle is 0 .. 2 PI
        while(deltaAngle < 0)deltaAngle += twoPi;
        while(deltaAngle > twoPi)deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
            if (samePoints) deltaAngle = 0;
            else deltaAngle = twoPi;
        }
        if (this.aClockwise === true && !samePoints) {
            if (deltaAngle === twoPi) deltaAngle = -twoPi;
            else deltaAngle = deltaAngle - twoPi;
        }
        const angle = this.aStartAngle + t * deltaAngle;
        let x6 = this.aX + this.xRadius * Math.cos(angle);
        let y6 = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
            const cos = Math.cos(this.aRotation);
            const sin = Math.sin(this.aRotation);
            const tx = x6 - this.aX;
            const ty = y6 - this.aY;
            // Rotate the point about the center of the ellipse.
            x6 = tx * cos - ty * sin + this.aX;
            y6 = tx * sin + ty * cos + this.aY;
        }
        return point.set(x6, y6);
    }
    copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.aX = this.aX;
        data4.aY = this.aY;
        data4.xRadius = this.xRadius;
        data4.yRadius = this.yRadius;
        data4.aStartAngle = this.aStartAngle;
        data4.aEndAngle = this.aEndAngle;
        data4.aClockwise = this.aClockwise;
        data4.aRotation = this.aRotation;
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
    }
}
$267b85717c4872ea$export$fd6fa092b321e4ba.prototype.isEllipseCurve = true;
class $267b85717c4872ea$export$cabffd493f1aeac4 extends $267b85717c4872ea$export$fd6fa092b321e4ba {
    constructor(aX1, aY1, aRadius1, aStartAngle1, aEndAngle1, aClockwise1){
        super(aX1, aY1, aRadius1, aRadius1, aStartAngle1, aEndAngle1, aClockwise1);
        this.type = 'ArcCurve';
    }
}
$267b85717c4872ea$export$cabffd493f1aeac4.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/ function $267b85717c4872ea$var$CubicPoly() {
    let c0 = 0, c11 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */ function init(x0, x11, t0, t11) {
        c0 = x0;
        c11 = t0;
        c2 = -3 * x0 + 3 * x11 - 2 * t0 - t11;
        c3 = 2 * x0 - 2 * x11 + t0 + t11;
    }
    return {
        initCatmullRom: function(x0, x11, x21, x31, tension) {
            init(x11, x21, tension * (x21 - x0), tension * (x31 - x11));
        },
        initNonuniformCatmullRom: function(x0, x11, x21, x31, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t11 = (x11 - x0) / dt0 - (x21 - x0) / (dt0 + dt1) + (x21 - x11) / dt1;
            let t2 = (x21 - x11) / dt1 - (x31 - x11) / (dt1 + dt2) + (x31 - x21) / dt2;
            // rescale tangents for parametrization in [0,1]
            t11 *= dt1;
            t2 *= dt1;
            init(x11, x21, t11, t2);
        },
        calc: function(t2) {
            const t21 = t2 * t2;
            const t3 = t21 * t2;
            return c0 + c11 * t2 + c2 * t21 + c3 * t3;
        }
    };
}
//
const $267b85717c4872ea$var$tmp = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$px = new $267b85717c4872ea$var$CubicPoly(), $267b85717c4872ea$var$py = new $267b85717c4872ea$var$CubicPoly(), $267b85717c4872ea$var$pz = new $267b85717c4872ea$var$CubicPoly();
class $267b85717c4872ea$export$b61f20e3a81bf432 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(points4 = [], closed = false, curveType = 'centripetal', tension = 0.5){
        super();
        this.type = 'CatmullRomCurve3';
        this.points = points4;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()) {
        const point = optionalTarget;
        const points1 = this.points;
        const l = points1.length;
        const p = (l - (this.closed ? 0 : 1)) * t;
        let intPoint = Math.floor(p);
        let weight = p - intPoint;
        if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        else if (weight === 0 && intPoint === l - 1) {
            intPoint = l - 2;
            weight = 1;
        }
        let p02, p32; // 4 points (p1 & p2 defined below)
        if (this.closed || intPoint > 0) p02 = points1[(intPoint - 1) % l];
        else {
            // extrapolate first point
            $267b85717c4872ea$var$tmp.subVectors(points1[0], points1[1]).add(points1[0]);
            p02 = $267b85717c4872ea$var$tmp;
        }
        const p12 = points1[intPoint % l];
        const p22 = points1[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) p32 = points1[(intPoint + 2) % l];
        else {
            // extrapolate last point
            $267b85717c4872ea$var$tmp.subVectors(points1[l - 1], points1[l - 2]).add(points1[l - 1]);
            p32 = $267b85717c4872ea$var$tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
            // init Centripetal / Chordal Catmull-Rom
            const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            let dt0 = Math.pow(p02.distanceToSquared(p12), pow);
            let dt1 = Math.pow(p12.distanceToSquared(p22), pow);
            let dt2 = Math.pow(p22.distanceToSquared(p32), pow);
            // safety check for repeated points
            if (dt1 < 0.0001) dt1 = 1;
            if (dt0 < 0.0001) dt0 = dt1;
            if (dt2 < 0.0001) dt2 = dt1;
            $267b85717c4872ea$var$px.initNonuniformCatmullRom(p02.x, p12.x, p22.x, p32.x, dt0, dt1, dt2);
            $267b85717c4872ea$var$py.initNonuniformCatmullRom(p02.y, p12.y, p22.y, p32.y, dt0, dt1, dt2);
            $267b85717c4872ea$var$pz.initNonuniformCatmullRom(p02.z, p12.z, p22.z, p32.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
            $267b85717c4872ea$var$px.initCatmullRom(p02.x, p12.x, p22.x, p32.x, this.tension);
            $267b85717c4872ea$var$py.initCatmullRom(p02.y, p12.y, p22.y, p32.y, this.tension);
            $267b85717c4872ea$var$pz.initCatmullRom(p02.z, p12.z, p22.z, p32.z, this.tension);
        }
        point.set($267b85717c4872ea$var$px.calc(weight), $267b85717c4872ea$var$py.calc(weight), $267b85717c4872ea$var$pz.calc(weight));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i5 = 0, l = source.points.length; i5 < l; i5++){
            const point = source.points[i5];
            this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.points = [];
        for(let i5 = 0, l = this.points.length; i5 < l; i5++){
            const point = this.points[i5];
            data4.points.push(point.toArray());
        }
        data4.closed = this.closed;
        data4.curveType = this.curveType;
        data4.tension = this.tension;
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i5 = 0, l = json.points.length; i5 < l; i5++){
            const point = json.points[i5];
            this.points.push(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
    }
}
$267b85717c4872ea$export$b61f20e3a81bf432.prototype.isCatmullRomCurve3 = true;
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */ function $267b85717c4872ea$var$CatmullRom(t2, p02, p12, p22, p32) {
    const v0 = (p22 - p02) * 0.5;
    const v1 = (p32 - p12) * 0.5;
    const t21 = t2 * t2;
    const t3 = t2 * t21;
    return (2 * p12 - 2 * p22 + v0 + v1) * t3 + (-3 * p12 + 3 * p22 - 2 * v0 - v1) * t21 + v0 * t2 + p12;
}
//
function $267b85717c4872ea$var$QuadraticBezierP0(t2, p) {
    const k = 1 - t2;
    return k * k * p;
}
function $267b85717c4872ea$var$QuadraticBezierP1(t2, p) {
    return 2 * (1 - t2) * t2 * p;
}
function $267b85717c4872ea$var$QuadraticBezierP2(t2, p) {
    return t2 * t2 * p;
}
function $267b85717c4872ea$var$QuadraticBezier(t2, p02, p12, p22) {
    return $267b85717c4872ea$var$QuadraticBezierP0(t2, p02) + $267b85717c4872ea$var$QuadraticBezierP1(t2, p12) + $267b85717c4872ea$var$QuadraticBezierP2(t2, p22);
}
//
function $267b85717c4872ea$var$CubicBezierP0(t2, p) {
    const k = 1 - t2;
    return k * k * k * p;
}
function $267b85717c4872ea$var$CubicBezierP1(t2, p) {
    const k = 1 - t2;
    return 3 * k * k * t2 * p;
}
function $267b85717c4872ea$var$CubicBezierP2(t2, p) {
    return 3 * (1 - t2) * t2 * t2 * p;
}
function $267b85717c4872ea$var$CubicBezierP3(t2, p) {
    return t2 * t2 * t2 * p;
}
function $267b85717c4872ea$var$CubicBezier(t2, p02, p12, p22, p32) {
    return $267b85717c4872ea$var$CubicBezierP0(t2, p02) + $267b85717c4872ea$var$CubicBezierP1(t2, p12) + $267b85717c4872ea$var$CubicBezierP2(t2, p22) + $267b85717c4872ea$var$CubicBezierP3(t2, p32);
}
class $267b85717c4872ea$export$95a2cec5c7146264 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v0 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v1 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v2 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v3 = new $267b85717c4872ea$export$95d9e1e745cc7977()){
        super();
        this.type = 'CubicBezierCurve';
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$95d9e1e745cc7977()) {
        const point = optionalTarget;
        const v01 = this.v0, v11 = this.v1, v21 = this.v2, v31 = this.v3;
        point.set($267b85717c4872ea$var$CubicBezier(t, v01.x, v11.x, v21.x, v31.x), $267b85717c4872ea$var$CubicBezier(t, v01.y, v11.y, v21.y, v31.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v0 = this.v0.toArray();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        data4.v3 = this.v3.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
$267b85717c4872ea$export$95a2cec5c7146264.prototype.isCubicBezierCurve = true;
class $267b85717c4872ea$export$2565f522f4f1df70 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v01 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v11 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v21 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v31 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()){
        super();
        this.type = 'CubicBezierCurve3';
        this.v0 = v01;
        this.v1 = v11;
        this.v2 = v21;
        this.v3 = v31;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()) {
        const point = optionalTarget;
        const v02 = this.v0, v12 = this.v1, v22 = this.v2, v32 = this.v3;
        point.set($267b85717c4872ea$var$CubicBezier(t, v02.x, v12.x, v22.x, v32.x), $267b85717c4872ea$var$CubicBezier(t, v02.y, v12.y, v22.y, v32.y), $267b85717c4872ea$var$CubicBezier(t, v02.z, v12.z, v22.z, v32.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v0 = this.v0.toArray();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        data4.v3 = this.v3.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
    }
}
$267b85717c4872ea$export$2565f522f4f1df70.prototype.isCubicBezierCurve3 = true;
class $267b85717c4872ea$export$b37bb8298f497da0 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v12 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v22 = new $267b85717c4872ea$export$95d9e1e745cc7977()){
        super();
        this.type = 'LineCurve';
        this.v1 = v12;
        this.v2 = v22;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$95d9e1e745cc7977()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    getTangent(t, optionalTarget) {
        const tangent = optionalTarget || new $267b85717c4872ea$export$95d9e1e745cc7977();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
$267b85717c4872ea$export$b37bb8298f497da0.prototype.isLineCurve = true;
class $267b85717c4872ea$export$c75df1253e8c3c17 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v13 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v23 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()){
        super();
        this.type = 'LineCurve3';
        this.isLineCurve3 = true;
        this.v1 = v13;
        this.v2 = v23;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()) {
        const point = optionalTarget;
        if (t === 1) point.copy(this.v2);
        else {
            point.copy(this.v2).sub(this.v1);
            point.multiplyScalar(t).add(this.v1);
        }
        return point;
    }
    // Line curve is linear, so we can overwrite default getPointAt
    getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
    }
    copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
class $267b85717c4872ea$export$27134e4b5096519e extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v02 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v14 = new $267b85717c4872ea$export$95d9e1e745cc7977(), v24 = new $267b85717c4872ea$export$95d9e1e745cc7977()){
        super();
        this.type = 'QuadraticBezierCurve';
        this.v0 = v02;
        this.v1 = v14;
        this.v2 = v24;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$95d9e1e745cc7977()) {
        const point = optionalTarget;
        const v03 = this.v0, v15 = this.v1, v25 = this.v2;
        point.set($267b85717c4872ea$var$QuadraticBezier(t, v03.x, v15.x, v25.x), $267b85717c4872ea$var$QuadraticBezier(t, v03.y, v15.y, v25.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v0 = this.v0.toArray();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
$267b85717c4872ea$export$27134e4b5096519e.prototype.isQuadraticBezierCurve = true;
class $267b85717c4872ea$export$a91922fbd5df0bd5 extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(v03 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v15 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), v25 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()){
        super();
        this.type = 'QuadraticBezierCurve3';
        this.v0 = v03;
        this.v1 = v15;
        this.v2 = v25;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()) {
        const point = optionalTarget;
        const v04 = this.v0, v16 = this.v1, v26 = this.v2;
        point.set($267b85717c4872ea$var$QuadraticBezier(t, v04.x, v16.x, v26.x), $267b85717c4872ea$var$QuadraticBezier(t, v04.y, v16.y, v26.y), $267b85717c4872ea$var$QuadraticBezier(t, v04.z, v16.z, v26.z));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.v0 = this.v0.toArray();
        data4.v1 = this.v1.toArray();
        data4.v2 = this.v2.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
    }
}
$267b85717c4872ea$export$a91922fbd5df0bd5.prototype.isQuadraticBezierCurve3 = true;
class $267b85717c4872ea$export$d384af114ea096f extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(points1 = []){
        super();
        this.type = 'SplineCurve';
        this.points = points1;
    }
    getPoint(t, optionalTarget = new $267b85717c4872ea$export$95d9e1e745cc7977()) {
        const point = optionalTarget;
        const points2 = this.points;
        const p = (points2.length - 1) * t;
        const intPoint = Math.floor(p);
        const weight = p - intPoint;
        const p02 = points2[intPoint === 0 ? intPoint : intPoint - 1];
        const p12 = points2[intPoint];
        const p22 = points2[intPoint > points2.length - 2 ? points2.length - 1 : intPoint + 1];
        const p32 = points2[intPoint > points2.length - 3 ? points2.length - 1 : intPoint + 2];
        point.set($267b85717c4872ea$var$CatmullRom(weight, p02.x, p12.x, p22.x, p32.x), $267b85717c4872ea$var$CatmullRom(weight, p02.y, p12.y, p22.y, p32.y));
        return point;
    }
    copy(source) {
        super.copy(source);
        this.points = [];
        for(let i5 = 0, l = source.points.length; i5 < l; i5++){
            const point = source.points[i5];
            this.points.push(point.clone());
        }
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.points = [];
        for(let i5 = 0, l = this.points.length; i5 < l; i5++){
            const point = this.points[i5];
            data4.points.push(point.toArray());
        }
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for(let i5 = 0, l = json.points.length; i5 < l; i5++){
            const point = json.points[i5];
            this.points.push(new $267b85717c4872ea$export$95d9e1e745cc7977().fromArray(point));
        }
        return this;
    }
}
$267b85717c4872ea$export$d384af114ea096f.prototype.isSplineCurve = true;
var $267b85717c4872ea$var$Curves = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ArcCurve: $267b85717c4872ea$export$cabffd493f1aeac4,
    CatmullRomCurve3: $267b85717c4872ea$export$b61f20e3a81bf432,
    CubicBezierCurve: $267b85717c4872ea$export$95a2cec5c7146264,
    CubicBezierCurve3: $267b85717c4872ea$export$2565f522f4f1df70,
    EllipseCurve: $267b85717c4872ea$export$fd6fa092b321e4ba,
    LineCurve: $267b85717c4872ea$export$b37bb8298f497da0,
    LineCurve3: $267b85717c4872ea$export$c75df1253e8c3c17,
    QuadraticBezierCurve: $267b85717c4872ea$export$27134e4b5096519e,
    QuadraticBezierCurve3: $267b85717c4872ea$export$a91922fbd5df0bd5,
    SplineCurve: $267b85717c4872ea$export$d384af114ea096f
});
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */ const $267b85717c4872ea$var$Earcut = {
    triangulate: function(data4, holeIndices, dim = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data4.length;
        let outerNode = $267b85717c4872ea$var$linkedList(data4, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x6, y6, invSize;
        if (hasHoles) outerNode = $267b85717c4872ea$var$eliminateHoles(data4, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data4.length > 80 * dim) {
            minX = maxX = data4[0];
            minY = maxY = data4[1];
            for(let i5 = dim; i5 < outerLen; i5 += dim){
                x6 = data4[i5];
                y6 = data4[i5 + 1];
                if (x6 < minX) minX = x6;
                if (y6 < minY) minY = y6;
                if (x6 > maxX) maxX = x6;
                if (y6 > maxY) maxY = y6;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        $267b85717c4872ea$var$earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function $267b85717c4872ea$var$linkedList(data4, start, end, dim, clockwise) {
    let i5, last;
    if (clockwise === $267b85717c4872ea$var$signedArea(data4, start, end, dim) > 0) for(i5 = start; i5 < end; i5 += dim)last = $267b85717c4872ea$var$insertNode(i5, data4[i5], data4[i5 + 1], last);
    else for(i5 = end - dim; i5 >= start; i5 -= dim)last = $267b85717c4872ea$var$insertNode(i5, data4[i5], data4[i5 + 1], last);
    if (last && $267b85717c4872ea$var$equals(last, last.next)) {
        $267b85717c4872ea$var$removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function $267b85717c4872ea$var$filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p = start, again;
    do {
        again = false;
        if (!p.steiner && ($267b85717c4872ea$var$equals(p, p.next) || $267b85717c4872ea$var$area(p.prev, p, p.next) === 0)) {
            $267b85717c4872ea$var$removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
        } else p = p.next;
    }while (again || p !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function $267b85717c4872ea$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) $267b85717c4872ea$var$indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? $267b85717c4872ea$var$isEarHashed(ear, minX, minY, invSize) : $267b85717c4872ea$var$isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            $267b85717c4872ea$var$removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) $267b85717c4872ea$var$earcutLinked($267b85717c4872ea$var$filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = $267b85717c4872ea$var$cureLocalIntersections($267b85717c4872ea$var$filterPoints(ear), triangles, dim);
                $267b85717c4872ea$var$earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) $267b85717c4872ea$var$splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function $267b85717c4872ea$var$isEar(ear) {
    const a2 = ear.prev, b3 = ear, c2 = ear.next;
    if ($267b85717c4872ea$var$area(a2, b3, c2) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p = ear.next.next;
    while(p !== ear.prev){
        if ($267b85717c4872ea$var$pointInTriangle(a2.x, a2.y, b3.x, b3.y, c2.x, c2.y, p.x, p.y) && $267b85717c4872ea$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }
    return true;
}
function $267b85717c4872ea$var$isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b3 = ear, c2 = ear.next;
    if ($267b85717c4872ea$var$area(a2, b3, c2) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a2.x < b3.x ? a2.x < c2.x ? a2.x : c2.x : b3.x < c2.x ? b3.x : c2.x, minTY = a2.y < b3.y ? a2.y < c2.y ? a2.y : c2.y : b3.y < c2.y ? b3.y : c2.y, maxTX = a2.x > b3.x ? a2.x > c2.x ? a2.x : c2.x : b3.x > c2.x ? b3.x : c2.x, maxTY = a2.y > b3.y ? a2.y > c2.y ? a2.y : c2.y : b3.y > c2.y ? b3.y : c2.y;
    // z-order range for the current triangle bbox;
    const minZ = $267b85717c4872ea$var$zOrder(minTX, minTY, minX, minY, invSize), maxZ = $267b85717c4872ea$var$zOrder(maxTX, maxTY, minX, minY, invSize);
    let p = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p && p.z >= minZ && n && n.z <= maxZ){
        if (p !== ear.prev && p !== ear.next && $267b85717c4872ea$var$pointInTriangle(a2.x, a2.y, b3.x, b3.y, c2.x, c2.y, p.x, p.y) && $267b85717c4872ea$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && $267b85717c4872ea$var$pointInTriangle(a2.x, a2.y, b3.x, b3.y, c2.x, c2.y, n.x, n.y) && $267b85717c4872ea$var$area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p && p.z >= minZ){
        if (p !== ear.prev && p !== ear.next && $267b85717c4872ea$var$pointInTriangle(a2.x, a2.y, b3.x, b3.y, c2.x, c2.y, p.x, p.y) && $267b85717c4872ea$var$area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && $267b85717c4872ea$var$pointInTriangle(a2.x, a2.y, b3.x, b3.y, c2.x, c2.y, n.x, n.y) && $267b85717c4872ea$var$area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function $267b85717c4872ea$var$cureLocalIntersections(start, triangles, dim) {
    let p = start;
    do {
        const a2 = p.prev, b3 = p.next.next;
        if (!$267b85717c4872ea$var$equals(a2, b3) && $267b85717c4872ea$var$intersects(a2, p, p.next, b3) && $267b85717c4872ea$var$locallyInside(a2, b3) && $267b85717c4872ea$var$locallyInside(b3, a2)) {
            triangles.push(a2.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b3.i / dim);
            // remove two nodes involved
            $267b85717c4872ea$var$removeNode(p);
            $267b85717c4872ea$var$removeNode(p.next);
            p = start = b3;
        }
        p = p.next;
    }while (p !== start)
    return $267b85717c4872ea$var$filterPoints(p);
}
// try splitting polygon into two and triangulate them independently
function $267b85717c4872ea$var$splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a2 = start;
    do {
        let b3 = a2.next.next;
        while(b3 !== a2.prev){
            if (a2.i !== b3.i && $267b85717c4872ea$var$isValidDiagonal(a2, b3)) {
                // split the polygon in two by the diagonal
                let c2 = $267b85717c4872ea$var$splitPolygon(a2, b3);
                // filter colinear points around the cuts
                a2 = $267b85717c4872ea$var$filterPoints(a2, a2.next);
                c2 = $267b85717c4872ea$var$filterPoints(c2, c2.next);
                // run earcut on each half
                $267b85717c4872ea$var$earcutLinked(a2, triangles, dim, minX, minY, invSize);
                $267b85717c4872ea$var$earcutLinked(c2, triangles, dim, minX, minY, invSize);
                return;
            }
            b3 = b3.next;
        }
        a2 = a2.next;
    }while (a2 !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function $267b85717c4872ea$var$eliminateHoles(data4, holeIndices, outerNode, dim) {
    const queue = [];
    let i5, len, start, end, list;
    for(i5 = 0, len = holeIndices.length; i5 < len; i5++){
        start = holeIndices[i5] * dim;
        end = i5 < len - 1 ? holeIndices[i5 + 1] * dim : data4.length;
        list = $267b85717c4872ea$var$linkedList(data4, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push($267b85717c4872ea$var$getLeftmost(list));
    }
    queue.sort($267b85717c4872ea$var$compareX);
    // process holes from left to right
    for(i5 = 0; i5 < queue.length; i5++){
        $267b85717c4872ea$var$eliminateHole(queue[i5], outerNode);
        outerNode = $267b85717c4872ea$var$filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function $267b85717c4872ea$var$compareX(a2, b3) {
    return a2.x - b3.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function $267b85717c4872ea$var$eliminateHole(hole, outerNode) {
    outerNode = $267b85717c4872ea$var$findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b3 = $267b85717c4872ea$var$splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        $267b85717c4872ea$var$filterPoints(outerNode, outerNode.next);
        $267b85717c4872ea$var$filterPoints(b3, b3.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function $267b85717c4872ea$var$findHoleBridge(hole, outerNode) {
    let p = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            const x6 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x6 <= hx && x6 > qx) {
                qx = x6;
                if (x6 === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    }while (p !== outerNode)
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p = m;
    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && $267b85717c4872ea$var$pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
            if ($267b85717c4872ea$var$locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && $267b85717c4872ea$var$sectorContainsSector(m, p)))) {
                m = p;
                tanMin = tan;
            }
        }
        p = p.next;
    }while (p !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function $267b85717c4872ea$var$sectorContainsSector(m, p) {
    return $267b85717c4872ea$var$area(m.prev, m, p.prev) < 0 && $267b85717c4872ea$var$area(p.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function $267b85717c4872ea$var$indexCurve(start, minX, minY, invSize) {
    let p = start;
    do {
        if (p.z === null) p.z = $267b85717c4872ea$var$zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    }while (p !== start)
    p.prevZ.nextZ = null;
    p.prevZ = null;
    $267b85717c4872ea$var$sortLinked(p);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function $267b85717c4872ea$var$sortLinked(list) {
    let i5, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p){
            numMerges++;
            q = p;
            pSize = 0;
            for(i5 = 0; i5 < inSize; i5++){
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q){
                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function $267b85717c4872ea$var$zOrder(x6, y6, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x6 = 32767 * (x6 - minX) * invSize;
    y6 = 32767 * (y6 - minY) * invSize;
    x6 = (x6 | x6 << 8) & 16711935;
    x6 = (x6 | x6 << 4) & 252645135;
    x6 = (x6 | x6 << 2) & 858993459;
    x6 = (x6 | x6 << 1) & 1431655765;
    y6 = (y6 | y6 << 8) & 16711935;
    y6 = (y6 | y6 << 4) & 252645135;
    y6 = (y6 | y6 << 2) & 858993459;
    y6 = (y6 | y6 << 1) & 1431655765;
    return x6 | y6 << 1;
}
// find the leftmost node of a polygon ring
function $267b85717c4872ea$var$getLeftmost(start) {
    let p = start, leftmost = start;
    do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
        p = p.next;
    }while (p !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function $267b85717c4872ea$var$pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function $267b85717c4872ea$var$isValidDiagonal(a2, b3) {
    return a2.next.i !== b3.i && a2.prev.i !== b3.i && !$267b85717c4872ea$var$intersectsPolygon(a2, b3) && ($267b85717c4872ea$var$locallyInside(a2, b3) && $267b85717c4872ea$var$locallyInside(b3, a2) && $267b85717c4872ea$var$middleInside(a2, b3) && ($267b85717c4872ea$var$area(a2.prev, a2, b3.prev) || $267b85717c4872ea$var$area(a2, b3.prev, b3)) || $267b85717c4872ea$var$equals(a2, b3) && $267b85717c4872ea$var$area(a2.prev, a2, a2.next) > 0 && $267b85717c4872ea$var$area(b3.prev, b3, b3.next) > 0); // special zero-length case
}
// signed area of a triangle
function $267b85717c4872ea$var$area(p, q, r3) {
    return (q.y - p.y) * (r3.x - q.x) - (q.x - p.x) * (r3.y - q.y);
}
// check if two points are equal
function $267b85717c4872ea$var$equals(p12, p22) {
    return p12.x === p22.x && p12.y === p22.y;
}
// check if two segments intersect
function $267b85717c4872ea$var$intersects(p12, q1, p22, q2) {
    const o1 = $267b85717c4872ea$var$sign($267b85717c4872ea$var$area(p12, q1, p22));
    const o2 = $267b85717c4872ea$var$sign($267b85717c4872ea$var$area(p12, q1, q2));
    const o3 = $267b85717c4872ea$var$sign($267b85717c4872ea$var$area(p22, q2, p12));
    const o4 = $267b85717c4872ea$var$sign($267b85717c4872ea$var$area(p22, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && $267b85717c4872ea$var$onSegment(p12, p22, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && $267b85717c4872ea$var$onSegment(p12, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && $267b85717c4872ea$var$onSegment(p22, p12, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && $267b85717c4872ea$var$onSegment(p22, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function $267b85717c4872ea$var$onSegment(p, q, r3) {
    return q.x <= Math.max(p.x, r3.x) && q.x >= Math.min(p.x, r3.x) && q.y <= Math.max(p.y, r3.y) && q.y >= Math.min(p.y, r3.y);
}
function $267b85717c4872ea$var$sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function $267b85717c4872ea$var$intersectsPolygon(a2, b3) {
    let p = a2;
    do {
        if (p.i !== a2.i && p.next.i !== a2.i && p.i !== b3.i && p.next.i !== b3.i && $267b85717c4872ea$var$intersects(p, p.next, a2, b3)) return true;
        p = p.next;
    }while (p !== a2)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function $267b85717c4872ea$var$locallyInside(a2, b3) {
    return $267b85717c4872ea$var$area(a2.prev, a2, a2.next) < 0 ? $267b85717c4872ea$var$area(a2, b3, a2.next) >= 0 && $267b85717c4872ea$var$area(a2, a2.prev, b3) >= 0 : $267b85717c4872ea$var$area(a2, b3, a2.prev) < 0 || $267b85717c4872ea$var$area(a2, a2.next, b3) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function $267b85717c4872ea$var$middleInside(a2, b3) {
    let p = a2, inside = false;
    const px = (a2.x + b3.x) / 2, py = (a2.y + b3.y) / 2;
    do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
        p = p.next;
    }while (p !== a2)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function $267b85717c4872ea$var$splitPolygon(a2, b3) {
    const a21 = new $267b85717c4872ea$var$Node(a2.i, a2.x, a2.y), b21 = new $267b85717c4872ea$var$Node(b3.i, b3.x, b3.y), an = a2.next, bp = b3.prev;
    a2.next = b3;
    b3.prev = a2;
    a21.next = an;
    an.prev = a21;
    b21.next = a21;
    a21.prev = b21;
    bp.next = b21;
    b21.prev = bp;
    return b21;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function $267b85717c4872ea$var$insertNode(i5, x6, y6, last) {
    const p = new $267b85717c4872ea$var$Node(i5, x6, y6);
    if (!last) {
        p.prev = p;
        p.next = p;
    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}
function $267b85717c4872ea$var$removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function $267b85717c4872ea$var$Node(i5, x6, y6) {
    // vertex index in coordinates array
    this.i = i5;
    // vertex coordinates
    this.x = x6;
    this.y = y6;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function $267b85717c4872ea$var$signedArea(data4, start, end, dim) {
    let sum = 0;
    for(let i5 = start, j = end - dim; i5 < end; i5 += dim){
        sum += (data4[j] - data4[i5]) * (data4[i5 + 1] + data4[j + 1]);
        j = i5;
    }
    return sum;
}
class $267b85717c4872ea$export$50a45ec5a8fa659f {
    // calculate area of the contour polygon
    static area(contour) {
        const n = contour.length;
        let a2 = 0;
        for(let p = n - 1, q = 0; q < n; p = q++)a2 += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        return a2 * 0.5;
    }
    static isClockWise(pts) {
        return $267b85717c4872ea$export$50a45ec5a8fa659f.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
        const vertices7 = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        $267b85717c4872ea$var$removeDupEndPts(contour);
        $267b85717c4872ea$var$addContour(vertices7, contour);
        //
        let holeIndex = contour.length;
        holes.forEach($267b85717c4872ea$var$removeDupEndPts);
        for(let i5 = 0; i5 < holes.length; i5++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i5].length;
            $267b85717c4872ea$var$addContour(vertices7, holes[i5]);
        }
        //
        const triangles = $267b85717c4872ea$var$Earcut.triangulate(vertices7, holeIndices);
        //
        for(let i6 = 0; i6 < triangles.length; i6 += 3)faces.push(triangles.slice(i6, i6 + 3));
        return faces;
    }
}
function $267b85717c4872ea$var$removeDupEndPts(points2) {
    const l = points2.length;
    if (l > 2 && points2[l - 1].equals(points2[0])) points2.pop();
}
function $267b85717c4872ea$var$addContour(vertices7, contour) {
    for(let i5 = 0; i5 < contour.length; i5++){
        vertices7.push(contour[i5].x);
        vertices7.push(contour[i5].y);
    }
}
/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ class $267b85717c4872ea$export$7dac0f8fbb3b30ab extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(shapes1, options3){
        super();
        this.type = 'ExtrudeGeometry';
        this.parameters = {
            shapes: shapes1,
            options: options3
        };
        shapes1 = Array.isArray(shapes1) ? shapes1 : [
            shapes1
        ];
        const scope4 = this;
        const verticesArray = [];
        const uvArray = [];
        for(let i5 = 0, l = shapes1.length; i5 < l; i5++){
            const shape = shapes1[i5];
            addShape1(shape);
        }
        // build geometry
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(verticesArray, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvArray, 2));
        this.computeVertexNormals();
        // functions
        function addShape1(shape) {
            const placeholder = [];
            // options
            const curveSegments = options3.curveSegments !== undefined ? options3.curveSegments : 12;
            const steps = options3.steps !== undefined ? options3.steps : 1;
            let depth4 = options3.depth !== undefined ? options3.depth : 100;
            let bevelEnabled = options3.bevelEnabled !== undefined ? options3.bevelEnabled : true;
            let bevelThickness = options3.bevelThickness !== undefined ? options3.bevelThickness : 6;
            let bevelSize = options3.bevelSize !== undefined ? options3.bevelSize : bevelThickness - 2;
            let bevelOffset = options3.bevelOffset !== undefined ? options3.bevelOffset : 0;
            let bevelSegments = options3.bevelSegments !== undefined ? options3.bevelSegments : 3;
            const extrudePath = options3.extrudePath;
            const uvgen = options3.UVGenerator !== undefined ? options3.UVGenerator : $267b85717c4872ea$var$WorldUVGenerator;
            // deprecated options
            if (options3.amount !== undefined) {
                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                depth4 = options3.amount;
            }
            //
            let extrudePts, extrudeByPath = false;
            let splineTube, binormal, normal2, position2;
            if (extrudePath) {
                extrudePts = extrudePath.getSpacedPoints(steps);
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
                // SETUP TNB variables
                // TODO1 - have a .isClosed in spline?
                splineTube = extrudePath.computeFrenetFrames(steps, false);
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                binormal = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
                normal2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
                position2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            }
            // Safeguards if bevels are not enabled
            if (!bevelEnabled) {
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
            }
            // Variables initialization
            const shapePoints = shape.extractPoints(curveSegments);
            let vertices7 = shapePoints.shape;
            const holes = shapePoints.holes;
            const reverse = !$267b85717c4872ea$export$50a45ec5a8fa659f.isClockWise(vertices7);
            if (reverse) {
                vertices7 = vertices7.reverse();
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                for(let h = 0, hl = holes.length; h < hl; h++){
                    const ahole = holes[h];
                    if ($267b85717c4872ea$export$50a45ec5a8fa659f.isClockWise(ahole)) holes[h] = ahole.reverse();
                }
            }
            const faces = $267b85717c4872ea$export$50a45ec5a8fa659f.triangulateShape(vertices7, holes);
            /* Vertices */ const contour = vertices7; // vertices has all points but contour has only points of circumference
            for(let h = 0, hl = holes.length; h < hl; h++){
                const ahole = holes[h];
                vertices7 = vertices7.concat(ahole);
            }
            function scalePt2(pt, vec, size1) {
                if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                return vec.clone().multiplyScalar(size1).add(pt);
            }
            const vlen = vertices7.length, flen = faces.length;
            // Find directions for point movement
            function getBevelVec(inPt, inPrev, inNext) {
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
                const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
                const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
                const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
                // check for collinear edges
                const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
                if (Math.abs(collinear0) > Number.EPSILON) {
                    // not collinear
                    // length of vectors for normalizing
                    const v_prev_len = Math.sqrt(v_prev_lensq);
                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                    // shift adjacent points by unit vectors to the left
                    const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
                    const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
                    const ptNextShift_x = inNext.x - v_next_y / v_next_len;
                    const ptNextShift_y = inNext.y + v_next_x / v_next_len;
                    // scaling factor for v_prev to intersection point
                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                    // vector from inPt to intersection point
                    v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
                    v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
                    if (v_trans_lensq <= 2) return new $267b85717c4872ea$export$95d9e1e745cc7977(v_trans_x, v_trans_y);
                    else shrink_by = Math.sqrt(v_trans_lensq / 2);
                } else {
                    // handle special case of collinear edges
                    let direction_eq = false; // assumes: opposite
                    if (v_prev_x > Number.EPSILON) {
                        if (v_next_x > Number.EPSILON) direction_eq = true;
                    } else {
                        if (v_prev_x < -Number.EPSILON) {
                            if (v_next_x < -Number.EPSILON) direction_eq = true;
                        } else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) direction_eq = true;
                    }
                    if (direction_eq) {
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = -v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt(v_prev_lensq);
                    } else {
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                    }
                }
                return new $267b85717c4872ea$export$95d9e1e745cc7977(v_trans_x / shrink_by, v_trans_y / shrink_by);
            }
            const contourMovements = [];
            for(let i6 = 0, il = contour.length, j = il - 1, k = i6 + 1; i6 < il; i6++, j++, k++){
                if (j === il) j = 0;
                if (k === il) k = 0;
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
                contourMovements[i6] = getBevelVec(contour[i6], contour[j], contour[k]);
            }
            const holesMovements = [];
            let oneHoleMovements, verticesMovements = contourMovements.concat();
            for(let h1 = 0, hl1 = holes.length; h1 < hl1; h1++){
                const ahole = holes[h1];
                oneHoleMovements = [];
                for(let i7 = 0, il1 = ahole.length, j1 = il1 - 1, k1 = i7 + 1; i7 < il1; i7++, j1++, k1++){
                    if (j1 === il1) j1 = 0;
                    if (k1 === il1) k1 = 0;
                    //  (j)---(i)---(k)
                    oneHoleMovements[i7] = getBevelVec(ahole[i7], ahole[j1], ahole[k1]);
                }
                holesMovements.push(oneHoleMovements);
                verticesMovements = verticesMovements.concat(oneHoleMovements);
            }
            // Loop bevelSegments, 1 for the front, 1 for the back
            for(let b3 = 0; b3 < bevelSegments; b3++){
                //for ( b = bevelSegments; b > 0; b -- ) {
                const t2 = b3 / bevelSegments;
                const z5 = bevelThickness * Math.cos(t2 * Math.PI / 2);
                const bs = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i7 = 0, il1 = contour.length; i7 < il1; i7++){
                    const vert = scalePt2(contour[i7], contourMovements[i7], bs);
                    v(vert.x, vert.y, -z5);
                }
                // expand holes
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    oneHoleMovements = holesMovements[h2];
                    for(let i8 = 0, il2 = ahole.length; i8 < il2; i8++){
                        const vert = scalePt2(ahole[i8], oneHoleMovements[i8], bs);
                        v(vert.x, vert.y, -z5);
                    }
                }
            }
            const bs = bevelSize + bevelOffset;
            // Back facing vertices
            for(let i7 = 0; i7 < vlen; i7++){
                const vert = bevelEnabled ? scalePt2(vertices7[i7], verticesMovements[i7], bs) : vertices7[i7];
                if (!extrudeByPath) v(vert.x, vert.y, 0);
                else {
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                    normal2.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[0]).add(normal2).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add stepped vertices...
            // Including front facing vertices
            for(let s1 = 1; s1 <= steps; s1++)for(let i8 = 0; i8 < vlen; i8++){
                const vert = bevelEnabled ? scalePt2(vertices7[i8], verticesMovements[i8], bs) : vertices7[i8];
                if (!extrudeByPath) v(vert.x, vert.y, depth4 / steps * s1);
                else {
                    // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                    normal2.copy(splineTube.normals[s1]).multiplyScalar(vert.x);
                    binormal.copy(splineTube.binormals[s1]).multiplyScalar(vert.y);
                    position2.copy(extrudePts[s1]).add(normal2).add(binormal);
                    v(position2.x, position2.y, position2.z);
                }
            }
            // Add bevel segments planes
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for(let b4 = bevelSegments - 1; b4 >= 0; b4--){
                const t2 = b4 / bevelSegments;
                const z5 = bevelThickness * Math.cos(t2 * Math.PI / 2);
                const bs1 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
                // contract shape
                for(let i9 = 0, il1 = contour.length; i9 < il1; i9++){
                    const vert = scalePt2(contour[i9], contourMovements[i9], bs1);
                    v(vert.x, vert.y, depth4 + z5);
                }
                // expand holes
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    oneHoleMovements = holesMovements[h2];
                    for(let i10 = 0, il2 = ahole.length; i10 < il2; i10++){
                        const vert = scalePt2(ahole[i10], oneHoleMovements[i10], bs1);
                        if (!extrudeByPath) v(vert.x, vert.y, depth4 + z5);
                        else v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z5);
                    }
                }
            }
            /* Faces */ // Top and bottom faces
            buildLidFaces();
            // Sides faces
            buildSideFaces();
            /////  Internal functions
            function buildLidFaces() {
                const start = verticesArray.length / 3;
                if (bevelEnabled) {
                    let layer = 0; // steps + 1
                    let offset1 = vlen * layer;
                    // Bottom faces
                    for(let i9 = 0; i9 < flen; i9++){
                        const face = faces[i9];
                        f3(face[2] + offset1, face[1] + offset1, face[0] + offset1);
                    }
                    layer = steps + bevelSegments * 2;
                    offset1 = vlen * layer;
                    // Top faces
                    for(let i10 = 0; i10 < flen; i10++){
                        const face = faces[i10];
                        f3(face[0] + offset1, face[1] + offset1, face[2] + offset1);
                    }
                } else {
                    // Bottom faces
                    for(let i9 = 0; i9 < flen; i9++){
                        const face = faces[i9];
                        f3(face[2], face[1], face[0]);
                    }
                    // Top faces
                    for(let i10 = 0; i10 < flen; i10++){
                        const face = faces[i10];
                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                    }
                }
                scope4.addGroup(start, verticesArray.length / 3 - start, 0);
            }
            // Create faces for the z-sides of the shape
            function buildSideFaces() {
                const start = verticesArray.length / 3;
                let layeroffset = 0;
                sidewalls(contour, layeroffset);
                layeroffset += contour.length;
                for(let h2 = 0, hl2 = holes.length; h2 < hl2; h2++){
                    const ahole = holes[h2];
                    sidewalls(ahole, layeroffset);
                    //, true
                    layeroffset += ahole.length;
                }
                scope4.addGroup(start, verticesArray.length / 3 - start, 1);
            }
            function sidewalls(contour1, layeroffset) {
                let i9 = contour1.length;
                while((--i9) >= 0){
                    const j1 = i9;
                    let k1 = i9 - 1;
                    if (k1 < 0) k1 = contour1.length - 1;
                    //console.log('b', i,j, i-1, k,vertices.length);
                    for(let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++){
                        const slen1 = vlen * s2;
                        const slen2 = vlen * (s2 + 1);
                        const a2 = layeroffset + j1 + slen1, b5 = layeroffset + k1 + slen1, c2 = layeroffset + k1 + slen2, d = layeroffset + j1 + slen2;
                        f4(a2, b5, c2, d);
                    }
                }
            }
            function v(x6, y6, z5) {
                placeholder.push(x6);
                placeholder.push(y6);
                placeholder.push(z5);
            }
            function f3(a2, b5, c2) {
                addVertex(a2);
                addVertex(b5);
                addVertex(c2);
                const nextIndex = verticesArray.length / 3;
                const uvs4 = uvgen.generateTopUV(scope4, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs4[0]);
                addUV(uvs4[1]);
                addUV(uvs4[2]);
            }
            function f4(a2, b5, c2, d) {
                addVertex(a2);
                addVertex(b5);
                addVertex(d);
                addVertex(b5);
                addVertex(c2);
                addVertex(d);
                const nextIndex = verticesArray.length / 3;
                const uvs4 = uvgen.generateSideWallUV(scope4, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                addUV(uvs4[0]);
                addUV(uvs4[1]);
                addUV(uvs4[3]);
                addUV(uvs4[1]);
                addUV(uvs4[2]);
                addUV(uvs4[3]);
            }
            function addVertex(index1) {
                verticesArray.push(placeholder[index1 * 3 + 0]);
                verticesArray.push(placeholder[index1 * 3 + 1]);
                verticesArray.push(placeholder[index1 * 3 + 2]);
            }
            function addUV(vector2) {
                uvArray.push(vector2.x);
                uvArray.push(vector2.y);
            }
        }
    }
    toJSON() {
        const data4 = super.toJSON();
        const shapes1 = this.parameters.shapes;
        const options4 = this.parameters.options;
        return $267b85717c4872ea$var$toJSON$1(shapes1, options4, data4);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j = 0, jl = data.shapes.length; j < jl; j++){
            const shape = shapes[data.shapes[j]];
            geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== undefined) data.options.extrudePath = new $267b85717c4872ea$var$Curves[extrudePath.type]().fromJSON(extrudePath);
        return new $267b85717c4872ea$export$7dac0f8fbb3b30ab(geometryShapes, data.options);
    }
}
const $267b85717c4872ea$var$WorldUVGenerator = {
    generateTopUV: function(geometry8, vertices7, indexA, indexB, indexC) {
        const a_x = vertices7[indexA * 3];
        const a_y = vertices7[indexA * 3 + 1];
        const b_x = vertices7[indexB * 3];
        const b_y = vertices7[indexB * 3 + 1];
        const c_x = vertices7[indexC * 3];
        const c_y = vertices7[indexC * 3 + 1];
        return [
            new $267b85717c4872ea$export$95d9e1e745cc7977(a_x, a_y),
            new $267b85717c4872ea$export$95d9e1e745cc7977(b_x, b_y),
            new $267b85717c4872ea$export$95d9e1e745cc7977(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry8, vertices7, indexA, indexB, indexC, indexD) {
        const a_x = vertices7[indexA * 3];
        const a_y = vertices7[indexA * 3 + 1];
        const a_z = vertices7[indexA * 3 + 2];
        const b_x = vertices7[indexB * 3];
        const b_y = vertices7[indexB * 3 + 1];
        const b_z = vertices7[indexB * 3 + 2];
        const c_x = vertices7[indexC * 3];
        const c_y = vertices7[indexC * 3 + 1];
        const c_z = vertices7[indexC * 3 + 2];
        const d_x = vertices7[indexD * 3];
        const d_y = vertices7[indexD * 3 + 1];
        const d_z = vertices7[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) return [
            new $267b85717c4872ea$export$95d9e1e745cc7977(a_x, 1 - a_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(b_x, 1 - b_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(c_x, 1 - c_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(d_x, 1 - d_z)
        ];
        else return [
            new $267b85717c4872ea$export$95d9e1e745cc7977(a_y, 1 - a_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(b_y, 1 - b_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(c_y, 1 - c_z),
            new $267b85717c4872ea$export$95d9e1e745cc7977(d_y, 1 - d_z)
        ];
    }
};
function $267b85717c4872ea$var$toJSON$1(shapes2, options4, data4) {
    data4.shapes = [];
    if (Array.isArray(shapes2)) for(let i6 = 0, l1 = shapes2.length; i6 < l1; i6++){
        const shape = shapes2[i6];
        data4.shapes.push(shape.uuid);
    }
    else data4.shapes.push(shapes2.uuid);
    if (options4.extrudePath !== undefined) data4.options.extrudePath = options4.extrudePath.toJSON();
    return data4;
}
class $267b85717c4872ea$export$362a3ddc4e904cfe extends $267b85717c4872ea$export$1c1772a16308eaa1 {
    constructor(radius6 = 1, detail2 = 0){
        const t2 = (1 + Math.sqrt(5)) / 2;
        const vertices7 = [
            -1,
            t2,
            0,
            1,
            t2,
            0,
            -1,
            -t2,
            0,
            1,
            -t2,
            0,
            0,
            -1,
            t2,
            0,
            1,
            t2,
            0,
            -1,
            -t2,
            0,
            1,
            -t2,
            t2,
            0,
            -1,
            t2,
            0,
            1,
            -t2,
            0,
            -1,
            -t2,
            0,
            1
        ];
        const indices6 = [
            0,
            11,
            5,
            0,
            5,
            1,
            0,
            1,
            7,
            0,
            7,
            10,
            0,
            10,
            11,
            1,
            5,
            9,
            5,
            11,
            4,
            11,
            10,
            2,
            10,
            7,
            6,
            7,
            1,
            8,
            3,
            9,
            4,
            3,
            4,
            2,
            3,
            2,
            6,
            3,
            6,
            8,
            3,
            8,
            9,
            4,
            9,
            5,
            2,
            4,
            11,
            6,
            2,
            10,
            8,
            6,
            7,
            9,
            8,
            1
        ];
        super(vertices7, indices6, radius6, detail2);
        this.type = 'IcosahedronGeometry';
        this.parameters = {
            radius: radius6,
            detail: detail2
        };
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$362a3ddc4e904cfe(data.radius, data.detail);
    }
}
class $267b85717c4872ea$export$82ccc99a183c6757 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(points2, segments2 = 12, phiStart = 0, phiLength = Math.PI * 2){
        super();
        this.type = 'LatheGeometry';
        this.parameters = {
            points: points2,
            segments: segments2,
            phiStart: phiStart,
            phiLength: phiLength
        };
        segments2 = Math.floor(segments2);
        // clamp phiLength so it's in range of [ 0, 2PI ]
        phiLength = $267b85717c4872ea$var$clamp(phiLength, 0, Math.PI * 2);
        // buffers
        const indices7 = [];
        const vertices8 = [];
        const uvs4 = [];
        // helper variables
        const inverseSegments = 1 / segments2;
        const vertex1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const uv1 = new $267b85717c4872ea$export$95d9e1e745cc7977();
        // generate vertices and uvs
        for(let i6 = 0; i6 <= segments2; i6++){
            const phi = phiStart + i6 * inverseSegments * phiLength;
            const sin = Math.sin(phi);
            const cos = Math.cos(phi);
            for(let j = 0; j <= points2.length - 1; j++){
                // vertex
                vertex1.x = points2[j].x * sin;
                vertex1.y = points2[j].y;
                vertex1.z = points2[j].x * cos;
                vertices8.push(vertex1.x, vertex1.y, vertex1.z);
                // uv
                uv1.x = i6 / segments2;
                uv1.y = j / (points2.length - 1);
                uvs4.push(uv1.x, uv1.y);
            }
        }
        // indices
        for(let i7 = 0; i7 < segments2; i7++)for(let j = 0; j < points2.length - 1; j++){
            const base = j + i7 * points2.length;
            const a2 = base;
            const b3 = base + points2.length;
            const c2 = base + points2.length + 1;
            const d = base + 1;
            // faces
            indices7.push(a2, b3, d);
            indices7.push(b3, c2, d);
        }
        // build geometry
        this.setIndex(indices7);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices8, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs4, 2));
        // generate normals
        this.computeVertexNormals();
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
        if (phiLength === Math.PI * 2) {
            const normals4 = this.attributes.normal.array;
            const n1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const n2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            const n = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            // this is the buffer offset for the last line of vertices
            const base = segments2 * points2.length * 3;
            for(let i8 = 0, j1 = 0; i8 < points2.length; i8++, j1 += 3){
                // select the normal of the vertex in the first line
                n1.x = normals4[j1 + 0];
                n1.y = normals4[j1 + 1];
                n1.z = normals4[j1 + 2];
                // select the normal of the vertex in the last line
                n2.x = normals4[base + j1 + 0];
                n2.y = normals4[base + j1 + 1];
                n2.z = normals4[base + j1 + 2];
                // average normals
                n.addVectors(n1, n2).normalize();
                // assign the new values to both normals
                normals4[j1 + 0] = normals4[base + j1 + 0] = n.x;
                normals4[j1 + 1] = normals4[base + j1 + 1] = n.y;
                normals4[j1 + 2] = normals4[base + j1 + 2] = n.z;
            }
        }
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$82ccc99a183c6757(data.points, data.segments, data.phiStart, data.phiLength);
    }
}
class $267b85717c4872ea$export$4f8ac4fd44f1e5f extends $267b85717c4872ea$export$1c1772a16308eaa1 {
    constructor(radius7 = 1, detail3 = 0){
        const vertices9 = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
        ];
        const indices8 = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
        ];
        super(vertices9, indices8, radius7, detail3);
        this.type = 'OctahedronGeometry';
        this.parameters = {
            radius: radius7,
            detail: detail3
        };
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$4f8ac4fd44f1e5f(data.radius, data.detail);
    }
}
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */ class $267b85717c4872ea$export$be4484824eed17ec extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(func, slices, stacks){
        super();
        this.type = 'ParametricGeometry';
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
        // buffers
        const indices9 = [];
        const vertices10 = [];
        const normals4 = [];
        const uvs5 = [];
        const EPS = 0.00001;
        const normal2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const p02 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), p12 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const pu = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), pv = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
        // generate vertices, normals and uvs
        const sliceCount = slices + 1;
        for(let i8 = 0; i8 <= stacks; i8++){
            const v = i8 / stacks;
            for(let j1 = 0; j1 <= slices; j1++){
                const u = j1 / slices;
                // vertex
                func(u, v, p02);
                vertices10.push(p02.x, p02.y, p02.z);
                // normal
                // approximate tangent vectors via finite differences
                if (u - EPS >= 0) {
                    func(u - EPS, v, p12);
                    pu.subVectors(p02, p12);
                } else {
                    func(u + EPS, v, p12);
                    pu.subVectors(p12, p02);
                }
                if (v - EPS >= 0) {
                    func(u, v - EPS, p12);
                    pv.subVectors(p02, p12);
                } else {
                    func(u, v + EPS, p12);
                    pv.subVectors(p12, p02);
                }
                // cross product of tangent vectors returns surface normal
                normal2.crossVectors(pu, pv).normalize();
                normals4.push(normal2.x, normal2.y, normal2.z);
                // uv
                uvs5.push(u, v);
            }
        }
        // generate indices
        for(let i9 = 0; i9 < stacks; i9++)for(let j1 = 0; j1 < slices; j1++){
            const a2 = i9 * sliceCount + j1;
            const b3 = i9 * sliceCount + j1 + 1;
            const c2 = (i9 + 1) * sliceCount + j1 + 1;
            const d = (i9 + 1) * sliceCount + j1;
            // faces one and two
            indices9.push(a2, b3, d);
            indices9.push(b3, c2, d);
        }
        // build geometry
        this.setIndex(indices9);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices10, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals4, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs5, 2));
    }
}
class $267b85717c4872ea$export$924916dda2d7dd4c extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart3 = 0, thetaLength3 = Math.PI * 2){
        super();
        this.type = 'RingGeometry';
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart3,
            thetaLength: thetaLength3
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        // buffers
        const indices10 = [];
        const vertices11 = [];
        const normals5 = [];
        const uvs6 = [];
        // some helper variables
        let radius8 = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const uv2 = new $267b85717c4872ea$export$95d9e1e745cc7977();
        // generate vertices, normals and uvs
        for(let j2 = 0; j2 <= phiSegments; j2++){
            for(let i10 = 0; i10 <= thetaSegments; i10++){
                // values are generate from the inside of the ring to the outside
                const segment = thetaStart3 + i10 / thetaSegments * thetaLength3;
                // vertex
                vertex2.x = radius8 * Math.cos(segment);
                vertex2.y = radius8 * Math.sin(segment);
                vertices11.push(vertex2.x, vertex2.y, vertex2.z);
                // normal
                normals5.push(0, 0, 1);
                // uv
                uv2.x = (vertex2.x / outerRadius + 1) / 2;
                uv2.y = (vertex2.y / outerRadius + 1) / 2;
                uvs6.push(uv2.x, uv2.y);
            }
            // increase the radius for next row of vertices
            radius8 += radiusStep;
        }
        // indices
        for(let j3 = 0; j3 < phiSegments; j3++){
            const thetaSegmentLevel = j3 * (thetaSegments + 1);
            for(let i10 = 0; i10 < thetaSegments; i10++){
                const segment = i10 + thetaSegmentLevel;
                const a2 = segment;
                const b3 = segment + thetaSegments + 1;
                const c2 = segment + thetaSegments + 2;
                const d = segment + 1;
                // faces
                indices10.push(a2, b3, d);
                indices10.push(b3, c2, d);
            }
        }
        // build geometry
        this.setIndex(indices10);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices11, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals5, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs6, 2));
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$924916dda2d7dd4c(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
    }
}
class $267b85717c4872ea$export$aacf45bade30a4eb extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(shapes2, curveSegments = 12){
        super();
        this.type = 'ShapeGeometry';
        this.parameters = {
            shapes: shapes2,
            curveSegments: curveSegments
        };
        // buffers
        const indices11 = [];
        const vertices12 = [];
        const normals6 = [];
        const uvs7 = [];
        // helper variables
        let groupStart2 = 0;
        let groupCount = 0;
        // allow single and array values for "shapes" parameter
        if (Array.isArray(shapes2) === false) addShape2(shapes2);
        else for(let i10 = 0; i10 < shapes2.length; i10++){
            addShape2(shapes2[i10]);
            this.addGroup(groupStart2, groupCount, i10); // enables MultiMaterial support
            groupStart2 += groupCount;
            groupCount = 0;
        }
        // build geometry
        this.setIndex(indices11);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices12, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals6, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs7, 2));
        // helper functions
        function addShape2(shape) {
            const indexOffset = vertices12.length / 3;
            const points3 = shape.extractPoints(curveSegments);
            let shapeVertices = points3.shape;
            const shapeHoles = points3.holes;
            // check direction of vertices
            if ($267b85717c4872ea$export$50a45ec5a8fa659f.isClockWise(shapeVertices) === false) shapeVertices = shapeVertices.reverse();
            for(let i12 = 0, l1 = shapeHoles.length; i12 < l1; i12++){
                const shapeHole = shapeHoles[i12];
                if ($267b85717c4872ea$export$50a45ec5a8fa659f.isClockWise(shapeHole) === true) shapeHoles[i12] = shapeHole.reverse();
            }
            const faces = $267b85717c4872ea$export$50a45ec5a8fa659f.triangulateShape(shapeVertices, shapeHoles);
            // join vertices of inner and outer paths to a single array
            for(let i13 = 0, l2 = shapeHoles.length; i13 < l2; i13++){
                const shapeHole = shapeHoles[i13];
                shapeVertices = shapeVertices.concat(shapeHole);
            }
            // vertices, normals, uvs
            for(let i14 = 0, l3 = shapeVertices.length; i14 < l3; i14++){
                const vertex3 = shapeVertices[i14];
                vertices12.push(vertex3.x, vertex3.y, 0);
                normals6.push(0, 0, 1);
                uvs7.push(vertex3.x, vertex3.y); // world uvs
            }
            // incides
            for(let i15 = 0, l4 = faces.length; i15 < l4; i15++){
                const face = faces[i15];
                const a2 = face[0] + indexOffset;
                const b3 = face[1] + indexOffset;
                const c2 = face[2] + indexOffset;
                indices11.push(a2, b3, c2);
                groupCount += 3;
            }
        }
    }
    toJSON() {
        const data4 = super.toJSON();
        const shapes3 = this.parameters.shapes;
        return $267b85717c4872ea$var$toJSON(shapes3, data4);
    }
    static fromJSON(data, shapes) {
        const geometryShapes = [];
        for(let j4 = 0, jl = data.shapes.length; j4 < jl; j4++){
            const shape = shapes[data.shapes[j4]];
            geometryShapes.push(shape);
        }
        return new $267b85717c4872ea$export$aacf45bade30a4eb(geometryShapes, data.curveSegments);
    }
}
function $267b85717c4872ea$var$toJSON(shapes3, data4) {
    data4.shapes = [];
    if (Array.isArray(shapes3)) for(let i12 = 0, l1 = shapes3.length; i12 < l1; i12++){
        const shape = shapes3[i12];
        data4.shapes.push(shape.uuid);
    }
    else data4.shapes.push(shapes3.uuid);
    return data4;
}
class $267b85717c4872ea$export$56e3472b8168fecc extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(radius9 = 1, widthSegments2 = 8, heightSegments4 = 6, phiStart1 = 0, phiLength1 = Math.PI * 2, thetaStart4 = 0, thetaLength4 = Math.PI){
        super();
        this.type = 'SphereGeometry';
        this.parameters = {
            radius: radius9,
            widthSegments: widthSegments2,
            heightSegments: heightSegments4,
            phiStart: phiStart1,
            phiLength: phiLength1,
            thetaStart: thetaStart4,
            thetaLength: thetaLength4
        };
        widthSegments2 = Math.max(3, Math.floor(widthSegments2));
        heightSegments4 = Math.max(2, Math.floor(heightSegments4));
        const thetaEnd = Math.min(thetaStart4 + thetaLength4, Math.PI);
        let index1 = 0;
        const grid = [];
        const vertex3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const normal3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        // buffers
        const indices12 = [];
        const vertices13 = [];
        const normals7 = [];
        const uvs8 = [];
        // generate vertices, normals and uvs
        for(let iy2 = 0; iy2 <= heightSegments4; iy2++){
            const verticesRow = [];
            const v = iy2 / heightSegments4;
            // special case for the poles
            let uOffset = 0;
            if (iy2 == 0 && thetaStart4 == 0) uOffset = 0.5 / widthSegments2;
            else if (iy2 == heightSegments4 && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments2;
            for(let ix1 = 0; ix1 <= widthSegments2; ix1++){
                const u = ix1 / widthSegments2;
                // vertex
                vertex3.x = -radius9 * Math.cos(phiStart1 + u * phiLength1) * Math.sin(thetaStart4 + v * thetaLength4);
                vertex3.y = radius9 * Math.cos(thetaStart4 + v * thetaLength4);
                vertex3.z = radius9 * Math.sin(phiStart1 + u * phiLength1) * Math.sin(thetaStart4 + v * thetaLength4);
                vertices13.push(vertex3.x, vertex3.y, vertex3.z);
                // normal
                normal3.copy(vertex3).normalize();
                normals7.push(normal3.x, normal3.y, normal3.z);
                // uv
                uvs8.push(u + uOffset, 1 - v);
                verticesRow.push(index1++);
            }
            grid.push(verticesRow);
        }
        // indices
        for(let iy3 = 0; iy3 < heightSegments4; iy3++)for(let ix1 = 0; ix1 < widthSegments2; ix1++){
            const a2 = grid[iy3][ix1 + 1];
            const b3 = grid[iy3][ix1];
            const c2 = grid[iy3 + 1][ix1];
            const d = grid[iy3 + 1][ix1 + 1];
            if (iy3 !== 0 || thetaStart4 > 0) indices12.push(a2, b3, d);
            if (iy3 !== heightSegments4 - 1 || thetaEnd < Math.PI) indices12.push(b3, c2, d);
        }
        // build geometry
        this.setIndex(indices12);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices13, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals7, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs8, 2));
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$56e3472b8168fecc(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
}
class $267b85717c4872ea$export$6c2b321a0bd817ad extends $267b85717c4872ea$export$1c1772a16308eaa1 {
    constructor(radius10 = 1, detail4 = 0){
        const vertices14 = [
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            1,
            -1,
            1,
            -1,
            -1
        ];
        const indices13 = [
            2,
            1,
            0,
            0,
            3,
            2,
            1,
            3,
            0,
            2,
            3,
            1
        ];
        super(vertices14, indices13, radius10, detail4);
        this.type = 'TetrahedronGeometry';
        this.parameters = {
            radius: radius10,
            detail: detail4
        };
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$6c2b321a0bd817ad(data.radius, data.detail);
    }
}
/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */ class $267b85717c4872ea$export$98d8723ea09f75ef extends $267b85717c4872ea$export$7dac0f8fbb3b30ab {
    constructor(text1, parameters7 = {
    }){
        const font = parameters7.font;
        if (!(font && font.isFont)) {
            console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
            return new $267b85717c4872ea$export$84a34b4c8ecb6751();
        }
        const shapes3 = font.generateShapes(text1, parameters7.size);
        // translate parameters to ExtrudeGeometry API
        parameters7.depth = parameters7.height !== undefined ? parameters7.height : 50;
        // defaults
        if (parameters7.bevelThickness === undefined) parameters7.bevelThickness = 10;
        if (parameters7.bevelSize === undefined) parameters7.bevelSize = 8;
        if (parameters7.bevelEnabled === undefined) parameters7.bevelEnabled = false;
        super(shapes3, parameters7);
        this.type = 'TextGeometry';
    }
}
class $267b85717c4872ea$export$a686f4ad7c95412 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(radius11 = 1, tube = 0.4, radialSegments2 = 8, tubularSegments = 6, arc = Math.PI * 2){
        super();
        this.type = 'TorusGeometry';
        this.parameters = {
            radius: radius11,
            tube: tube,
            radialSegments: radialSegments2,
            tubularSegments: tubularSegments,
            arc: arc
        };
        radialSegments2 = Math.floor(radialSegments2);
        tubularSegments = Math.floor(tubularSegments);
        // buffers
        const indices14 = [];
        const vertices15 = [];
        const normals8 = [];
        const uvs9 = [];
        // helper variables
        const center2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const vertex4 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const normal4 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        // generate vertices, normals and uvs
        for(let j4 = 0; j4 <= radialSegments2; j4++)for(let i12 = 0; i12 <= tubularSegments; i12++){
            const u = i12 / tubularSegments * arc;
            const v = j4 / radialSegments2 * Math.PI * 2;
            // vertex
            vertex4.x = (radius11 + tube * Math.cos(v)) * Math.cos(u);
            vertex4.y = (radius11 + tube * Math.cos(v)) * Math.sin(u);
            vertex4.z = tube * Math.sin(v);
            vertices15.push(vertex4.x, vertex4.y, vertex4.z);
            // normal
            center2.x = radius11 * Math.cos(u);
            center2.y = radius11 * Math.sin(u);
            normal4.subVectors(vertex4, center2).normalize();
            normals8.push(normal4.x, normal4.y, normal4.z);
            // uv
            uvs9.push(i12 / tubularSegments);
            uvs9.push(j4 / radialSegments2);
        }
        // generate indices
        for(let j5 = 1; j5 <= radialSegments2; j5++)for(let i13 = 1; i13 <= tubularSegments; i13++){
            // indices
            const a2 = (tubularSegments + 1) * j5 + i13 - 1;
            const b3 = (tubularSegments + 1) * (j5 - 1) + i13 - 1;
            const c2 = (tubularSegments + 1) * (j5 - 1) + i13;
            const d = (tubularSegments + 1) * j5 + i13;
            // faces
            indices14.push(a2, b3, d);
            indices14.push(b3, c2, d);
        }
        // build geometry
        this.setIndex(indices14);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices15, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals8, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs9, 2));
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$a686f4ad7c95412(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
    }
}
class $267b85717c4872ea$export$d79b98f183885cd1 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(radius12 = 1, tube1 = 0.4, tubularSegments1 = 64, radialSegments3 = 8, p = 2, q = 3){
        super();
        this.type = 'TorusKnotGeometry';
        this.parameters = {
            radius: radius12,
            tube: tube1,
            tubularSegments: tubularSegments1,
            radialSegments: radialSegments3,
            p: p,
            q: q
        };
        tubularSegments1 = Math.floor(tubularSegments1);
        radialSegments3 = Math.floor(radialSegments3);
        // buffers
        const indices15 = [];
        const vertices16 = [];
        const normals9 = [];
        const uvs10 = [];
        // helper variables
        const vertex5 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const normal5 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const P1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const P2 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const B = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const T = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const N = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        // generate vertices, normals and uvs
        for(let i14 = 0; i14 <= tubularSegments1; ++i14){
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
            const u = i14 / tubularSegments1 * p * Math.PI * 2;
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
            calculatePositionOnCurve(u, p, q, radius12, P1);
            calculatePositionOnCurve(u + 0.01, p, q, radius12, P2);
            // calculate orthonormal basis
            T.subVectors(P2, P1);
            N.addVectors(P2, P1);
            B.crossVectors(T, N);
            N.crossVectors(B, T);
            // normalize B, N. T can be ignored, we don't use it
            B.normalize();
            N.normalize();
            for(let j6 = 0; j6 <= radialSegments3; ++j6){
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                const v = j6 / radialSegments3 * Math.PI * 2;
                const cx = -tube1 * Math.cos(v);
                const cy = tube1 * Math.sin(v);
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
                vertex5.x = P1.x + (cx * N.x + cy * B.x);
                vertex5.y = P1.y + (cx * N.y + cy * B.y);
                vertex5.z = P1.z + (cx * N.z + cy * B.z);
                vertices16.push(vertex5.x, vertex5.y, vertex5.z);
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                normal5.subVectors(vertex5, P1).normalize();
                normals9.push(normal5.x, normal5.y, normal5.z);
                // uv
                uvs10.push(i14 / tubularSegments1);
                uvs10.push(j6 / radialSegments3);
            }
        }
        // generate indices
        for(let j6 = 1; j6 <= tubularSegments1; j6++)for(let i15 = 1; i15 <= radialSegments3; i15++){
            // indices
            const a2 = (radialSegments3 + 1) * (j6 - 1) + (i15 - 1);
            const b3 = (radialSegments3 + 1) * j6 + (i15 - 1);
            const c2 = (radialSegments3 + 1) * j6 + i15;
            const d = (radialSegments3 + 1) * (j6 - 1) + i15;
            // faces
            indices15.push(a2, b3, d);
            indices15.push(b3, c2, d);
        }
        // build geometry
        this.setIndex(indices15);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices16, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals9, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs10, 2));
        // this function calculates the current position on the torus curve
        function calculatePositionOnCurve(u, p6, q1, radius13, position1) {
            const cu = Math.cos(u);
            const su = Math.sin(u);
            const quOverP = q1 / p6 * u;
            const cs = Math.cos(quOverP);
            position1.x = radius13 * (2 + cs) * 0.5 * cu;
            position1.y = radius13 * (2 + cs) * su * 0.5;
            position1.z = radius13 * Math.sin(quOverP) * 0.5;
        }
    }
    static fromJSON(data) {
        return new $267b85717c4872ea$export$d79b98f183885cd1(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
    }
}
class $267b85717c4872ea$export$c783db6dcd0e7478 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(path1, tubularSegments2 = 64, radius13 = 1, radialSegments4 = 8, closed1 = false){
        super();
        this.type = 'TubeGeometry';
        this.parameters = {
            path: path1,
            tubularSegments: tubularSegments2,
            radius: radius13,
            radialSegments: radialSegments4,
            closed: closed1
        };
        const frames = path1.computeFrenetFrames(tubularSegments2, closed1);
        // expose internals
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        // helper variables
        const vertex6 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const normal6 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        const uv3 = new $267b85717c4872ea$export$95d9e1e745cc7977();
        let P = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        // buffer
        const vertices17 = [];
        const normals10 = [];
        const uvs11 = [];
        const indices16 = [];
        // create buffer data
        generateBufferData();
        // build geometry
        this.setIndex(indices16);
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices17, 3));
        this.setAttribute('normal', new $267b85717c4872ea$export$8af155dd3ccd7773(normals10, 3));
        this.setAttribute('uv', new $267b85717c4872ea$export$8af155dd3ccd7773(uvs11, 2));
        // functions
        function generateBufferData() {
            for(let i16 = 0; i16 < tubularSegments2; i16++)generateSegment(i16);
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
            generateSegment(closed1 === false ? tubularSegments2 : 0);
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
            generateUVs2();
            // finally create faces
            generateIndices();
        }
        function generateSegment(i16) {
            // we use getPointAt to sample evenly distributed points from the given path
            P = path1.getPointAt(i16 / tubularSegments2, P);
            // retrieve corresponding normal and binormal
            const N1 = frames.normals[i16];
            const B1 = frames.binormals[i16];
            // generate normals and vertices for the current segment
            for(let j7 = 0; j7 <= radialSegments4; j7++){
                const v = j7 / radialSegments4 * Math.PI * 2;
                const sin = Math.sin(v);
                const cos = -Math.cos(v);
                // normal
                normal6.x = cos * N1.x + sin * B1.x;
                normal6.y = cos * N1.y + sin * B1.y;
                normal6.z = cos * N1.z + sin * B1.z;
                normal6.normalize();
                normals10.push(normal6.x, normal6.y, normal6.z);
                // vertex
                vertex6.x = P.x + radius13 * normal6.x;
                vertex6.y = P.y + radius13 * normal6.y;
                vertex6.z = P.z + radius13 * normal6.z;
                vertices17.push(vertex6.x, vertex6.y, vertex6.z);
            }
        }
        function generateIndices() {
            for(let j7 = 1; j7 <= tubularSegments2; j7++)for(let i16 = 1; i16 <= radialSegments4; i16++){
                const a2 = (radialSegments4 + 1) * (j7 - 1) + (i16 - 1);
                const b3 = (radialSegments4 + 1) * j7 + (i16 - 1);
                const c2 = (radialSegments4 + 1) * j7 + i16;
                const d = (radialSegments4 + 1) * (j7 - 1) + i16;
                // faces
                indices16.push(a2, b3, d);
                indices16.push(b3, c2, d);
            }
        }
        function generateUVs2() {
            for(let i16 = 0; i16 <= tubularSegments2; i16++)for(let j7 = 0; j7 <= radialSegments4; j7++){
                uv3.x = i16 / tubularSegments2;
                uv3.y = j7 / radialSegments4;
                uvs11.push(uv3.x, uv3.y);
            }
        }
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.path = this.parameters.path.toJSON();
        return data4;
    }
    static fromJSON(data) {
        // This only works for built-in curves (e.g. CatmullRomCurve3).
        // User defined curves or instances of CurvePath will not be deserialized.
        return new $267b85717c4872ea$export$c783db6dcd0e7478(new $267b85717c4872ea$var$Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
    }
}
class $267b85717c4872ea$export$f05a2fa5988a1b9d extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(geometry8){
        super();
        this.type = 'WireframeGeometry';
        if (geometry8.isGeometry === true) {
            console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
            return;
        }
        // buffer
        const vertices18 = [];
        // helper variables
        const edge = [
            0,
            0
        ], edges = {
        };
        const vertex7 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
        if (geometry8.index !== null) {
            // indexed BufferGeometry
            const position1 = geometry8.attributes.position;
            const indices17 = geometry8.index;
            let groups = geometry8.groups;
            if (groups.length === 0) groups = [
                {
                    start: 0,
                    count: indices17.count,
                    materialIndex: 0
                }
            ];
            // create a data structure that contains all eges without duplicates
            for(let o = 0, ol = groups.length; o < ol; ++o){
                const group = groups[o];
                const start = group.start;
                const count3 = group.count;
                for(let i16 = start, l1 = start + count3; i16 < l1; i16 += 3)for(let j7 = 0; j7 < 3; j7++){
                    const edge1 = indices17.getX(i16 + j7);
                    const edge2 = indices17.getX(i16 + (j7 + 1) % 3);
                    edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
                    edge[1] = Math.max(edge1, edge2);
                    const key1 = edge[0] + ',' + edge[1];
                    if (edges[key1] === undefined) edges[key1] = {
                        index1: edge[0],
                        index2: edge[1]
                    };
                }
            }
            // generate vertices
            for(const key1 in edges){
                const e = edges[key1];
                vertex7.fromBufferAttribute(position1, e.index1);
                vertices18.push(vertex7.x, vertex7.y, vertex7.z);
                vertex7.fromBufferAttribute(position1, e.index2);
                vertices18.push(vertex7.x, vertex7.y, vertex7.z);
            }
        } else {
            // non-indexed BufferGeometry
            const position1 = geometry8.attributes.position;
            for(let i16 = 0, l1 = position1.count / 3; i16 < l1; i16++)for(let j7 = 0; j7 < 3; j7++){
                // three edges per triangle, an edge is represented as (index1, index2)
                // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                const index11 = 3 * i16 + j7;
                vertex7.fromBufferAttribute(position1, index11);
                vertices18.push(vertex7.x, vertex7.y, vertex7.z);
                const index2 = 3 * i16 + (j7 + 1) % 3;
                vertex7.fromBufferAttribute(position1, index2);
                vertices18.push(vertex7.x, vertex7.y, vertex7.z);
            }
        }
        // build geometry
        this.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices18, 3));
    }
}
var $267b85717c4872ea$var$Geometries = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    BoxGeometry: $267b85717c4872ea$export$7adcd09f49b1ca3c,
    BoxBufferGeometry: $267b85717c4872ea$export$7adcd09f49b1ca3c,
    CircleGeometry: $267b85717c4872ea$export$7d8d1abfdf118042,
    CircleBufferGeometry: $267b85717c4872ea$export$7d8d1abfdf118042,
    ConeGeometry: $267b85717c4872ea$export$1f850d89f6c8d5b3,
    ConeBufferGeometry: $267b85717c4872ea$export$1f850d89f6c8d5b3,
    CylinderGeometry: $267b85717c4872ea$export$94c6884a61a1e52e,
    CylinderBufferGeometry: $267b85717c4872ea$export$94c6884a61a1e52e,
    DodecahedronGeometry: $267b85717c4872ea$export$b268e5ba415841ce,
    DodecahedronBufferGeometry: $267b85717c4872ea$export$b268e5ba415841ce,
    EdgesGeometry: $267b85717c4872ea$export$2042389ca5695441,
    ExtrudeGeometry: $267b85717c4872ea$export$7dac0f8fbb3b30ab,
    ExtrudeBufferGeometry: $267b85717c4872ea$export$7dac0f8fbb3b30ab,
    IcosahedronGeometry: $267b85717c4872ea$export$362a3ddc4e904cfe,
    IcosahedronBufferGeometry: $267b85717c4872ea$export$362a3ddc4e904cfe,
    LatheGeometry: $267b85717c4872ea$export$82ccc99a183c6757,
    LatheBufferGeometry: $267b85717c4872ea$export$82ccc99a183c6757,
    OctahedronGeometry: $267b85717c4872ea$export$4f8ac4fd44f1e5f,
    OctahedronBufferGeometry: $267b85717c4872ea$export$4f8ac4fd44f1e5f,
    ParametricGeometry: $267b85717c4872ea$export$be4484824eed17ec,
    ParametricBufferGeometry: $267b85717c4872ea$export$be4484824eed17ec,
    PlaneGeometry: $267b85717c4872ea$export$f5196b7984dc72bd,
    PlaneBufferGeometry: $267b85717c4872ea$export$f5196b7984dc72bd,
    PolyhedronGeometry: $267b85717c4872ea$export$1c1772a16308eaa1,
    PolyhedronBufferGeometry: $267b85717c4872ea$export$1c1772a16308eaa1,
    RingGeometry: $267b85717c4872ea$export$924916dda2d7dd4c,
    RingBufferGeometry: $267b85717c4872ea$export$924916dda2d7dd4c,
    ShapeGeometry: $267b85717c4872ea$export$aacf45bade30a4eb,
    ShapeBufferGeometry: $267b85717c4872ea$export$aacf45bade30a4eb,
    SphereGeometry: $267b85717c4872ea$export$56e3472b8168fecc,
    SphereBufferGeometry: $267b85717c4872ea$export$56e3472b8168fecc,
    TetrahedronGeometry: $267b85717c4872ea$export$6c2b321a0bd817ad,
    TetrahedronBufferGeometry: $267b85717c4872ea$export$6c2b321a0bd817ad,
    TextGeometry: $267b85717c4872ea$export$98d8723ea09f75ef,
    TextBufferGeometry: $267b85717c4872ea$export$98d8723ea09f75ef,
    TorusGeometry: $267b85717c4872ea$export$a686f4ad7c95412,
    TorusBufferGeometry: $267b85717c4872ea$export$a686f4ad7c95412,
    TorusKnotGeometry: $267b85717c4872ea$export$d79b98f183885cd1,
    TorusKnotBufferGeometry: $267b85717c4872ea$export$d79b98f183885cd1,
    TubeGeometry: $267b85717c4872ea$export$c783db6dcd0e7478,
    TubeBufferGeometry: $267b85717c4872ea$export$c783db6dcd0e7478,
    WireframeGeometry: $267b85717c4872ea$export$f05a2fa5988a1b9d
});
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */ class $267b85717c4872ea$export$d60ae7ffee1204 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters8){
        super();
        this.type = 'ShadowMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
        this.transparent = true;
        this.setValues(parameters8);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        return this;
    }
}
$267b85717c4872ea$export$d60ae7ffee1204.prototype.isShadowMaterial = true;
class $267b85717c4872ea$export$44c67e5b3e2f1fcc extends $267b85717c4872ea$export$2a77b7c526ae5937 {
    constructor(parameters9){
        super(parameters9);
        this.type = 'RawShaderMaterial';
    }
}
$267b85717c4872ea$export$44c67e5b3e2f1fcc.prototype.isRawShaderMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */ class $267b85717c4872ea$export$9e3d9f854a8d8dca extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters10){
        super();
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215); // diffuse
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $267b85717c4872ea$export$9c3212295f347347;
        this.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.morphTargets = false;
        this.morphNormals = false;
        this.flatShading = false;
        this.vertexTangents = false;
        this.setValues(parameters10);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        this.vertexTangents = source.vertexTangents;
        return this;
    }
}
$267b85717c4872ea$export$9e3d9f854a8d8dca.prototype.isMeshStandardMaterial = true;
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> ),
 *
 *  thickness: <float>,
 *  thicknessMap: new THREE.Texture( <Image> ),
 *  attenuationDistance: <float>,
 *  attenuationColor: <Color>
 * }
 */ class $267b85717c4872ea$export$8e48fda91416ebbe extends $267b85717c4872ea$export$9e3d9f854a8d8dca {
    constructor(parameters11){
        super();
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.clearcoat = 0;
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.clearcoatNormalMap = null;
        this.reflectivity = 0.5; // maps to F0 = 0.04
        Object.defineProperty(this, 'ior', {
            get: function() {
                return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
            },
            set: function(ior) {
                this.reflectivity = $267b85717c4872ea$var$clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
            }
        });
        this.sheen = null; // null will disable sheen bsdf
        this.transmission = 0;
        this.transmissionMap = null;
        this.thickness = 0.01;
        this.thicknessMap = null;
        this.attenuationDistance = 0;
        this.attenuationColor = new $267b85717c4872ea$export$e4830c8e55b4f80d(1, 1, 1);
        this.setValues(parameters11);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.reflectivity = source.reflectivity;
        if (source.sheen) this.sheen = (this.sheen || new $267b85717c4872ea$export$e4830c8e55b4f80d()).copy(source.sheen);
        else this.sheen = null;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        return this;
    }
}
$267b85717c4872ea$export$8e48fda91416ebbe.prototype.isMeshPhysicalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */ class $267b85717c4872ea$export$a329e7eb7e1af1af extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters12){
        super();
        this.type = 'MeshPhongMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215); // diffuse
        this.specular = new $267b85717c4872ea$export$e4830c8e55b4f80d(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $267b85717c4872ea$export$9c3212295f347347;
        this.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $267b85717c4872ea$export$9662028f262f1c9a;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.morphTargets = false;
        this.morphNormals = false;
        this.flatShading = false;
        this.setValues(parameters12);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
    }
}
$267b85717c4872ea$export$a329e7eb7e1af1af.prototype.isMeshPhongMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ class $267b85717c4872ea$export$d171fef9914bcc52 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters13){
        super();
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $267b85717c4872ea$export$9c3212295f347347;
        this.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters13);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
}
$267b85717c4872ea$export$d171fef9914bcc52.prototype.isMeshToonMaterial = true;
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */ class $267b85717c4872ea$export$b34bdbeb7c871cc8 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters14){
        super();
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $267b85717c4872ea$export$9c3212295f347347;
        this.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.flatShading = false;
        this.setValues(parameters14);
    }
    copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
    }
}
$267b85717c4872ea$export$b34bdbeb7c871cc8.prototype.isMeshNormalMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */ class $267b85717c4872ea$export$ec3f1559d9bda861 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters15){
        super();
        this.type = 'MeshLambertMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215); // diffuse
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new $267b85717c4872ea$export$e4830c8e55b4f80d(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = $267b85717c4872ea$export$9662028f262f1c9a;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters15);
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    }
}
$267b85717c4872ea$export$ec3f1559d9bda861.prototype.isMeshLambertMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */ class $267b85717c4872ea$export$efdd6d5ebb1b0c25 extends $267b85717c4872ea$export$1631e5d26e6ca932 {
    constructor(parameters16){
        super();
        this.defines = {
            'MATCAP': ''
        };
        this.type = 'MeshMatcapMaterial';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215); // diffuse
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = $267b85717c4872ea$export$9c3212295f347347;
        this.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.morphTargets = false;
        this.morphNormals = false;
        this.flatShading = false;
        this.setValues(parameters16);
    }
    copy(source) {
        super.copy(source);
        this.defines = {
            'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.flatShading = source.flatShading;
        return this;
    }
}
$267b85717c4872ea$export$efdd6d5ebb1b0c25.prototype.isMeshMatcapMaterial = true;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */ class $267b85717c4872ea$export$37080b7b378e1ae extends $267b85717c4872ea$export$9dd1d6697fbc79f6 {
    constructor(parameters17){
        super();
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters17);
    }
    copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    }
}
$267b85717c4872ea$export$37080b7b378e1ae.prototype.isLineDashedMaterial = true;
var $267b85717c4872ea$var$Materials = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ShadowMaterial: $267b85717c4872ea$export$d60ae7ffee1204,
    SpriteMaterial: $267b85717c4872ea$export$84b903c68a869d64,
    RawShaderMaterial: $267b85717c4872ea$export$44c67e5b3e2f1fcc,
    ShaderMaterial: $267b85717c4872ea$export$2a77b7c526ae5937,
    PointsMaterial: $267b85717c4872ea$export$5e855264a077e9f,
    MeshPhysicalMaterial: $267b85717c4872ea$export$8e48fda91416ebbe,
    MeshStandardMaterial: $267b85717c4872ea$export$9e3d9f854a8d8dca,
    MeshPhongMaterial: $267b85717c4872ea$export$a329e7eb7e1af1af,
    MeshToonMaterial: $267b85717c4872ea$export$d171fef9914bcc52,
    MeshNormalMaterial: $267b85717c4872ea$export$b34bdbeb7c871cc8,
    MeshLambertMaterial: $267b85717c4872ea$export$ec3f1559d9bda861,
    MeshDepthMaterial: $267b85717c4872ea$export$4153a5007efa303f,
    MeshDistanceMaterial: $267b85717c4872ea$export$1b7bb4a7b69d3a38,
    MeshBasicMaterial: $267b85717c4872ea$export$f191b8c5dbd3d9f9,
    MeshMatcapMaterial: $267b85717c4872ea$export$efdd6d5ebb1b0c25,
    LineDashedMaterial: $267b85717c4872ea$export$37080b7b378e1ae,
    LineBasicMaterial: $267b85717c4872ea$export$9dd1d6697fbc79f6,
    Material: $267b85717c4872ea$export$1631e5d26e6ca932
});
const $267b85717c4872ea$export$f672e35d7b72544f = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array14, from, to) {
        if ($267b85717c4872ea$export$f672e35d7b72544f.isTypedArray(array14)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array14.constructor(array14.subarray(from, to !== undefined ? to : array14.length));
        return array14.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array14, type7, forceClone) {
        if (!array14 || !forceClone && array14.constructor === type7) return array14;
        if (typeof type7.BYTES_PER_ELEMENT === 'number') return new type7(array14); // create typed array
        return Array.prototype.slice.call(array14); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i16, j7) {
            return times[i16] - times[j7];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i16 = 0; i16 !== n; ++i16)result[i16] = i16;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride1, order2) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i16 = 0, dstOffset = 0; dstOffset !== nValues; ++i16){
            const srcOffset = order2[i16] * stride1;
            for(let j7 = 0; j7 !== stride1; ++j7)result[dstOffset++] = values[srcOffset + j7];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i16 = 1, key1 = jsonKeys[0];
        while(key1 !== undefined && key1[valuePropertyName] === undefined)key1 = jsonKeys[i16++];
        if (key1 === undefined) return; // no data
        let value = key1[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                values.push.apply(values, value); // push all elements
            }
            key1 = jsonKeys[i16++];
        }while (key1 !== undefined)
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                value.toArray(values, values.length);
            }
            key1 = jsonKeys[i16++];
        }while (key1 !== undefined)
        else // otherwise push as-is
        do {
            value = key1[valuePropertyName];
            if (value !== undefined) {
                times.push(key1.time);
                values.push(value);
            }
            key1 = jsonKeys[i16++];
        }while (key1 !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i16 = 0; i16 < clip.tracks.length; ++i16){
            const track = clip.tracks[i16];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j7 = 0; j7 < track.times.length; ++j7){
                const frame = track.times[j7] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j7]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j7 * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = $267b85717c4872ea$export$f672e35d7b72544f.convertArray(times, track.times.constructor);
            track.values = $267b85717c4872ea$export$f672e35d7b72544f.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i17 = 0; i17 < clip.tracks.length; ++i17)if (minStartTime > clip.tracks[i17].times[0]) minStartTime = clip.tracks[i17].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i18 = 0; i18 < clip.tracks.length; ++i18)clip.tracks[i18].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0) fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i16 = 0; i16 < numTracks; ++i16){
            const referenceTrack = referenceClip.tracks[i16];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new $267b85717c4872ea$export$8756178d528e80f7().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j7 = 0; j7 < numTimes; ++j7){
                const valueStart = j7 * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                $267b85717c4872ea$export$8756178d528e80f7.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = $267b85717c4872ea$export$1b7d33858890b670;
        return targetClip;
    }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */ class $267b85717c4872ea$export$4a454595f745ddee {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {
        };
    }
    evaluate(t) {
        const pp = this.parameterPositions;
        let i16 = this._cachedIndex, t11 = pp[i16], t0 = pp[i16 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t < t11)) {
                        for(let giveUpAt = i16 + 2;;){
                            if (t11 === undefined) {
                                if (t < t0) break forward_scan;
                                // after end
                                i16 = pp.length;
                                this._cachedIndex = i16;
                                return this.afterEnd_(i16 - 1, t, t0);
                            }
                            if (i16 === giveUpAt) break; // this loop
                            t0 = t11;
                            t11 = pp[++i16];
                            if (t < t11) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t < t1global) {
                            i16 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i16 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t, t11);
                            }
                            if (i16 === giveUpAt) break; // this loop
                            t11 = t0;
                            t0 = pp[(--i16) - 1];
                            if (t >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i16;
                        i16 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i16 < right){
                    const mid = i16 + right >>> 1;
                    if (t < pp[mid]) right = mid;
                    else i16 = mid + 1;
                }
                t11 = pp[i16];
                t0 = pp[i16 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t, t11);
                }
                if (t11 === undefined) {
                    i16 = pp.length;
                    this._cachedIndex = i16;
                    return this.afterEnd_(i16 - 1, t0, t);
                }
            } // seek
            this._cachedIndex = i16;
            this.intervalChanged_(i16, t0, t11);
        } // validate_interval
        return this.interpolate_(i16, t0, t, t11);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride1 = this.valueSize, offset1 = index * stride1;
        for(let i16 = 0; i16 !== stride1; ++i16)result[i16] = values[offset1 + i16];
        return result;
    }
    // Template methods for derived classes:
    interpolate_() {
        throw new Error('call to abstract method');
    // implementations shall return this.resultBuffer
    }
    intervalChanged_() {
    // empty
    }
}
// ALIAS DEFINITIONS
$267b85717c4872ea$export$4a454595f745ddee.prototype.beforeStart_ = $267b85717c4872ea$export$4a454595f745ddee.prototype.copySampleValue_;
$267b85717c4872ea$export$4a454595f745ddee.prototype.afterEnd_ = $267b85717c4872ea$export$4a454595f745ddee.prototype.copySampleValue_;
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */ class $267b85717c4872ea$export$d8ced7562bc9282b extends $267b85717c4872ea$export$4a454595f745ddee {
    constructor(parameterPositions1, sampleValues1, sampleSize1, resultBuffer1){
        super(parameterPositions1, sampleValues1, sampleSize1, resultBuffer1);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
            endingStart: $267b85717c4872ea$export$d8b6fdb2f300ab40,
            endingEnd: $267b85717c4872ea$export$d8b6fdb2f300ab40
        };
    }
    intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case $267b85717c4872ea$export$6f63fb2e509705af:
                // f'(t0) = 0
                iPrev = i1;
                tPrev = 2 * t0 - t1;
                break;
            case $267b85717c4872ea$export$ab43ac719393f08d:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i1;
                tPrev = t1;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case $267b85717c4872ea$export$6f63fb2e509705af:
                // f'(tN) = 0
                iNext = i1;
                tNext = 2 * t1 - t0;
                break;
            case $267b85717c4872ea$export$ab43ac719393f08d:
                // use the other end of the curve
                iNext = 1;
                tNext = t1 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i1 - 1;
                tNext = t0;
        }
        const halfDt = (t1 - t0) * 0.5, stride1 = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride1;
        this._offsetNext = iNext * stride1;
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride1 = this.valueSize, o1 = i1 * stride1, o0 = o1 - stride1, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p6 = (t - t0) / (t1 - t0), pp = p6 * p6, ppp = pp * p6;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p6;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p6 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p6;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i16 = 0; i16 !== stride1; ++i16)result[i16] = sP * values[oP + i16] + s0 * values[o0 + i16] + s1 * values[o1 + i16] + sN * values[oN + i16];
        return result;
    }
}
class $267b85717c4872ea$export$53b17592d36ed11c extends $267b85717c4872ea$export$4a454595f745ddee {
    constructor(parameterPositions2, sampleValues2, sampleSize2, resultBuffer2){
        super(parameterPositions2, sampleValues2, sampleSize2, resultBuffer2);
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride1 = this.valueSize, offset1 = i1 * stride1, offset0 = offset1 - stride1, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
        for(let i16 = 0; i16 !== stride1; ++i16)result[i16] = values[offset0 + i16] * weight0 + values[offset1 + i16] * weight1;
        return result;
    }
}
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */ class $267b85717c4872ea$export$436def06d70496b6 extends $267b85717c4872ea$export$4a454595f745ddee {
    constructor(parameterPositions3, sampleValues3, sampleSize3, resultBuffer3){
        super(parameterPositions3, sampleValues3, sampleSize3, resultBuffer3);
    }
    interpolate_(i1 /*, t0, t, t1 */ ) {
        return this.copySampleValue_(i1 - 1);
    }
}
class $267b85717c4872ea$export$7681eae64aeddad0 {
    constructor(name2, times, values, interpolation1){
        if (name2 === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
        if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name2);
        this.name = name2;
        this.times = $267b85717c4872ea$export$f672e35d7b72544f.convertArray(times, this.TimeBufferType);
        this.values = $267b85717c4872ea$export$f672e35d7b72544f.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation1 || this.DefaultInterpolation);
    }
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    static toJSON(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== this.toJSON) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': $267b85717c4872ea$export$f672e35d7b72544f.convertArray(track.times, Array),
                'values': $267b85717c4872ea$export$f672e35d7b72544f.convertArray(track.values, Array)
            };
            const interpolation1 = track.getInterpolation();
            if (interpolation1 !== track.DefaultInterpolation) json.interpolation = interpolation1;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
        return new $267b85717c4872ea$export$436def06d70496b6(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
        return new $267b85717c4872ea$export$53b17592d36ed11c(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
        return new $267b85717c4872ea$export$d8ced7562bc9282b(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case $267b85717c4872ea$export$3b97cb67250b5b78:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case $267b85717c4872ea$export$6b1e0ecaec10d488:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case $267b85717c4872ea$export$a21a2facc0e6ec62:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    }
    getInterpolation() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return $267b85717c4872ea$export$3b97cb67250b5b78;
            case this.InterpolantFactoryMethodLinear:
                return $267b85717c4872ea$export$6b1e0ecaec10d488;
            case this.InterpolantFactoryMethodSmooth:
                return $267b85717c4872ea$export$a21a2facc0e6ec62;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    // move all keyframes either forwards or backwards in time
    shift(timeOffset) {
        if (timeOffset !== 0) {
            const times1 = this.times;
            for(let i16 = 0, n = times1.length; i16 !== n; ++i16)times1[i16] += timeOffset;
        }
        return this;
    }
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale(timeScale) {
        if (timeScale !== 1) {
            const times1 = this.times;
            for(let i16 = 0, n = times1.length; i16 !== n; ++i16)times1[i16] *= timeScale;
        }
        return this;
    }
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim(startTime, endTime) {
        const times1 = this.times, nKeys = times1.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times1[from] < startTime)++from;
        while(to !== -1 && times1[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride1 = this.getValueSize();
            this.times = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(times1, from, to);
            this.values = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(this.values, from * stride1, to * stride1);
        }
        return this;
    }
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times1 = this.times, values1 = this.values, nKeys = times1.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i16 = 0; i16 !== nKeys; i16++){
            const currTime = times1[i16];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i16, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i16, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values1 !== undefined) {
            if ($267b85717c4872ea$export$f672e35d7b72544f.isTypedArray(values1)) for(let i17 = 0, n = values1.length; i17 !== n; ++i17){
                const value = values1[i17];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i17, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    }
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times1 = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(this.times), values1 = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(this.values), stride1 = this.getValueSize(), smoothInterpolation = this.getInterpolation() === $267b85717c4872ea$export$a21a2facc0e6ec62, lastIndex = times1.length - 1;
        let writeIndex = 1;
        for(let i16 = 1; i16 < lastIndex; ++i16){
            let keep = false;
            const time = times1[i16];
            const timeNext = times1[i16 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i16 !== 1 || time !== times1[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset1 = i16 * stride1, offsetP = offset1 - stride1, offsetN = offset1 + stride1;
                    for(let j7 = 0; j7 !== stride1; ++j7){
                        const value = values1[offset1 + j7];
                        if (value !== values1[offsetP + j7] || value !== values1[offsetN + j7]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i16 !== writeIndex) {
                    times1[writeIndex] = times1[i16];
                    const readOffset = i16 * stride1, writeOffset = writeIndex * stride1;
                    for(let j7 = 0; j7 !== stride1; ++j7)values1[writeOffset + j7] = values1[readOffset + j7];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times1[writeIndex] = times1[lastIndex];
            for(let readOffset = lastIndex * stride1, writeOffset = writeIndex * stride1, j7 = 0; j7 !== stride1; ++j7)values1[writeOffset + j7] = values1[readOffset + j7];
            ++writeIndex;
        }
        if (writeIndex !== times1.length) {
            this.times = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(times1, 0, writeIndex);
            this.values = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(values1, 0, writeIndex * stride1);
        } else {
            this.times = times1;
            this.values = values1;
        }
        return this;
    }
    clone() {
        const times1 = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(this.times, 0);
        const values1 = $267b85717c4872ea$export$f672e35d7b72544f.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times1, values1);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
}
$267b85717c4872ea$export$7681eae64aeddad0.prototype.TimeBufferType = Float32Array;
$267b85717c4872ea$export$7681eae64aeddad0.prototype.ValueBufferType = Float32Array;
$267b85717c4872ea$export$7681eae64aeddad0.prototype.DefaultInterpolation = $267b85717c4872ea$export$6b1e0ecaec10d488;
/**
 * A Track of Boolean keyframe values.
 */ class $267b85717c4872ea$export$4c7089b4796793cd extends $267b85717c4872ea$export$7681eae64aeddad0 {
}
$267b85717c4872ea$export$4c7089b4796793cd.prototype.ValueTypeName = 'bool';
$267b85717c4872ea$export$4c7089b4796793cd.prototype.ValueBufferType = Array;
$267b85717c4872ea$export$4c7089b4796793cd.prototype.DefaultInterpolation = $267b85717c4872ea$export$3b97cb67250b5b78;
$267b85717c4872ea$export$4c7089b4796793cd.prototype.InterpolantFactoryMethodLinear = undefined;
$267b85717c4872ea$export$4c7089b4796793cd.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of keyframe values that represent color.
 */ class $267b85717c4872ea$export$b3a2fd27733fdc7 extends $267b85717c4872ea$export$7681eae64aeddad0 {
}
$267b85717c4872ea$export$b3a2fd27733fdc7.prototype.ValueTypeName = 'color';
/**
 * A Track of numeric keyframe values.
 */ class $267b85717c4872ea$export$4e12a1a1b04ccebf extends $267b85717c4872ea$export$7681eae64aeddad0 {
}
$267b85717c4872ea$export$4e12a1a1b04ccebf.prototype.ValueTypeName = 'number';
/**
 * Spherical linear unit quaternion interpolant.
 */ class $267b85717c4872ea$export$e7c89c6a3cc89ff5 extends $267b85717c4872ea$export$4a454595f745ddee {
    constructor(parameterPositions4, sampleValues4, sampleSize4, resultBuffer4){
        super(parameterPositions4, sampleValues4, sampleSize4, resultBuffer4);
    }
    interpolate_(i1, t0, t, t1) {
        const result = this.resultBuffer, values1 = this.sampleValues, stride1 = this.valueSize, alpha = (t - t0) / (t1 - t0);
        let offset1 = i1 * stride1;
        for(let end = offset1 + stride1; offset1 !== end; offset1 += 4)$267b85717c4872ea$export$8756178d528e80f7.slerpFlat(result, 0, values1, offset1 - stride1, values1, offset1, alpha);
        return result;
    }
}
/**
 * A Track of quaternion keyframe values.
 */ class $267b85717c4872ea$export$d6e1386f3fab9d4d extends $267b85717c4872ea$export$7681eae64aeddad0 {
    InterpolantFactoryMethodLinear(result) {
        return new $267b85717c4872ea$export$e7c89c6a3cc89ff5(this.times, this.values, this.getValueSize(), result);
    }
}
$267b85717c4872ea$export$d6e1386f3fab9d4d.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
$267b85717c4872ea$export$d6e1386f3fab9d4d.prototype.DefaultInterpolation = $267b85717c4872ea$export$6b1e0ecaec10d488;
$267b85717c4872ea$export$d6e1386f3fab9d4d.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track that interpolates Strings
 */ class $267b85717c4872ea$export$b952493fa13fc3d3 extends $267b85717c4872ea$export$7681eae64aeddad0 {
}
$267b85717c4872ea$export$b952493fa13fc3d3.prototype.ValueTypeName = 'string';
$267b85717c4872ea$export$b952493fa13fc3d3.prototype.ValueBufferType = Array;
$267b85717c4872ea$export$b952493fa13fc3d3.prototype.DefaultInterpolation = $267b85717c4872ea$export$3b97cb67250b5b78;
$267b85717c4872ea$export$b952493fa13fc3d3.prototype.InterpolantFactoryMethodLinear = undefined;
$267b85717c4872ea$export$b952493fa13fc3d3.prototype.InterpolantFactoryMethodSmooth = undefined;
/**
 * A Track of vectored keyframe values.
 */ class $267b85717c4872ea$export$647eb676c3f24c16 extends $267b85717c4872ea$export$7681eae64aeddad0 {
}
$267b85717c4872ea$export$647eb676c3f24c16.prototype.ValueTypeName = 'vector';
class $267b85717c4872ea$export$79ad2141f3423764 {
    constructor(name1, duration1 = -1, tracks, blendMode2 = $267b85717c4872ea$export$54330578444a738c){
        this.name = name1;
        this.tracks = tracks;
        this.duration = duration1;
        this.blendMode = blendMode2;
        this.uuid = $267b85717c4872ea$var$generateUUID();
        // this means it should figure out its duration by scanning the tracks
        if (this.duration < 0) this.resetDuration();
    }
    static parse(json) {
        const tracks1 = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i16 = 0, n = jsonTracks.length; i16 !== n; ++i16)tracks1.push($267b85717c4872ea$var$parseKeyframeTrack(jsonTracks[i16]).scale(frameTime));
        const clip = new this(json.name, json.duration, tracks1, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
    }
    static toJSON(clip) {
        const tracks1 = [], clipTracks = clip.tracks;
        const json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks1,
            'uuid': clip.uuid,
            'blendMode': clip.blendMode
        };
        for(let i16 = 0, n = clipTracks.length; i16 !== n; ++i16)tracks1.push($267b85717c4872ea$export$7681eae64aeddad0.toJSON(clipTracks[i16]));
        return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks1 = [];
        for(let i16 = 0; i16 < numMorphTargets; i16++){
            let times1 = [];
            let values1 = [];
            times1.push((i16 + numMorphTargets - 1) % numMorphTargets, i16, (i16 + 1) % numMorphTargets);
            values1.push(0, 1, 0);
            const order2 = $267b85717c4872ea$export$f672e35d7b72544f.getKeyframeOrder(times1);
            times1 = $267b85717c4872ea$export$f672e35d7b72544f.sortedArray(times1, 1, order2);
            values1 = $267b85717c4872ea$export$f672e35d7b72544f.sortedArray(values1, 1, order2);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times1[0] === 0) {
                times1.push(numMorphTargets);
                values1.push(values1[0]);
            }
            tracks1.push(new $267b85717c4872ea$export$4e12a1a1b04ccebf('.morphTargetInfluences[' + morphTargetSequence[i16].name + ']', times1, values1).scale(1 / fps));
        }
        return new this(name, -1, tracks1);
    }
    static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i16 = 0; i16 < clipArray.length; i16++){
            if (clipArray[i16].name === name) return clipArray[i16];
        }
        return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {
        };
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i16 = 0, il = morphTargets.length; i16 < il; i16++){
            const morphTarget = morphTargets[i16];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name3 = parts[1];
                let animationMorphTargets = animationToMorphTargets[name3];
                if (!animationMorphTargets) animationToMorphTargets[name3] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name3 in animationToMorphTargets)clips.push(this.CreateFromMorphTargetSequence(name3, animationToMorphTargets[name3], fps, noLoop));
        return clips;
    }
    // parse the animation.hierarchy format
    static parseAnimation(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times1 = [];
                const values1 = [];
                $267b85717c4872ea$export$f672e35d7b72544f.flattenJSON(animationKeys, times1, values1, propertyName);
                // empty keys are filtered out, so check again
                if (times1.length !== 0) destTracks.push(new trackType(trackName, times1, values1));
            }
        };
        const tracks1 = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode1 = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration1 = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {
                };
                let k;
                for(k = 0; k < animationKeys.length; k++){
                    if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times1 = [];
                    const values1 = [];
                    for(let m = 0; m !== animationKeys[k].morphTargets.length; ++m){
                        const animationKey = animationKeys[k];
                        times1.push(animationKey.time);
                        values1.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks1.push(new $267b85717c4872ea$export$4e12a1a1b04ccebf('.morphTargetInfluence[' + morphTargetName + ']', times1, values1));
                }
                duration1 = morphTargetNames.length * (fps || 1);
            } else {
                // ...assume skeletal animation
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack($267b85717c4872ea$export$647eb676c3f24c16, boneName + '.position', animationKeys, 'pos', tracks1);
                addNonemptyTrack($267b85717c4872ea$export$d6e1386f3fab9d4d, boneName + '.quaternion', animationKeys, 'rot', tracks1);
                addNonemptyTrack($267b85717c4872ea$export$647eb676c3f24c16, boneName + '.scale', animationKeys, 'scl', tracks1);
            }
        }
        if (tracks1.length === 0) return null;
        const clip = new this(clipName, duration1, tracks1, blendMode1);
        return clip;
    }
    resetDuration() {
        const tracks1 = this.tracks;
        let duration1 = 0;
        for(let i16 = 0, n = tracks1.length; i16 !== n; ++i16){
            const track = this.tracks[i16];
            duration1 = Math.max(duration1, track.times[track.times.length - 1]);
        }
        this.duration = duration1;
        return this;
    }
    trim() {
        for(let i16 = 0; i16 < this.tracks.length; i16++)this.tracks[i16].trim(0, this.duration);
        return this;
    }
    validate() {
        let valid = true;
        for(let i16 = 0; i16 < this.tracks.length; i16++)valid = valid && this.tracks[i16].validate();
        return valid;
    }
    optimize() {
        for(let i16 = 0; i16 < this.tracks.length; i16++)this.tracks[i16].optimize();
        return this;
    }
    clone() {
        const tracks1 = [];
        for(let i16 = 0; i16 < this.tracks.length; i16++)tracks1.push(this.tracks[i16].clone());
        return new this.constructor(this.name, this.duration, tracks1, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function $267b85717c4872ea$var$getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return $267b85717c4872ea$export$4e12a1a1b04ccebf;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return $267b85717c4872ea$export$647eb676c3f24c16;
        case 'color':
            return $267b85717c4872ea$export$b3a2fd27733fdc7;
        case 'quaternion':
            return $267b85717c4872ea$export$d6e1386f3fab9d4d;
        case 'bool':
        case 'boolean':
            return $267b85717c4872ea$export$4c7089b4796793cd;
        case 'string':
            return $267b85717c4872ea$export$b952493fa13fc3d3;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function $267b85717c4872ea$var$parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = $267b85717c4872ea$var$getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times1 = [], values1 = [];
        $267b85717c4872ea$export$f672e35d7b72544f.flattenJSON(json.keys, times1, values1, 'value');
        json.times = times1;
        json.values = values1;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
const $267b85717c4872ea$export$7c17e0f15419affd = {
    enabled: false,
    files: {
    },
    add: function(key1, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key1] = file;
    },
    get: function(key1) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key1];
    },
    remove: function(key1) {
        delete this.files[key1];
    },
    clear: function() {
        this.files = {
        };
    }
};
class $267b85717c4872ea$export$53aaaf7fed9d16ee {
    constructor(onLoad1, onProgress1, onError1){
        const scope5 = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = undefined;
        const handlers = [];
        // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
        this.onStart = undefined;
        this.onLoad = onLoad1;
        this.onProgress = onProgress1;
        this.onError = onError1;
        this.itemStart = function(url) {
            itemsTotal++;
            if (isLoading === false) {
                if (scope5.onStart !== undefined) scope5.onStart(url, itemsLoaded, itemsTotal);
            }
            isLoading = true;
        };
        this.itemEnd = function(url) {
            itemsLoaded++;
            if (scope5.onProgress !== undefined) scope5.onProgress(url, itemsLoaded, itemsTotal);
            if (itemsLoaded === itemsTotal) {
                isLoading = false;
                if (scope5.onLoad !== undefined) scope5.onLoad();
            }
        };
        this.itemError = function(url) {
            if (scope5.onError !== undefined) scope5.onError(url);
        };
        this.resolveURL = function(url) {
            if (urlModifier) return urlModifier(url);
            return url;
        };
        this.setURLModifier = function(transform) {
            urlModifier = transform;
            return this;
        };
        this.addHandler = function(regex, loader) {
            handlers.push(regex, loader);
            return this;
        };
        this.removeHandler = function(regex) {
            const index3 = handlers.indexOf(regex);
            if (index3 !== -1) handlers.splice(index3, 2);
            return this;
        };
        this.getHandler = function(file) {
            for(let i16 = 0, l1 = handlers.length; i16 < l1; i16 += 2){
                const regex = handlers[i16];
                const loader = handlers[i16 + 1];
                if (regex.global) regex.lastIndex = 0; // see #17920
                if (regex.test(file)) return loader;
            }
            return null;
        };
    }
}
const $267b85717c4872ea$export$e4a62db56fe87452 = new $267b85717c4872ea$export$53aaaf7fed9d16ee();
class $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager){
        this.manager = manager !== undefined ? manager : $267b85717c4872ea$export$e4a62db56fe87452;
        this.crossOrigin = 'anonymous';
        this.withCredentials = false;
        this.path = '';
        this.resourcePath = '';
        this.requestHeader = {
        };
    }
    load() {
    }
    loadAsync(url, onProgress) {
        const scope6 = this;
        return new Promise(function(resolve, reject) {
            scope6.load(url, resolve, onProgress, reject);
        });
    }
    parse() {
    }
    setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    }
    setWithCredentials(value) {
        this.withCredentials = value;
        return this;
    }
    setPath(path) {
        this.path = path;
        return this;
    }
    setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    }
    setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
}
const $267b85717c4872ea$var$loading = {
};
class $267b85717c4872ea$export$de6ef55ef3be029c extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager1){
        super(manager1);
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope6 = this;
        const cached = $267b85717c4872ea$export$7c17e0f15419affd.get(url);
        if (cached !== undefined) {
            scope6.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope6.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if ($267b85717c4872ea$var$loading[url] !== undefined) {
            $267b85717c4872ea$var$loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data4 = dataUriRegexResult[3];
            data4 = decodeURIComponent(data4);
            if (isBase64) data4 = atob(data4);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data4.length);
                        for(let i16 = 0; i16 < data4.length; i16++)view[i16] = data4.charCodeAt(i16);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data4, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data4);
                        break;
                    default:
                        response = data4;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope6.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope6.manager.itemError(url);
                    scope6.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            $267b85717c4872ea$var$loading[url] = [];
            $267b85717c4872ea$var$loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = $267b85717c4872ea$var$loading[url];
                delete $267b85717c4872ea$var$loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    $267b85717c4872ea$export$7c17e0f15419affd.add(url, response);
                    for(let i16 = 0, il = callbacks.length; i16 < il; i16++){
                        const callback = callbacks[i16];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope6.manager.itemEnd(url);
                } else {
                    for(let i16 = 0, il = callbacks.length; i16 < il; i16++){
                        const callback = callbacks[i16];
                        if (callback.onError) callback.onError(event);
                    }
                    scope6.manager.itemError(url);
                    scope6.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = $267b85717c4872ea$var$loading[url];
                for(let i16 = 0, il = callbacks.length; i16 < il; i16++){
                    const callback = callbacks[i16];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = $267b85717c4872ea$var$loading[url];
                delete $267b85717c4872ea$var$loading[url];
                for(let i16 = 0, il = callbacks.length; i16 < il; i16++){
                    const callback = callbacks[i16];
                    if (callback.onError) callback.onError(event);
                }
                scope6.manager.itemError(url);
                scope6.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = $267b85717c4872ea$var$loading[url];
                delete $267b85717c4872ea$var$loading[url];
                for(let i16 = 0, il = callbacks.length; i16 < il; i16++){
                    const callback = callbacks[i16];
                    if (callback.onError) callback.onError(event);
                }
                scope6.manager.itemError(url);
                scope6.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope6.manager.itemStart(url);
        return request;
    }
    setResponseType(value) {
        this.responseType = value;
        return this;
    }
    setMimeType(value) {
        this.mimeType = value;
        return this;
    }
}
class $267b85717c4872ea$export$2c29b95a2266fb8a extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager2){
        super(manager2);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope6.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope6.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const animations = [];
        for(let i16 = 0; i16 < json.length; i16++){
            const clip = $267b85717c4872ea$export$79ad2141f3423764.parse(json[i16]);
            animations.push(clip);
        }
        return animations;
    }
}
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class $267b85717c4872ea$export$58bcae49fbba6ead extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager3){
        super(manager3);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const images1 = [];
        const texture2 = new $267b85717c4872ea$export$be0b28729ca1f6c0();
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope6.withCredentials);
        let loaded = 0;
        function loadTexture(i16) {
            loader.load(url[i16], function(buffer) {
                const texDatas = scope6.parse(buffer, true);
                images1[i16] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture2.minFilter = $267b85717c4872ea$export$d8f3ba475551f5c1;
                    texture2.image = images1;
                    texture2.format = texDatas.format;
                    texture2.needsUpdate = true;
                    if (onLoad) onLoad(texture2);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i16 = 0, il = url.length; i16 < il; ++i16)loadTexture(i16);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope6.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images1[f] = {
                        mipmaps: []
                    };
                    for(let i17 = 0; i17 < texDatas.mipmapCount; i17++){
                        images1[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i17]);
                        images1[f].format = texDatas.format;
                        images1[f].width = texDatas.width;
                        images1[f].height = texDatas.height;
                    }
                }
                texture2.image = images1;
            } else {
                texture2.image.width = texDatas.width;
                texture2.image.height = texDatas.height;
                texture2.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture2.minFilter = $267b85717c4872ea$export$d8f3ba475551f5c1;
            texture2.format = texDatas.format;
            texture2.needsUpdate = true;
            if (onLoad) onLoad(texture2);
        }, onProgress, onError);
        return texture2;
    }
}
class $267b85717c4872ea$export$39150bb19f4dc1ac extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager4){
        super(manager4);
    }
    load(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope6 = this;
        const cached = $267b85717c4872ea$export$7c17e0f15419affd.get(url);
        if (cached !== undefined) {
            scope6.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope6.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image1 = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image1.removeEventListener('load', onImageLoad, false);
            image1.removeEventListener('error', onImageError, false);
            $267b85717c4872ea$export$7c17e0f15419affd.add(url, this);
            if (onLoad) onLoad(this);
            scope6.manager.itemEnd(url);
        }
        function onImageError(event) {
            image1.removeEventListener('load', onImageLoad, false);
            image1.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope6.manager.itemError(url);
            scope6.manager.itemEnd(url);
        }
        image1.addEventListener('load', onImageLoad, false);
        image1.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image1.crossOrigin = this.crossOrigin;
        }
        scope6.manager.itemStart(url);
        image1.src = url;
        return image1;
    }
}
class $267b85717c4872ea$export$ef8b534c169b03e2 extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager5){
        super(manager5);
    }
    load(urls, onLoad, onProgress, onError) {
        const texture2 = new $267b85717c4872ea$export$2093b765bab902d5();
        const loader = new $267b85717c4872ea$export$39150bb19f4dc1ac(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i16) {
            loader.load(urls[i16], function(image1) {
                texture2.images[i16] = image1;
                loaded++;
                if (loaded === 6) {
                    texture2.needsUpdate = true;
                    if (onLoad) onLoad(texture2);
                }
            }, undefined, onError);
        }
        for(let i16 = 0; i16 < urls.length; ++i16)loadTexture(i16);
        return texture2;
    }
}
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */ class $267b85717c4872ea$export$9409c5fcd4393162 extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager6){
        super(manager6);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const texture2 = new $267b85717c4872ea$export$2c21e84929b149b4();
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope6.withCredentials);
        loader.load(url, function(buffer) {
            const texData = scope6.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture2.image = texData.image;
            else if (texData.data !== undefined) {
                texture2.image.width = texData.width;
                texture2.image.height = texData.height;
                texture2.image.data = texData.data;
            }
            texture2.wrapS = texData.wrapS !== undefined ? texData.wrapS : $267b85717c4872ea$export$73b90a84ed7db63c;
            texture2.wrapT = texData.wrapT !== undefined ? texData.wrapT : $267b85717c4872ea$export$73b90a84ed7db63c;
            texture2.magFilter = texData.magFilter !== undefined ? texData.magFilter : $267b85717c4872ea$export$d8f3ba475551f5c1;
            texture2.minFilter = texData.minFilter !== undefined ? texData.minFilter : $267b85717c4872ea$export$d8f3ba475551f5c1;
            texture2.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.encoding !== undefined) texture2.encoding = texData.encoding;
            if (texData.flipY !== undefined) texture2.flipY = texData.flipY;
            if (texData.format !== undefined) texture2.format = texData.format;
            if (texData.type !== undefined) texture2.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture2.mipmaps = texData.mipmaps;
                texture2.minFilter = $267b85717c4872ea$export$f4f4190ac785556; // presumably...
            }
            if (texData.mipmapCount === 1) texture2.minFilter = $267b85717c4872ea$export$d8f3ba475551f5c1;
            if (texData.generateMipmaps !== undefined) texture2.generateMipmaps = texData.generateMipmaps;
            texture2.needsUpdate = true;
            if (onLoad) onLoad(texture2, texData);
        }, onProgress, onError);
        return texture2;
    }
}
class $267b85717c4872ea$export$b1cf4a115f3af368 extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager7){
        super(manager7);
    }
    load(url, onLoad, onProgress, onError) {
        const texture2 = new $267b85717c4872ea$export$1cad442f1a6e549f();
        const loader = new $267b85717c4872ea$export$39150bb19f4dc1ac(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image1) {
            texture2.image = image1;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture2.format = isJPEG ? $267b85717c4872ea$export$cb1f224ebfa17eab : $267b85717c4872ea$export$fdd3489947276d08;
            texture2.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture2);
        }, onProgress, onError);
        return texture2;
    }
}
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/ class $267b85717c4872ea$export$111ffa88cdd487ec extends $267b85717c4872ea$export$c94d58bf7a3bdecc {
    constructor(){
        super();
        this.type = 'CurvePath';
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    }
    add(curve) {
        this.curves.push(curve);
    }
    closePath() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new $267b85717c4872ea$export$b37bb8298f497da0(endPoint, startPoint));
    }
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint(t) {
        const d = t * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i16 = 0;
        // To think about boundaries points.
        while(i16 < curveLengths.length){
            if (curveLengths[i16] >= d) {
                const diff = curveLengths[i16] - d;
                const curve = this.curves[i16];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i16++;
        }
        return null;
    // loop where sum != 0, sum > d , sum+1 <d
    }
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    }
    // cacheLengths must be recalculated.
    updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    }
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i16 = 0, l1 = this.curves.length; i16 < l1; i16++){
            sums += this.curves[i16].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    }
    getSpacedPoints(divisions = 40) {
        const points3 = [];
        for(let i16 = 0; i16 <= divisions; i16++)points3.push(this.getPoint(i16 / divisions));
        if (this.autoClose) points3.push(points3[0]);
        return points3;
    }
    getPoints(divisions = 12) {
        const points3 = [];
        let last;
        for(let i16 = 0, curves = this.curves; i16 < curves.length; i16++){
            const curve = curves[i16];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j7 = 0; j7 < pts.length; j7++){
                const point = pts[j7];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points3.push(point);
                last = point;
            }
        }
        if (this.autoClose && points3.length > 1 && !points3[points3.length - 1].equals(points3[0])) points3.push(points3[0]);
        return points3;
    }
    copy(source) {
        super.copy(source);
        this.curves = [];
        for(let i16 = 0, l1 = source.curves.length; i16 < l1; i16++){
            const curve = source.curves[i16];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.autoClose = this.autoClose;
        data4.curves = [];
        for(let i16 = 0, l1 = this.curves.length; i16 < l1; i16++){
            const curve = this.curves[i16];
            data4.curves.push(curve.toJSON());
        }
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i16 = 0, l1 = json.curves.length; i16 < l1; i16++){
            const curve = json.curves[i16];
            this.curves.push(new $267b85717c4872ea$var$Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
}
class $267b85717c4872ea$export$49a62d21c8b8d137 extends $267b85717c4872ea$export$111ffa88cdd487ec {
    constructor(points3){
        super();
        this.type = 'Path';
        this.currentPoint = new $267b85717c4872ea$export$95d9e1e745cc7977();
        if (points3) this.setFromPoints(points3);
    }
    setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for(let i16 = 1, l1 = points.length; i16 < l1; i16++)this.lineTo(points[i16].x, points[i16].y);
        return this;
    }
    moveTo(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
        return this;
    }
    lineTo(x, y) {
        const curve = new $267b85717c4872ea$export$b37bb8298f497da0(this.currentPoint.clone(), new $267b85717c4872ea$export$95d9e1e745cc7977(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new $267b85717c4872ea$export$27134e4b5096519e(this.currentPoint.clone(), new $267b85717c4872ea$export$95d9e1e745cc7977(aCPx, aCPy), new $267b85717c4872ea$export$95d9e1e745cc7977(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new $267b85717c4872ea$export$95a2cec5c7146264(this.currentPoint.clone(), new $267b85717c4872ea$export$95d9e1e745cc7977(aCP1x, aCP1y), new $267b85717c4872ea$export$95d9e1e745cc7977(aCP2x, aCP2y), new $267b85717c4872ea$export$95d9e1e745cc7977(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    }
    splineThru(pts /*Array of Vector*/ ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new $267b85717c4872ea$export$d384af114ea096f(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new $267b85717c4872ea$export$fd6fa092b321e4ba(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    }
    copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.currentPoint = this.currentPoint.toArray();
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
}
class $267b85717c4872ea$export$5d9987e6723d242f extends $267b85717c4872ea$export$49a62d21c8b8d137 {
    constructor(points5){
        super(points5);
        this.uuid = $267b85717c4872ea$var$generateUUID();
        this.type = 'Shape';
        this.holes = [];
    }
    getPointsHoles(divisions) {
        const holesPts = [];
        for(let i16 = 0, l1 = this.holes.length; i16 < l1; i16++)holesPts[i16] = this.holes[i16].getPoints(divisions);
        return holesPts;
    }
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    }
    copy(source) {
        super.copy(source);
        this.holes = [];
        for(let i16 = 0, l1 = source.holes.length; i16 < l1; i16++){
            const hole = source.holes[i16];
            this.holes.push(hole.clone());
        }
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.uuid = this.uuid;
        data4.holes = [];
        for(let i16 = 0, l1 = this.holes.length; i16 < l1; i16++){
            const hole = this.holes[i16];
            data4.holes.push(hole.toJSON());
        }
        return data4;
    }
    fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i16 = 0, l1 = json.holes.length; i16 < l1; i16++){
            const hole = json.holes[i16];
            this.holes.push(new $267b85717c4872ea$export$49a62d21c8b8d137().fromJSON(hole));
        }
        return this;
    }
}
class $267b85717c4872ea$export$d5415290bbbd757d extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(color3, intensity = 1){
        super();
        this.type = 'Light';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d(color3);
        this.intensity = intensity;
    }
    dispose() {
    // Empty here in base class; some subclasses override.
    }
    copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    }
    toJSON(meta) {
        const data4 = super.toJSON(meta);
        data4.object.color = this.color.getHex();
        data4.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data4.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data4.object.distance = this.distance;
        if (this.angle !== undefined) data4.object.angle = this.angle;
        if (this.decay !== undefined) data4.object.decay = this.decay;
        if (this.penumbra !== undefined) data4.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data4.object.shadow = this.shadow.toJSON();
        return data4;
    }
}
$267b85717c4872ea$export$d5415290bbbd757d.prototype.isLight = true;
class $267b85717c4872ea$export$4b2cb6740e099c0f extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(skyColor, groundColor, intensity1){
        super(skyColor, intensity1);
        this.type = 'HemisphereLight';
        this.position.copy($267b85717c4872ea$export$c8ea94beaa33360.DefaultUp);
        this.updateMatrix();
        this.groundColor = new $267b85717c4872ea$export$e4830c8e55b4f80d(groundColor);
    }
    copy(source) {
        $267b85717c4872ea$export$d5415290bbbd757d.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
}
$267b85717c4872ea$export$4b2cb6740e099c0f.prototype.isHemisphereLight = true;
const $267b85717c4872ea$var$_projScreenMatrix$1 = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_lightPositionWorld$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_lookTarget$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$var$LightShadow {
    constructor(camera1){
        this.camera = camera1;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.mapSize = new $267b85717c4872ea$export$95d9e1e745cc7977(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new $267b85717c4872ea$export$960b1460cb9cd6c9();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new $267b85717c4872ea$export$6ef72105b8c3e2c6();
        this._frameExtents = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
        this._viewportCount = 1;
        this._viewports = [
            new $267b85717c4872ea$export$14dfcb76afe97063(0, 0, 1, 1)
        ];
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        $267b85717c4872ea$var$_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy($267b85717c4872ea$var$_lightPositionWorld$1);
        $267b85717c4872ea$var$_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt($267b85717c4872ea$var$_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        $267b85717c4872ea$var$_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix($267b85717c4872ea$var$_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        if (this.map) this.map.dispose();
        if (this.mapPass) this.mapPass.dispose();
    }
    copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const object = {
        };
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
}
class $267b85717c4872ea$var$SpotLightShadow extends $267b85717c4872ea$var$LightShadow {
    constructor(){
        super(new $267b85717c4872ea$export$95bab1c599905cc4(50, 1, 0.5, 500));
        this.focus = 1;
    }
    updateMatrices(light) {
        const camera1 = this.camera;
        const fov1 = $267b85717c4872ea$var$RAD2DEG * 2 * light.angle * this.focus;
        const aspect1 = this.mapSize.width / this.mapSize.height;
        const far3 = light.distance || camera1.far;
        if (fov1 !== camera1.fov || aspect1 !== camera1.aspect || far3 !== camera1.far) {
            camera1.fov = fov1;
            camera1.aspect = aspect1;
            camera1.far = far3;
            camera1.updateProjectionMatrix();
        }
        super.updateMatrices(light);
    }
    copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
    }
}
$267b85717c4872ea$var$SpotLightShadow.prototype.isSpotLightShadow = true;
class $267b85717c4872ea$export$41ae9a00ee4021c9 extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(color4, intensity2, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1){
        super(color4, intensity2);
        this.type = 'SpotLight';
        this.position.copy($267b85717c4872ea$export$c8ea94beaa33360.DefaultUp);
        this.updateMatrix();
        this.target = new $267b85717c4872ea$export$c8ea94beaa33360();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay; // for physically correct lights, should be 2.
        this.shadow = new $267b85717c4872ea$var$SpotLightShadow();
    }
    get power() {
        // intensity = power per solid angle.
        // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        return this.intensity * Math.PI;
    }
    set power(power) {
        // intensity = power per solid angle.
        // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        this.intensity = power / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
$267b85717c4872ea$export$41ae9a00ee4021c9.prototype.isSpotLight = true;
const $267b85717c4872ea$var$_projScreenMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_lightPositionWorld = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_lookTarget = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$var$PointLightShadow extends $267b85717c4872ea$var$LightShadow {
    constructor(){
        super(new $267b85717c4872ea$export$95bab1c599905cc4(90, 1, 0.5, 500));
        this._frameExtents = new $267b85717c4872ea$export$95d9e1e745cc7977(4, 2);
        this._viewportCount = 6;
        this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
            // positive X
            new $267b85717c4872ea$export$14dfcb76afe97063(2, 1, 1, 1),
            // negative X
            new $267b85717c4872ea$export$14dfcb76afe97063(0, 1, 1, 1),
            // positive Z
            new $267b85717c4872ea$export$14dfcb76afe97063(3, 1, 1, 1),
            // negative Z
            new $267b85717c4872ea$export$14dfcb76afe97063(1, 1, 1, 1),
            // positive Y
            new $267b85717c4872ea$export$14dfcb76afe97063(3, 0, 1, 1),
            // negative Y
            new $267b85717c4872ea$export$14dfcb76afe97063(1, 0, 1, 1)
        ];
        this._cubeDirections = [
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 0, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-1, 0, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 1),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, -1),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, -1, 0)
        ];
        this._cubeUps = [
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 1),
            new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, -1)
        ];
    }
    updateMatrices(light, viewportIndex = 0) {
        const camera1 = this.camera;
        const shadowMatrix = this.matrix;
        const far3 = light.distance || camera1.far;
        if (far3 !== camera1.far) {
            camera1.far = far3;
            camera1.updateProjectionMatrix();
        }
        $267b85717c4872ea$var$_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera1.position.copy($267b85717c4872ea$var$_lightPositionWorld);
        $267b85717c4872ea$var$_lookTarget.copy(camera1.position);
        $267b85717c4872ea$var$_lookTarget.add(this._cubeDirections[viewportIndex]);
        camera1.up.copy(this._cubeUps[viewportIndex]);
        camera1.lookAt($267b85717c4872ea$var$_lookTarget);
        camera1.updateMatrixWorld();
        shadowMatrix.makeTranslation(-$267b85717c4872ea$var$_lightPositionWorld.x, -$267b85717c4872ea$var$_lightPositionWorld.y, -$267b85717c4872ea$var$_lightPositionWorld.z);
        $267b85717c4872ea$var$_projScreenMatrix.multiplyMatrices(camera1.projectionMatrix, camera1.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix($267b85717c4872ea$var$_projScreenMatrix);
    }
}
$267b85717c4872ea$var$PointLightShadow.prototype.isPointLightShadow = true;
class $267b85717c4872ea$export$7a2f9f523705113e extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(color5, intensity3, distance1 = 0, decay1 = 1){
        super(color5, intensity3);
        this.type = 'PointLight';
        this.distance = distance1;
        this.decay = decay1; // for physically correct lights, should be 2.
        this.shadow = new $267b85717c4872ea$var$PointLightShadow();
    }
    get power() {
        // intensity = power per solid angle.
        // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        return this.intensity * 4 * Math.PI;
    }
    set power(power) {
        // intensity = power per solid angle.
        // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
        this.intensity = power / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
}
$267b85717c4872ea$export$7a2f9f523705113e.prototype.isPointLight = true;
class $267b85717c4872ea$export$a38f6f1a088d3096 extends $267b85717c4872ea$export$d193d689dcf22ce8 {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near3 = 0.1, far3 = 2000){
        super();
        this.type = 'OrthographicCamera';
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near3;
        this.far = far3;
        this.updateProjectionMatrix();
    }
    copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        return this;
    }
    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left1 = cx - dx;
        let right1 = cx + dx;
        let top1 = cy + dy;
        let bottom1 = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left1 += scaleW * this.view.offsetX;
            right1 = left1 + scaleW * this.view.width;
            top1 -= scaleH * this.view.offsetY;
            bottom1 = top1 - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left1, right1, top1, bottom1, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
        const data4 = super.toJSON(meta);
        data4.object.zoom = this.zoom;
        data4.object.left = this.left;
        data4.object.right = this.right;
        data4.object.top = this.top;
        data4.object.bottom = this.bottom;
        data4.object.near = this.near;
        data4.object.far = this.far;
        if (this.view !== null) data4.object.view = Object.assign({
        }, this.view);
        return data4;
    }
}
$267b85717c4872ea$export$a38f6f1a088d3096.prototype.isOrthographicCamera = true;
class $267b85717c4872ea$var$DirectionalLightShadow extends $267b85717c4872ea$var$LightShadow {
    constructor(){
        super(new $267b85717c4872ea$export$a38f6f1a088d3096(-5, 5, 5, -5, 0.5, 500));
    }
}
$267b85717c4872ea$var$DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
class $267b85717c4872ea$export$2d57c52c960d9d44 extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(color6, intensity4){
        super(color6, intensity4);
        this.type = 'DirectionalLight';
        this.position.copy($267b85717c4872ea$export$c8ea94beaa33360.DefaultUp);
        this.updateMatrix();
        this.target = new $267b85717c4872ea$export$c8ea94beaa33360();
        this.shadow = new $267b85717c4872ea$var$DirectionalLightShadow();
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
}
$267b85717c4872ea$export$2d57c52c960d9d44.prototype.isDirectionalLight = true;
class $267b85717c4872ea$export$c1424cb85ae54a6d extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(color7, intensity5){
        super(color7, intensity5);
        this.type = 'AmbientLight';
    }
}
$267b85717c4872ea$export$c1424cb85ae54a6d.prototype.isAmbientLight = true;
class $267b85717c4872ea$export$9cd9c4d58100b370 extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(color8, intensity6, width11 = 10, height13 = 10){
        super(color8, intensity6);
        this.type = 'RectAreaLight';
        this.width = width11;
        this.height = height13;
    }
    copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
    }
    toJSON(meta) {
        const data4 = super.toJSON(meta);
        data4.object.width = this.width;
        data4.object.height = this.height;
        return data4;
    }
}
$267b85717c4872ea$export$9cd9c4d58100b370.prototype.isRectAreaLight = true;
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
class $267b85717c4872ea$export$e6e1a499301960ff {
    constructor(){
        this.coefficients = [];
        for(let i16 = 0; i16 < 9; i16++)this.coefficients.push(new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2());
    }
    set(coefficients) {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].copy(coefficients[i17]);
        return this;
    }
    zero() {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].set(0, 0, 0);
        return this;
    }
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt(normal, target) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y6);
        target.addScaledVector(coeff[2], 0.488603 * z5);
        target.addScaledVector(coeff[3], 0.488603 * x6);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x6 * y6));
        target.addScaledVector(coeff[5], 1.092548 * (y6 * z5));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z5 * z5 - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x6 * z5));
        target.addScaledVector(coeff[8], 0.546274 * (x6 * x6 - y6 * y6));
        return target;
    }
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt(normal, target) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y6); // ( 2 * π / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z5);
        target.addScaledVector(coeff[3], 1.023328 * x6);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x6 * y6); // ( π / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y6 * z5);
        target.addScaledVector(coeff[6], 0.743125 * z5 * z5 - 0.247708); // ( π / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x6 * z5);
        target.addScaledVector(coeff[8], 0.429043 * (x6 * x6 - y6 * y6)); // ( π / 4 ) * 0.546274
        return target;
    }
    add(sh) {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].add(sh.coefficients[i17]);
        return this;
    }
    addScaledSH(sh, s) {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].addScaledVector(sh.coefficients[i17], s);
        return this;
    }
    scale(s) {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].multiplyScalar(s);
        return this;
    }
    lerp(sh, alpha) {
        for(let i17 = 0; i17 < 9; i17++)this.coefficients[i17].lerp(sh.coefficients[i17], alpha);
        return this;
    }
    equals(sh) {
        for(let i17 = 0; i17 < 9; i17++){
            if (!this.coefficients[i17].equals(sh.coefficients[i17])) return false;
        }
        return true;
    }
    copy(sh) {
        return this.set(sh.coefficients);
    }
    clone() {
        return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for(let i17 = 0; i17 < 9; i17++)coefficients[i17].fromArray(array, offset + i17 * 3);
        return this;
    }
    toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for(let i17 = 0; i17 < 9; i17++)coefficients[i17].toArray(array, offset + i17 * 3);
        return array;
    }
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    static getBasisAt(normal, shBasis) {
        // normal is assumed to be unit length
        const x6 = normal.x, y6 = normal.y, z5 = normal.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y6;
        shBasis[2] = 0.488603 * z5;
        shBasis[3] = 0.488603 * x6;
        // band 2
        shBasis[4] = 1.092548 * x6 * y6;
        shBasis[5] = 1.092548 * y6 * z5;
        shBasis[6] = 0.315392 * (3 * z5 * z5 - 1);
        shBasis[7] = 1.092548 * x6 * z5;
        shBasis[8] = 0.546274 * (x6 * x6 - y6 * y6);
    }
}
$267b85717c4872ea$export$e6e1a499301960ff.prototype.isSphericalHarmonics3 = true;
class $267b85717c4872ea$export$1b810fb0fc316ea2 extends $267b85717c4872ea$export$d5415290bbbd757d {
    constructor(sh = new $267b85717c4872ea$export$e6e1a499301960ff(), intensity7 = 1){
        super(undefined, intensity7);
        this.sh = sh;
    }
    copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
    }
    fromJSON(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    }
    toJSON(meta) {
        const data4 = super.toJSON(meta);
        data4.object.sh = this.sh.toArray();
        return data4;
    }
}
$267b85717c4872ea$export$1b810fb0fc316ea2.prototype.isLightProbe = true;
class $267b85717c4872ea$export$6e08e0c49c53f9d5 extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager8){
        super(manager8);
        this.textures = {
        };
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(scope6.manager);
        loader.setPath(scope6.path);
        loader.setRequestHeader(scope6.requestHeader);
        loader.setWithCredentials(scope6.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope6.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope6.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const textures = this.textures;
        function getTexture(name3) {
            if (textures[name3] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name3);
            return textures[name3];
        }
        const material8 = new $267b85717c4872ea$var$Materials[json.type]();
        if (json.uuid !== undefined) material8.uuid = json.uuid;
        if (json.name !== undefined) material8.name = json.name;
        if (json.color !== undefined && material8.color !== undefined) material8.color.setHex(json.color);
        if (json.roughness !== undefined) material8.roughness = json.roughness;
        if (json.metalness !== undefined) material8.metalness = json.metalness;
        if (json.sheen !== undefined) material8.sheen = new $267b85717c4872ea$export$e4830c8e55b4f80d().setHex(json.sheen);
        if (json.emissive !== undefined && material8.emissive !== undefined) material8.emissive.setHex(json.emissive);
        if (json.specular !== undefined && material8.specular !== undefined) material8.specular.setHex(json.specular);
        if (json.shininess !== undefined) material8.shininess = json.shininess;
        if (json.clearcoat !== undefined) material8.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material8.clearcoatRoughness = json.clearcoatRoughness;
        if (json.transmission !== undefined) material8.transmission = json.transmission;
        if (json.thickness !== undefined) material8.thickness = json.thickness;
        if (json.attenuationDistance !== undefined) material8.attenuationDistance = json.attenuationDistance;
        if (json.attenuationColor !== undefined && material8.attenuationColor !== undefined) material8.attenuationColor.setHex(json.attenuationColor);
        if (json.fog !== undefined) material8.fog = json.fog;
        if (json.flatShading !== undefined) material8.flatShading = json.flatShading;
        if (json.blending !== undefined) material8.blending = json.blending;
        if (json.combine !== undefined) material8.combine = json.combine;
        if (json.side !== undefined) material8.side = json.side;
        if (json.shadowSide !== undefined) material8.shadowSide = json.shadowSide;
        if (json.opacity !== undefined) material8.opacity = json.opacity;
        if (json.transparent !== undefined) material8.transparent = json.transparent;
        if (json.alphaTest !== undefined) material8.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material8.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material8.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material8.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material8.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material8.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material8.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material8.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material8.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material8.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material8.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material8.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material8.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material8.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material8.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material8.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material8.rotation = json.rotation;
        if (json.linewidth !== 1) material8.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material8.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material8.gapSize = json.gapSize;
        if (json.scale !== undefined) material8.scale = json.scale;
        if (json.polygonOffset !== undefined) material8.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material8.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material8.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.morphTargets !== undefined) material8.morphTargets = json.morphTargets;
        if (json.morphNormals !== undefined) material8.morphNormals = json.morphNormals;
        if (json.dithering !== undefined) material8.dithering = json.dithering;
        if (json.alphaToCoverage !== undefined) material8.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== undefined) material8.premultipliedAlpha = json.premultipliedAlpha;
        if (json.vertexTangents !== undefined) material8.vertexTangents = json.vertexTangents;
        if (json.visible !== undefined) material8.visible = json.visible;
        if (json.toneMapped !== undefined) material8.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material8.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material8.vertexColors = json.vertexColors > 0 ? true : false;
            else material8.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name3 in json.uniforms){
            const uniform = json.uniforms[name3];
            material8.uniforms[name3] = {
            };
            switch(uniform.type){
                case 't':
                    material8.uniforms[name3].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$e4830c8e55b4f80d().setHex(uniform.value);
                    break;
                case 'v2':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$95d9e1e745cc7977().fromArray(uniform.value);
                    break;
                case 'v3':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2().fromArray(uniform.value);
                    break;
                case 'v4':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$14dfcb76afe97063().fromArray(uniform.value);
                    break;
                case 'm3':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$6b1dbb040148d435().fromArray(uniform.value);
                    break;
                case 'm4':
                    material8.uniforms[name3].value = new $267b85717c4872ea$export$960b1460cb9cd6c9().fromArray(uniform.value);
                    break;
                default:
                    material8.uniforms[name3].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material8.defines = json.defines;
        if (json.vertexShader !== undefined) material8.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material8.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key1 in json.extensions)material8.extensions[key1] = json.extensions[key1];
        // Deprecated
        if (json.shading !== undefined) material8.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material8.size = json.size;
        if (json.sizeAttenuation !== undefined) material8.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material8.map = getTexture(json.map);
        if (json.matcap !== undefined) material8.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material8.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material8.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material8.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material8.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material8.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material8.normalScale = new $267b85717c4872ea$export$95d9e1e745cc7977().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material8.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material8.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material8.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material8.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material8.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material8.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material8.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material8.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material8.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material8.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material8.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material8.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material8.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material8.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material8.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material8.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material8.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material8.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material8.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material8.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material8.clearcoatNormalScale = new $267b85717c4872ea$export$95d9e1e745cc7977().fromArray(json.clearcoatNormalScale);
        if (json.transmissionMap !== undefined) material8.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== undefined) material8.thicknessMap = getTexture(json.thicknessMap);
        return material8;
    }
    setTextures(value) {
        this.textures = value;
        return this;
    }
}
class $267b85717c4872ea$export$ca1479a24257f322 {
    static decodeText(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s2 = '';
        for(let i17 = 0, il = array.length; i17 < il; i17++)// Implicitly assumes little-endian.
        s2 += String.fromCharCode(array[i17]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s2));
        } catch (e) {
            return s2;
        }
    }
    static extractUrlBase(url) {
        const index3 = url.lastIndexOf('/');
        if (index3 === -1) return './';
        return url.substr(0, index3 + 1);
    }
}
class $267b85717c4872ea$export$16af4cb53a07e609 extends $267b85717c4872ea$export$84a34b4c8ecb6751 {
    constructor(){
        super();
        this.type = 'InstancedBufferGeometry';
        this.instanceCount = Infinity;
    }
    copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    toJSON() {
        const data4 = super.toJSON(this);
        data4.instanceCount = this.instanceCount;
        data4.isInstancedBufferGeometry = true;
        return data4;
    }
}
$267b85717c4872ea$export$16af4cb53a07e609.prototype.isInstancedBufferGeometry = true;
class $267b85717c4872ea$export$43b0106809e92336 extends $267b85717c4872ea$export$3d45483f125de856 {
    constructor(array14, itemSize12, normalized12, meshPerAttribute = 1){
        if (typeof normalized12 === 'number') {
            meshPerAttribute = normalized12;
            normalized12 = false;
            console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
        }
        super(array14, itemSize12, normalized12);
        this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    toJSON() {
        const data4 = super.toJSON();
        data4.meshPerAttribute = this.meshPerAttribute;
        data4.isInstancedBufferAttribute = true;
        return data4;
    }
}
$267b85717c4872ea$export$43b0106809e92336.prototype.isInstancedBufferAttribute = true;
class $267b85717c4872ea$export$570f99ad92b247cd extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager9){
        super(manager9);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(scope6.manager);
        loader.setPath(scope6.path);
        loader.setRequestHeader(scope6.requestHeader);
        loader.setWithCredentials(scope6.withCredentials);
        loader.load(url, function(text1) {
            try {
                onLoad(scope6.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope6.manager.itemError(url);
            }
        }, onProgress, onError);
    }
    parse(json) {
        const interleavedBufferMap = {
        };
        const arrayBufferMap = {
        };
        function getInterleavedBuffer(json, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json.interleavedBuffers;
            const interleavedBuffer1 = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json, interleavedBuffer1.buffer);
            const array15 = $267b85717c4872ea$var$getTypedArray(interleavedBuffer1.type, buffer);
            const ib = new $267b85717c4872ea$export$a310785f1020d6c0(array15, interleavedBuffer1.stride);
            ib.uuid = interleavedBuffer1.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry9 = json.isInstancedBufferGeometry ? new $267b85717c4872ea$export$16af4cb53a07e609() : new $267b85717c4872ea$export$84a34b4c8ecb6751();
        const index3 = json.data.index;
        if (index3 !== undefined) {
            const typedArray = $267b85717c4872ea$var$getTypedArray(index3.type, index3.array);
            geometry9.setIndex(new $267b85717c4872ea$export$3d45483f125de856(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for(const key1 in attributes){
            const attribute = attributes[key1];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer1 = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new $267b85717c4872ea$export$4f3b28b17d7a2b98(interleavedBuffer1, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = $267b85717c4872ea$var$getTypedArray(attribute.type, attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? $267b85717c4872ea$export$43b0106809e92336 : $267b85717c4872ea$export$3d45483f125de856;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
            if (attribute.updateRange !== undefined) {
                bufferAttribute.updateRange.offset = attribute.updateRange.offset;
                bufferAttribute.updateRange.count = attribute.updateRange.count;
            }
            geometry9.setAttribute(key1, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) for(const key2 in morphAttributes){
            const attributeArray = morphAttributes[key2];
            const array15 = [];
            for(let i17 = 0, il = attributeArray.length; i17 < il; i17++){
                const attribute = attributeArray[i17];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer1 = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new $267b85717c4872ea$export$4f3b28b17d7a2b98(interleavedBuffer1, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = $267b85717c4872ea$var$getTypedArray(attribute.type, attribute.array);
                    bufferAttribute = new $267b85717c4872ea$export$3d45483f125de856(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array15.push(bufferAttribute);
            }
            geometry9.morphAttributes[key2] = array15;
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry9.morphTargetsRelative = true;
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) for(let i17 = 0, n = groups.length; i17 !== n; ++i17){
            const group = groups[i17];
            geometry9.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
            if (boundingSphere.center !== undefined) center3.fromArray(boundingSphere.center);
            geometry9.boundingSphere = new $267b85717c4872ea$export$48b052fa5734fd42(center3, boundingSphere.radius);
        }
        if (json.name) geometry9.name = json.name;
        if (json.userData) geometry9.userData = json.userData;
        return geometry9;
    }
}
class $267b85717c4872ea$export$d0207755cfd785cb extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager10){
        super(manager10);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const path2 = this.path === '' ? $267b85717c4872ea$export$ca1479a24257f322.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path2;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(text1) {
            let json = null;
            try {
                json = JSON.parse(text1);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                return;
            }
            scope6.parse(json, onLoad);
        }, onProgress, onError);
    }
    async loadAsync(url, onProgress) {
        const scope6 = this;
        const path2 = this.path === '' ? $267b85717c4872ea$export$ca1479a24257f322.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path2;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        const text1 = await loader.loadAsync(url, onProgress);
        const json = JSON.parse(text1);
        const metadata = json.metadata;
        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
        return await scope6.parseAsync(json);
    }
    parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes4 = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes4);
        const images1 = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images1);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        //
        if (onLoad !== undefined) {
            let hasImages = false;
            for(const uuid in images1)if (images1[uuid] instanceof HTMLImageElement) {
                hasImages = true;
                break;
            }
            if (hasImages === false) onLoad(object);
        }
        return object;
    }
    async parseAsync(json) {
        const animations = this.parseAnimations(json.animations);
        const shapes4 = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes4);
        const images1 = await this.parseImagesAsync(json.images);
        const textures = this.parseTextures(json.textures, images1);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        return object;
    }
    parseShapes(json) {
        const shapes4 = {
        };
        if (json !== undefined) for(let i17 = 0, l1 = json.length; i17 < l1; i17++){
            const shape = new $267b85717c4872ea$export$5d9987e6723d242f().fromJSON(json[i17]);
            shapes4[shape.uuid] = shape;
        }
        return shapes4;
    }
    parseSkeletons(json, object) {
        const skeletons = {
        };
        const bones2 = {
        };
        // generate bone lookup table
        object.traverse(function(child) {
            if (child.isBone) bones2[child.uuid] = child;
        });
        // create skeletons
        if (json !== undefined) for(let i17 = 0, l1 = json.length; i17 < l1; i17++){
            const skeleton = new $267b85717c4872ea$export$5f835f44a1f55563().fromJSON(json[i17], bones2);
            skeletons[skeleton.uuid] = skeleton;
        }
        return skeletons;
    }
    parseGeometries(json, shapes) {
        const geometries = {
        };
        if (json !== undefined) {
            const bufferGeometryLoader = new $267b85717c4872ea$export$570f99ad92b247cd();
            for(let i17 = 0, l1 = json.length; i17 < l1; i17++){
                let geometry9;
                const data4 = json[i17];
                switch(data4.type){
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        geometry9 = bufferGeometryLoader.parse(data4);
                        break;
                    case 'Geometry':
                        console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
                        break;
                    default:
                        if (data4.type in $267b85717c4872ea$var$Geometries) geometry9 = $267b85717c4872ea$var$Geometries[data4.type].fromJSON(data4, shapes);
                        else console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data4.type}"`);
                }
                geometry9.uuid = data4.uuid;
                if (data4.name !== undefined) geometry9.name = data4.name;
                if (geometry9.isBufferGeometry === true && data4.userData !== undefined) geometry9.userData = data4.userData;
                geometries[data4.uuid] = geometry9;
            }
        }
        return geometries;
    }
    parseMaterials(json, textures) {
        const cache = {
        }; // MultiMaterial
        const materials = {
        };
        if (json !== undefined) {
            const loader = new $267b85717c4872ea$export$6e08e0c49c53f9d5();
            loader.setTextures(textures);
            for(let i17 = 0, l1 = json.length; i17 < l1; i17++){
                const data4 = json[i17];
                if (data4.type === 'MultiMaterial') {
                    // Deprecated
                    const array15 = [];
                    for(let j7 = 0; j7 < data4.materials.length; j7++){
                        const material8 = data4.materials[j7];
                        if (cache[material8.uuid] === undefined) cache[material8.uuid] = loader.parse(material8);
                        array15.push(cache[material8.uuid]);
                    }
                    materials[data4.uuid] = array15;
                } else {
                    if (cache[data4.uuid] === undefined) cache[data4.uuid] = loader.parse(data4);
                    materials[data4.uuid] = cache[data4.uuid];
                }
            }
        }
        return materials;
    }
    parseAnimations(json) {
        const animations = {
        };
        if (json !== undefined) for(let i17 = 0; i17 < json.length; i17++){
            const data4 = json[i17];
            const clip = $267b85717c4872ea$export$79ad2141f3423764.parse(data4);
            animations[clip.uuid] = clip;
        }
        return animations;
    }
    parseImages(json, onLoad) {
        const scope6 = this;
        const images1 = {
        };
        let loader;
        function loadImage(url) {
            scope6.manager.itemStart(url);
            return loader.load(url, function() {
                scope6.manager.itemEnd(url);
            }, undefined, function() {
                scope6.manager.itemError(url);
                scope6.manager.itemEnd(url);
            });
        }
        function deserializeImage(image1) {
            if (typeof image1 === 'string') {
                const url = image1;
                const path2 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope6.resourcePath + url;
                return loadImage(path2);
            } else {
                if (image1.data) return {
                    data: $267b85717c4872ea$var$getTypedArray(image1.type, image1.data),
                    width: image1.width,
                    height: image1.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            const manager11 = new $267b85717c4872ea$export$53aaaf7fed9d16ee(onLoad);
            loader = new $267b85717c4872ea$export$39150bb19f4dc1ac(manager11);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i17 = 0, il = json.length; i17 < il; i17++){
                const image1 = json[i17];
                const url = image1.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images1[image1.uuid] = [];
                    for(let j7 = 0, jl = url.length; j7 < jl; j7++){
                        const currentUrl = url[j7];
                        const deserializedImage = deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) images1[image1.uuid].push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            images1[image1.uuid].push(new $267b85717c4872ea$export$2c21e84929b149b4(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                } else {
                    // load single image
                    const deserializedImage = deserializeImage(image1.url);
                    if (deserializedImage !== null) images1[image1.uuid] = deserializedImage;
                }
            }
        }
        return images1;
    }
    async parseImagesAsync(json) {
        const scope6 = this;
        const images1 = {
        };
        let loader;
        async function deserializeImage(image1) {
            if (typeof image1 === 'string') {
                const url = image1;
                const path2 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope6.resourcePath + url;
                return await loader.loadAsync(path2);
            } else {
                if (image1.data) return {
                    data: $267b85717c4872ea$var$getTypedArray(image1.type, image1.data),
                    width: image1.width,
                    height: image1.height
                };
                else return null;
            }
        }
        if (json !== undefined && json.length > 0) {
            loader = new $267b85717c4872ea$export$39150bb19f4dc1ac(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i17 = 0, il = json.length; i17 < il; i17++){
                const image1 = json[i17];
                const url = image1.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images1[image1.uuid] = [];
                    for(let j7 = 0, jl = url.length; j7 < jl; j7++){
                        const currentUrl = url[j7];
                        const deserializedImage = await deserializeImage(currentUrl);
                        if (deserializedImage !== null) {
                            if (deserializedImage instanceof HTMLImageElement) images1[image1.uuid].push(deserializedImage);
                            else // special case: handle array of data textures for cube textures
                            images1[image1.uuid].push(new $267b85717c4872ea$export$2c21e84929b149b4(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                        }
                    }
                } else {
                    // load single image
                    const deserializedImage = await deserializeImage(image1.url);
                    if (deserializedImage !== null) images1[image1.uuid] = deserializedImage;
                }
            }
        }
        return images1;
    }
    parseTextures(json, images) {
        function parseConstant(value, type7) {
            if (typeof value === 'number') return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type7[value];
        }
        const textures = {
        };
        if (json !== undefined) for(let i17 = 0, l1 = json.length; i17 < l1; i17++){
            const data4 = json[i17];
            if (data4.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data4.uuid);
            if (images[data4.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data4.image);
            let texture2;
            const image1 = images[data4.image];
            if (Array.isArray(image1)) {
                texture2 = new $267b85717c4872ea$export$2093b765bab902d5(image1);
                if (image1.length === 6) texture2.needsUpdate = true;
            } else {
                if (image1 && image1.data) texture2 = new $267b85717c4872ea$export$2c21e84929b149b4(image1.data, image1.width, image1.height);
                else texture2 = new $267b85717c4872ea$export$1cad442f1a6e549f(image1);
                if (image1) texture2.needsUpdate = true; // textures can have undefined image data
            }
            texture2.uuid = data4.uuid;
            if (data4.name !== undefined) texture2.name = data4.name;
            if (data4.mapping !== undefined) texture2.mapping = parseConstant(data4.mapping, $267b85717c4872ea$var$TEXTURE_MAPPING);
            if (data4.offset !== undefined) texture2.offset.fromArray(data4.offset);
            if (data4.repeat !== undefined) texture2.repeat.fromArray(data4.repeat);
            if (data4.center !== undefined) texture2.center.fromArray(data4.center);
            if (data4.rotation !== undefined) texture2.rotation = data4.rotation;
            if (data4.wrap !== undefined) {
                texture2.wrapS = parseConstant(data4.wrap[0], $267b85717c4872ea$var$TEXTURE_WRAPPING);
                texture2.wrapT = parseConstant(data4.wrap[1], $267b85717c4872ea$var$TEXTURE_WRAPPING);
            }
            if (data4.format !== undefined) texture2.format = data4.format;
            if (data4.type !== undefined) texture2.type = data4.type;
            if (data4.encoding !== undefined) texture2.encoding = data4.encoding;
            if (data4.minFilter !== undefined) texture2.minFilter = parseConstant(data4.minFilter, $267b85717c4872ea$var$TEXTURE_FILTER);
            if (data4.magFilter !== undefined) texture2.magFilter = parseConstant(data4.magFilter, $267b85717c4872ea$var$TEXTURE_FILTER);
            if (data4.anisotropy !== undefined) texture2.anisotropy = data4.anisotropy;
            if (data4.flipY !== undefined) texture2.flipY = data4.flipY;
            if (data4.premultiplyAlpha !== undefined) texture2.premultiplyAlpha = data4.premultiplyAlpha;
            if (data4.unpackAlignment !== undefined) texture2.unpackAlignment = data4.unpackAlignment;
            textures[data4.uuid] = texture2;
        }
        return textures;
    }
    parseObject(data, geometries, materials, textures, animations) {
        let object;
        function getGeometry(name3) {
            if (geometries[name3] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name3);
            return geometries[name3];
        }
        function getMaterial(name3) {
            if (name3 === undefined) return undefined;
            if (Array.isArray(name3)) {
                const array15 = [];
                for(let i17 = 0, l1 = name3.length; i17 < l1; i17++){
                    const uuid = name3[i17];
                    if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    array15.push(materials[uuid]);
                }
                return array15;
            }
            if (materials[name3] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name3);
            return materials[name3];
        }
        function getTexture(uuid) {
            if (textures[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined texture', uuid);
            return textures[uuid];
        }
        let geometry9, material8;
        switch(data.type){
            case 'Scene':
                object = new $267b85717c4872ea$export$df6b198c079ba70b();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new $267b85717c4872ea$export$e4830c8e55b4f80d(data.background);
                    else object.background = getTexture(data.background);
                }
                if (data.environment !== undefined) object.environment = getTexture(data.environment);
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') object.fog = new $267b85717c4872ea$export$2b17e0dd8f1837fc(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === 'FogExp2') object.fog = new $267b85717c4872ea$export$1a5869459dddfad8(data.fog.color, data.fog.density);
                }
                break;
            case 'PerspectiveCamera':
                object = new $267b85717c4872ea$export$95bab1c599905cc4(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'OrthographicCamera':
                object = new $267b85717c4872ea$export$a38f6f1a088d3096(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'AmbientLight':
                object = new $267b85717c4872ea$export$c1424cb85ae54a6d(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new $267b85717c4872ea$export$2d57c52c960d9d44(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new $267b85717c4872ea$export$7a2f9f523705113e(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'RectAreaLight':
                object = new $267b85717c4872ea$export$9cd9c4d58100b370(data.color, data.intensity, data.width, data.height);
                break;
            case 'SpotLight':
                object = new $267b85717c4872ea$export$41ae9a00ee4021c9(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new $267b85717c4872ea$export$4b2cb6740e099c0f(data.color, data.groundColor, data.intensity);
                break;
            case 'LightProbe':
                object = new $267b85717c4872ea$export$1b810fb0fc316ea2().fromJSON(data);
                break;
            case 'SkinnedMesh':
                geometry9 = getGeometry(data.geometry);
                material8 = getMaterial(data.material);
                object = new $267b85717c4872ea$export$5d42c2f029f93672(geometry9, material8);
                if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                break;
            case 'Mesh':
                geometry9 = getGeometry(data.geometry);
                material8 = getMaterial(data.material);
                object = new $267b85717c4872ea$export$4cdb671a7054bbf9(geometry9, material8);
                break;
            case 'InstancedMesh':
                geometry9 = getGeometry(data.geometry);
                material8 = getMaterial(data.material);
                const count3 = data.count;
                const instanceMatrix = data.instanceMatrix;
                const instanceColor = data.instanceColor;
                object = new $267b85717c4872ea$export$7e23ced5e91bc59e(geometry9, material8, count3);
                object.instanceMatrix = new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(instanceMatrix.array), 16);
                if (instanceColor !== undefined) object.instanceColor = new $267b85717c4872ea$export$3d45483f125de856(new Float32Array(instanceColor.array), instanceColor.itemSize);
                break;
            case 'LOD':
                object = new $267b85717c4872ea$export$1174c10a60977fe1();
                break;
            case 'Line':
                object = new $267b85717c4872ea$export$2034040bfbe12f9(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineLoop':
                object = new $267b85717c4872ea$export$46bbc9ce4fba3102(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineSegments':
                object = new $267b85717c4872ea$export$705b5dac58c594af(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new $267b85717c4872ea$export$fd24d21d3cd7fd59(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new $267b85717c4872ea$export$c01017fc2f0e32a2(getMaterial(data.material));
                break;
            case 'Group':
                object = new $267b85717c4872ea$export$a145e63780346cea();
                break;
            case 'Bone':
                object = new $267b85717c4872ea$export$bb2c3ec0717e2c8c();
                break;
            default:
                object = new $267b85717c4872ea$export$c8ea94beaa33360();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i17 = 0; i17 < children.length; i17++)object.add(this.parseObject(children[i17], geometries, materials, textures, animations));
        }
        if (data.animations !== undefined) {
            const objectAnimations = data.animations;
            for(let i17 = 0; i17 < objectAnimations.length; i17++){
                const uuid = objectAnimations[i17];
                object.animations.push(animations[uuid]);
            }
        }
        if (data.type === 'LOD') {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l1 = 0; l1 < levels.length; l1++){
                const level = levels[l1];
                const child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
    bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function(child) {
            if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                const skeleton = skeletons[child.skeleton];
                if (skeleton === undefined) console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                else child.bind(skeleton, child.bindMatrix);
            }
        });
    }
    /* DEPRECATED */ setTexturePath(value) {
        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
        return this.setResourcePath(value);
    }
}
const $267b85717c4872ea$var$TEXTURE_MAPPING = {
    UVMapping: $267b85717c4872ea$export$f5c72f32487b09db,
    CubeReflectionMapping: $267b85717c4872ea$export$14b9933b43601226,
    CubeRefractionMapping: $267b85717c4872ea$export$2be972fd003606e2,
    EquirectangularReflectionMapping: $267b85717c4872ea$export$2fcdd5238f6d0712,
    EquirectangularRefractionMapping: $267b85717c4872ea$export$84dcc0fe92473f5c,
    CubeUVReflectionMapping: $267b85717c4872ea$export$fb3ca8bcae285728,
    CubeUVRefractionMapping: $267b85717c4872ea$export$8be195802fe0213b
};
const $267b85717c4872ea$var$TEXTURE_WRAPPING = {
    RepeatWrapping: $267b85717c4872ea$export$7e167fb3a9a9867a,
    ClampToEdgeWrapping: $267b85717c4872ea$export$73b90a84ed7db63c,
    MirroredRepeatWrapping: $267b85717c4872ea$export$2dd54949bff6f96d
};
const $267b85717c4872ea$var$TEXTURE_FILTER = {
    NearestFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
    NearestMipmapNearestFilter: $267b85717c4872ea$export$3d857d6c85506f73,
    NearestMipmapLinearFilter: $267b85717c4872ea$export$977236fa8e8d0f1d,
    LinearFilter: $267b85717c4872ea$export$d8f3ba475551f5c1,
    LinearMipmapNearestFilter: $267b85717c4872ea$export$f8cffbbc87915209,
    LinearMipmapLinearFilter: $267b85717c4872ea$export$f4f4190ac785556
};
class $267b85717c4872ea$export$103c236346f4c973 extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager11){
        super(manager11);
        if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
        if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
        this.options = {
            premultiplyAlpha: 'none'
        };
    }
    setOptions(options) {
        this.options = options;
        return this;
    }
    load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope6 = this;
        const cached = $267b85717c4872ea$export$7c17e0f15419affd.get(url);
        if (cached !== undefined) {
            scope6.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope6.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const fetchOptions = {
        };
        fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, Object.assign(scope6.options, {
                colorSpaceConversion: 'none'
            }));
        }).then(function(imageBitmap) {
            $267b85717c4872ea$export$7c17e0f15419affd.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope6.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope6.manager.itemError(url);
            scope6.manager.itemEnd(url);
        });
        scope6.manager.itemStart(url);
    }
}
$267b85717c4872ea$export$103c236346f4c973.prototype.isImageBitmapLoader = true;
class $267b85717c4872ea$export$154a94c1b1390f5f {
    constructor(){
        this.type = 'ShapePath';
        this.color = new $267b85717c4872ea$export$e4830c8e55b4f80d();
        this.subPaths = [];
        this.currentPath = null;
    }
    moveTo(x, y) {
        this.currentPath = new $267b85717c4872ea$export$49a62d21c8b8d137();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
    }
    lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    }
    splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
    }
    toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes4 = [];
            for(let i17 = 0, l1 = inSubpaths.length; i17 < l1; i17++){
                const tmpPath = inSubpaths[i17];
                const tmpShape = new $267b85717c4872ea$export$5d9987e6723d242f();
                tmpShape.curves = tmpPath.curves;
                shapes4.push(tmpShape);
            }
            return shapes4;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p6 = polyLen - 1, q1 = 0; q1 < polyLen; p6 = q1++){
                let edgeLowPt = inPolygon[p6];
                let edgeHighPt = inPolygon[q1];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q1];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p6];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    // continue;				// no intersection or edgeLowPt => doesn't count !!!
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                // continue;
                }
            }
            return inside;
        }
        const isClockWise = $267b85717c4872ea$export$50a45ec5a8fa659f.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes4 = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new $267b85717c4872ea$export$5d9987e6723d242f();
            tmpShape.curves = tmpPath.curves;
            shapes4.push(tmpShape);
            return shapes4;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i17 = 0, l1 = subPaths.length; i17 < l1; i17++){
            tmpPath = subPaths[i17];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new $267b85717c4872ea$export$5d9987e6723d242f(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            //console.log('cw', i);
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx1 = 0, sLen1 = newShapes.length; sIdx1 < sLen1; sIdx1++){
                const sho = newShapeHoles[sIdx1];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx1 !== s2Idx) toChange.push({
                            froms: sIdx1,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx1].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i18 = 0, il = newShapes.length; i18 < il; i18++){
            tmpShape = newShapes[i18].s;
            shapes4.push(tmpShape);
            tmpHoles = newShapeHoles[i18];
            for(let j7 = 0, jl = tmpHoles.length; j7 < jl; j7++)tmpShape.holes.push(tmpHoles[j7].h);
        }
        //console.log("shape", shapes);
        return shapes4;
    }
}
class $267b85717c4872ea$export$2bbce6c06f98c1c9 {
    constructor(data4){
        this.type = 'Font';
        this.data = data4;
    }
    generateShapes(text, size = 100) {
        const shapes4 = [];
        const paths = $267b85717c4872ea$var$createPaths(text, size, this.data);
        for(let p6 = 0, pl = paths.length; p6 < pl; p6++)Array.prototype.push.apply(shapes4, paths[p6].toShapes());
        return shapes4;
    }
}
function $267b85717c4872ea$var$createPaths(text2, size2, data5) {
    const chars = Array.from(text2);
    const scale1 = size2 / data5.resolution;
    const line_height = (data5.boundingBox.yMax - data5.boundingBox.yMin + data5.underlineThickness) * scale1;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i17 = 0; i17 < chars.length; i17++){
        const char = chars[i17];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = $267b85717c4872ea$var$createPath(char, scale1, offsetX, offsetY, data5);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function $267b85717c4872ea$var$createPath(char, scale1, offsetX, offsetY, data5) {
    const glyph = data5.glyphs[char] || data5.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data5.familyName + '.');
        return;
    }
    const path2 = new $267b85717c4872ea$export$154a94c1b1390f5f();
    let x6, y6, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i17 = 0, l1 = outline.length; i17 < l1;){
            const action = outline[i17++];
            switch(action){
                case 'm':
                    x6 = outline[i17++] * scale1 + offsetX;
                    y6 = outline[i17++] * scale1 + offsetY;
                    path2.moveTo(x6, y6);
                    break;
                case 'l':
                    x6 = outline[i17++] * scale1 + offsetX;
                    y6 = outline[i17++] * scale1 + offsetY;
                    path2.lineTo(x6, y6);
                    break;
                case 'q':
                    cpx = outline[i17++] * scale1 + offsetX;
                    cpy = outline[i17++] * scale1 + offsetY;
                    cpx1 = outline[i17++] * scale1 + offsetX;
                    cpy1 = outline[i17++] * scale1 + offsetY;
                    path2.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i17++] * scale1 + offsetX;
                    cpy = outline[i17++] * scale1 + offsetY;
                    cpx1 = outline[i17++] * scale1 + offsetX;
                    cpy1 = outline[i17++] * scale1 + offsetY;
                    cpx2 = outline[i17++] * scale1 + offsetX;
                    cpy2 = outline[i17++] * scale1 + offsetY;
                    path2.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale1,
        path: path2
    };
}
$267b85717c4872ea$export$2bbce6c06f98c1c9.prototype.isFont = true;
class $267b85717c4872ea$export$e7bf7a9727dd613e extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager12){
        super(manager12);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope6.withCredentials);
        loader.load(url, function(text2) {
            let json;
            try {
                json = JSON.parse(text2);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text2.substring(65, text2.length - 2));
            }
            const font1 = scope6.parse(json);
            if (onLoad) onLoad(font1);
        }, onProgress, onError);
    }
    parse(json) {
        return new $267b85717c4872ea$export$2bbce6c06f98c1c9(json);
    }
}
let $267b85717c4872ea$var$_context;
const $267b85717c4872ea$export$7934d79fdd1a409f = {
    getContext: function() {
        if ($267b85717c4872ea$var$_context === undefined) $267b85717c4872ea$var$_context = new (window.AudioContext || window.webkitAudioContext)();
        return $267b85717c4872ea$var$_context;
    },
    setContext: function(value) {
        $267b85717c4872ea$var$_context = value;
    }
};
class $267b85717c4872ea$export$ad9e97c8f8cbaf8d extends $267b85717c4872ea$export$11b02ccb21615fa4 {
    constructor(manager13){
        super(manager13);
    }
    load(url, onLoad, onProgress, onError) {
        const scope6 = this;
        const loader = new $267b85717c4872ea$export$de6ef55ef3be029c(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = $267b85717c4872ea$export$7934d79fdd1a409f.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope6.manager.itemError(url);
            }
        }, onProgress, onError);
    }
}
class $267b85717c4872ea$export$133d71a64182fccd extends $267b85717c4872ea$export$1b810fb0fc316ea2 {
    constructor(skyColor1, groundColor1, intensity8 = 1){
        super(undefined, intensity8);
        const color11 = new $267b85717c4872ea$export$e4830c8e55b4f80d().set(skyColor1);
        const color21 = new $267b85717c4872ea$export$e4830c8e55b4f80d().set(groundColor1);
        const sky = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(color11.r, color11.g, color11.b);
        const ground = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(color21.r, color21.g, color21.b);
        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        const c0 = Math.sqrt(Math.PI);
        const c11 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c11);
    }
}
$267b85717c4872ea$export$133d71a64182fccd.prototype.isHemisphereLightProbe = true;
class $267b85717c4872ea$export$6e647085dedadafa extends $267b85717c4872ea$export$1b810fb0fc316ea2 {
    constructor(color9, intensity9 = 1){
        super(undefined, intensity9);
        const color12 = new $267b85717c4872ea$export$e4830c8e55b4f80d().set(color9);
        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[0].set(color12.r, color12.g, color12.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
}
$267b85717c4872ea$export$6e647085dedadafa.prototype.isAmbientLightProbe = true;
const $267b85717c4872ea$var$_eyeRight = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_eyeLeft = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
class $267b85717c4872ea$export$d3b6e197d8c77027 {
    constructor(){
        this.type = 'StereoCamera';
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new $267b85717c4872ea$export$95bab1c599905cc4();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new $267b85717c4872ea$export$95bab1c599905cc4();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    }
    update(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan($267b85717c4872ea$var$DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            $267b85717c4872ea$var$_eyeLeft.elements[12] = -eyeSepHalf;
            $267b85717c4872ea$var$_eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply($267b85717c4872ea$var$_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply($267b85717c4872ea$var$_eyeRight);
    }
}
class $267b85717c4872ea$export$b24a678a18073137 {
    constructor(autoStart = true){
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
    start() {
        this.startTime = $267b85717c4872ea$var$now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = $267b85717c4872ea$var$now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
}
function $267b85717c4872ea$var$now() {
    return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
}
const $267b85717c4872ea$var$_position$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_quaternion$1 = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
const $267b85717c4872ea$var$_scale$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_orientation$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$37d81c1afe6fb9e6 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(){
        super();
        this.type = 'AudioListener';
        this.context = $267b85717c4872ea$export$7934d79fdd1a409f.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new $267b85717c4872ea$export$b24a678a18073137();
    }
    getInput() {
        return this.gain;
    }
    removeFilter() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    }
    getFilter() {
        return this.filter;
    }
    setFilter(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose($267b85717c4872ea$var$_position$1, $267b85717c4872ea$var$_quaternion$1, $267b85717c4872ea$var$_scale$1);
        $267b85717c4872ea$var$_orientation$1.set(0, 0, -1).applyQuaternion($267b85717c4872ea$var$_quaternion$1);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime($267b85717c4872ea$var$_position$1.x, endTime);
            listener.positionY.linearRampToValueAtTime($267b85717c4872ea$var$_position$1.y, endTime);
            listener.positionZ.linearRampToValueAtTime($267b85717c4872ea$var$_position$1.z, endTime);
            listener.forwardX.linearRampToValueAtTime($267b85717c4872ea$var$_orientation$1.x, endTime);
            listener.forwardY.linearRampToValueAtTime($267b85717c4872ea$var$_orientation$1.y, endTime);
            listener.forwardZ.linearRampToValueAtTime($267b85717c4872ea$var$_orientation$1.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition($267b85717c4872ea$var$_position$1.x, $267b85717c4872ea$var$_position$1.y, $267b85717c4872ea$var$_position$1.z);
            listener.setOrientation($267b85717c4872ea$var$_orientation$1.x, $267b85717c4872ea$var$_orientation$1.y, $267b85717c4872ea$var$_orientation$1.z, up.x, up.y, up.z);
        }
    }
}
class $267b85717c4872ea$export$aea72bdf6b67b9 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(listener){
        super();
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    }
    play(delay = 0) {
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i17 = 1, l1 = this.filters.length; i17 < l1; i17++)this.filters[i17 - 1].connect(this.filters[i17]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        this._connected = true;
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i17 = 1, l1 = this.filters.length; i17 < l1; i17++)this.filters[i17 - 1].disconnect(this.filters[i17]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        this._connected = false;
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
            this.disconnect();
            this.filters = value.slice();
            this.connect();
        } else this.filters = value.slice();
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
}
const $267b85717c4872ea$var$_position = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_quaternion = /*@__PURE__*/ new $267b85717c4872ea$export$8756178d528e80f7();
const $267b85717c4872ea$var$_scale = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_orientation = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$615c320bd3c38565 extends $267b85717c4872ea$export$aea72bdf6b67b9 {
    constructor(listener1){
        super(listener1);
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect(this.gain);
    }
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
    }
    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose($267b85717c4872ea$var$_position, $267b85717c4872ea$var$_quaternion, $267b85717c4872ea$var$_scale);
        $267b85717c4872ea$var$_orientation.set(0, 0, 1).applyQuaternion($267b85717c4872ea$var$_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime($267b85717c4872ea$var$_position.x, endTime);
            panner.positionY.linearRampToValueAtTime($267b85717c4872ea$var$_position.y, endTime);
            panner.positionZ.linearRampToValueAtTime($267b85717c4872ea$var$_position.z, endTime);
            panner.orientationX.linearRampToValueAtTime($267b85717c4872ea$var$_orientation.x, endTime);
            panner.orientationY.linearRampToValueAtTime($267b85717c4872ea$var$_orientation.y, endTime);
            panner.orientationZ.linearRampToValueAtTime($267b85717c4872ea$var$_orientation.z, endTime);
        } else {
            panner.setPosition($267b85717c4872ea$var$_position.x, $267b85717c4872ea$var$_position.y, $267b85717c4872ea$var$_position.z);
            panner.setOrientation($267b85717c4872ea$var$_orientation.x, $267b85717c4872ea$var$_orientation.y, $267b85717c4872ea$var$_orientation.z);
        }
    }
}
class $267b85717c4872ea$export$6a674a0986333d77 {
    constructor(audio, fftSize = 2048){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data5 = this.getFrequencyData();
        for(let i17 = 0; i17 < data5.length; i17++)value += data5[i17];
        return value / data5.length;
    }
}
class $267b85717c4872ea$export$3dad248fccc371a8 {
    constructor(binding1, typeName, valueSize){
        this.binding = binding1;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
        //
        // 'add' is used for additive cumulative results
        //
        // 'work' is optional and is only present for quaternion types. It is used
        // to store intermediate quaternion multiplication results
        switch(typeName){
            case 'quaternion':
                mixFunction = this._slerp;
                mixFunctionAdditive = this._slerpAdditive;
                setIdentity = this._setAdditiveIdentityQuaternion;
                this.buffer = new Float64Array(valueSize * 6);
                this._workIndex = 5;
                break;
            case 'string':
            case 'bool':
                mixFunction = this._select;
                // Use the regular mix function and for additive on these types,
                // additive is not relevant for non-numeric types
                mixFunctionAdditive = this._select;
                setIdentity = this._setAdditiveIdentityOther;
                this.buffer = new Array(valueSize * 5);
                break;
            default:
                mixFunction = this._lerp;
                mixFunctionAdditive = this._lerpAdditive;
                setIdentity = this._setAdditiveIdentityNumeric;
                this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
    }
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride1 = this.valueSize, offset2 = accuIndex * stride1 + stride1;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i17 = 0; i17 !== stride1; ++i17)buffer[offset2 + i17] = buffer[i17];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset2, 0, mix, stride1);
        }
        this.cumulativeWeight = currentWeight;
    }
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive(weight) {
        const buffer = this.buffer, stride1 = this.valueSize, offset2 = stride1 * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset2, 0, weight, stride1);
        this.cumulativeWeightAdditive += weight;
    }
    // apply the state of 'accu<i>' to the binding when accus differ
    apply(accuIndex) {
        const stride1 = this.valueSize, buffer = this.buffer, offset2 = accuIndex * stride1 + stride1, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding1 = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride1 * this._origIndex;
            this._mixBufferRegion(buffer, offset2, originalValueOffset, 1 - weight, stride1);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset2, this._addIndex * stride1, 1, stride1);
        for(let i17 = stride1, e = stride1 + stride1; i17 !== e; ++i17)if (buffer[i17] !== buffer[i17 + stride1]) {
            // value has changed -> update scene graph
            binding1.setValue(buffer, offset2);
            break;
        }
    }
    // remember the state of the bound property and copy it to both accus
    saveOriginalState() {
        const binding1 = this.binding;
        const buffer = this.buffer, stride1 = this.valueSize, originalValueOffset = stride1 * this._origIndex;
        binding1.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i17 = stride1, e = originalValueOffset; i17 !== e; ++i17)buffer[i17] = buffer[originalValueOffset + i17 % stride1];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    }
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i17 = startIndex; i17 < endIndex; i17++)this.buffer[i17] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i17 = 0; i17 < this.valueSize; i17++)this.buffer[targetIndex + i17] = this.buffer[startIndex + i17];
    }
    // mix functions
    _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) for(let i17 = 0; i17 !== stride; ++i17)buffer[dstOffset + i17] = buffer[srcOffset + i17];
    }
    _slerp(buffer, dstOffset, srcOffset, t) {
        $267b85717c4872ea$export$8756178d528e80f7.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        $267b85717c4872ea$export$8756178d528e80f7.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        $267b85717c4872ea$export$8756178d528e80f7.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
    }
    _lerp(buffer, dstOffset, srcOffset, t, stride) {
        const s2 = 1 - t;
        for(let i17 = 0; i17 !== stride; ++i17){
            const j7 = dstOffset + i17;
            buffer[j7] = buffer[j7] * s2 + buffer[srcOffset + i17] * t;
        }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for(let i17 = 0; i17 !== stride; ++i17){
            const j7 = dstOffset + i17;
            buffer[j7] = buffer[j7] + buffer[srcOffset + i17] * t;
        }
    }
}
// Characters [].:/ are reserved for track binding syntax.
const $267b85717c4872ea$var$_RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const $267b85717c4872ea$var$_reservedRe = new RegExp('[' + $267b85717c4872ea$var$_RESERVED_CHARS_RE + ']', 'g');
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const $267b85717c4872ea$var$_wordChar = '[^' + $267b85717c4872ea$var$_RESERVED_CHARS_RE + ']';
const $267b85717c4872ea$var$_wordCharOrDot = '[^' + $267b85717c4872ea$var$_RESERVED_CHARS_RE.replace('\\.', '') + ']';
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const $267b85717c4872ea$var$_directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', $267b85717c4872ea$var$_wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const $267b85717c4872ea$var$_nodeRe = /(WCOD+)?/.source.replace('WCOD', $267b85717c4872ea$var$_wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const $267b85717c4872ea$var$_objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', $267b85717c4872ea$var$_wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const $267b85717c4872ea$var$_propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', $267b85717c4872ea$var$_wordChar);
const $267b85717c4872ea$var$_trackRe = new RegExp("^" + $267b85717c4872ea$var$_directoryRe + $267b85717c4872ea$var$_nodeRe + $267b85717c4872ea$var$_objectRe + $267b85717c4872ea$var$_propertyRe + '$');
const $267b85717c4872ea$var$_supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
class $267b85717c4872ea$var$Composite {
    constructor(targetGroup, path2, optionalParsedPath){
        const parsedPath2 = optionalParsedPath || $267b85717c4872ea$export$824ece731fa712ce.parseTrackName(path2);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path2, parsedPath2);
    }
    getValue(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding1 = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding1 !== undefined) binding1.getValue(array, offset);
    }
    setValue(array, offset) {
        const bindings = this._bindings;
        for(let i17 = this._targetGroup.nCachedObjects_, n = bindings.length; i17 !== n; ++i17)bindings[i17].setValue(array, offset);
    }
    bind() {
        const bindings = this._bindings;
        for(let i17 = this._targetGroup.nCachedObjects_, n = bindings.length; i17 !== n; ++i17)bindings[i17].bind();
    }
    unbind() {
        const bindings = this._bindings;
        for(let i17 = this._targetGroup.nCachedObjects_, n = bindings.length; i17 !== n; ++i17)bindings[i17].unbind();
    }
}
// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class $267b85717c4872ea$export$824ece731fa712ce {
    constructor(rootNode, path3, parsedPath1){
        this.path = path3;
        this.parsedPath = parsedPath1 || $267b85717c4872ea$export$824ece731fa712ce.parseTrackName(path3);
        this.node = $267b85717c4872ea$export$824ece731fa712ce.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        // initial state of these methods that calls 'bind'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new $267b85717c4872ea$export$824ece731fa712ce(root, path, parsedPath);
        else return new $267b85717c4872ea$export$824ece731fa712ce.Composite(root, path, parsedPath);
    }
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */ static sanitizeNodeName(name) {
        return name.replace(/\s/g, '_').replace($267b85717c4872ea$var$_reservedRe, '');
    }
    static parseTrackName(trackName) {
        const matches = $267b85717c4872ea$var$_trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if ($267b85717c4872ea$var$_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    }
    static findNode(root, nodeName) {
        if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i17 = 0; i17 < children.length; i17++){
                    const childNode = children[i17];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
    // these are used to "bind" a nonexistent property
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    // Getters
    _getValue_direct(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
    }
    _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for(let i17 = 0, n = source.length; i17 !== n; ++i17)buffer[offset++] = source[i17];
    }
    _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
    }
    // Direct
    _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // EntireArray
    _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i17 = 0, n = dest.length; i17 !== n; ++i17)dest[i17] = buffer[offset++];
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i17 = 0, n = dest.length; i17 !== n; ++i17)dest[i17] = buffer[offset++];
        this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for(let i17 = 0, n = dest.length; i17 !== n; ++i17)dest[i17] = buffer[offset++];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // ArrayElement
    _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    // HasToFromArray
    _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    }
    // create getter / setter pair for a property in the scene graph
    bind() {
        let targetObject = this.node;
        const parsedPath3 = this.parsedPath;
        const objectName = parsedPath3.objectName;
        const propertyName = parsedPath3.propertyName;
        let propertyIndex = parsedPath3.propertyIndex;
        if (!targetObject) {
            targetObject = $267b85717c4872ea$export$824ece731fa712ce.findNode(this.rootNode, parsedPath3.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath3.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i17 = 0; i17 < targetObject.length; i17++)if (targetObject[i17].name === objectIndex) {
                        objectIndex = i17;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath3.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === 'morphTargetInfluences') {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
}
$267b85717c4872ea$export$824ece731fa712ce.Composite = $267b85717c4872ea$var$Composite;
$267b85717c4872ea$export$824ece731fa712ce.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
$267b85717c4872ea$export$824ece731fa712ce.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
$267b85717c4872ea$export$824ece731fa712ce.prototype.GetterByBindingType = [
    $267b85717c4872ea$export$824ece731fa712ce.prototype._getValue_direct,
    $267b85717c4872ea$export$824ece731fa712ce.prototype._getValue_array,
    $267b85717c4872ea$export$824ece731fa712ce.prototype._getValue_arrayElement,
    $267b85717c4872ea$export$824ece731fa712ce.prototype._getValue_toArray, 
];
$267b85717c4872ea$export$824ece731fa712ce.prototype.SetterByBindingTypeAndVersioning = [
    [
        // Direct
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_direct,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_direct_setNeedsUpdate,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_direct_setMatrixWorldNeedsUpdate, 
    ],
    [
        // EntireArray
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_array,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_array_setNeedsUpdate,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_array_setMatrixWorldNeedsUpdate, 
    ],
    [
        // ArrayElement
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_arrayElement,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_arrayElement_setNeedsUpdate,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate, 
    ],
    [
        // HasToFromArray
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_fromArray,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_fromArray_setNeedsUpdate,
        $267b85717c4872ea$export$824ece731fa712ce.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate, 
    ]
];
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */ class $267b85717c4872ea$export$fff9d9d5e544a780 {
    constructor(){
        this.uuid = $267b85717c4872ea$var$generateUUID();
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
        const indices17 = {
        };
        this._indicesByUUID = indices17; // for bookkeeping
        for(let i17 = 0, n = arguments.length; i17 !== n; ++i17)indices17[arguments[i17].uuid] = i17;
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {
        }; // inside: indices in these arrays
        const scope6 = this;
        this.stats = {
            objects: {
                get total () {
                    return scope6._objects.length;
                },
                get inUse () {
                    return this.total - scope6.nCachedObjects_;
                }
            },
            get bindingsPerObject () {
                return scope6._bindings.length;
            }
        };
    }
    add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i18 = 0, n1 = arguments.length; i18 !== n1; ++i18){
            const object = arguments[i18], uuid = object.uuid;
            let index3 = indicesByUUID[uuid];
            if (index3 === undefined) {
                // unknown object -> add it to the ACTIVE region
                index3 = nObjects++;
                indicesByUUID[uuid] = index3;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j7 = 0, m = nBindings; j7 !== m; ++j7)bindings[j7].push(new $267b85717c4872ea$export$824ece731fa712ce(object, paths[j7], parsedPaths[j7]));
            } else if (index3 < nCachedObjects) {
                knownObject = objects[index3];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index3;
                objects[index3] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j7 = 0, m = nBindings; j7 !== m; ++j7){
                    const bindingsForPath = bindings[j7], lastCached = bindingsForPath[firstActiveIndex];
                    let binding1 = bindingsForPath[index3];
                    bindingsForPath[index3] = lastCached;
                    if (binding1 === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding1 = new $267b85717c4872ea$export$824ece731fa712ce(object, paths[j7], parsedPaths[j7]);
                    bindingsForPath[firstActiveIndex] = binding1;
                }
            } else if (objects[index3] !== knownObject) console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i18 = 0, n1 = arguments.length; i18 !== n1; ++i18){
            const object = arguments[i18], uuid = object.uuid, index3 = indicesByUUID[uuid];
            if (index3 !== undefined && index3 >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index3;
                objects[index3] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j7 = 0, m = nBindings; j7 !== m; ++j7){
                    const bindingsForPath = bindings[j7], firstActive = bindingsForPath[lastCachedIndex], binding1 = bindingsForPath[index3];
                    bindingsForPath[index3] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding1;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // remove & forget
    uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i18 = 0, n1 = arguments.length; i18 !== n1; ++i18){
            const object = arguments[i18], uuid = object.uuid, index3 = indicesByUUID[uuid];
            if (index3 !== undefined) {
                delete indicesByUUID[uuid];
                if (index3 < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index3;
                    objects[index3] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j7 = 0, m = nBindings; j7 !== m; ++j7){
                        const bindingsForPath = bindings[j7], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index3] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    if (lastIndex > 0) indicesByUUID[lastObject.uuid] = index3;
                    objects[index3] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j7 = 0, m = nBindings; j7 !== m; ++j7){
                        const bindingsForPath = bindings[j7];
                        bindingsForPath[index3] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    }
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        const indicesByPath = this._bindingsIndicesByPath;
        let index3 = indicesByPath[path];
        const bindings = this._bindings;
        if (index3 !== undefined) return bindings[index3];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index3 = bindings.length;
        indicesByPath[path] = index3;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i18 = nCachedObjects, n1 = objects.length; i18 !== n1; ++i18){
            const object = objects[i18];
            bindingsForPath[i18] = new $267b85717c4872ea$export$824ece731fa712ce(object, path, parsedPath);
        }
        return bindingsForPath;
    }
    unsubscribe_(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index3 = indicesByPath[path];
        if (index3 !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index3;
            bindings[index3] = lastBindings;
            bindings.pop();
            parsedPaths[index3] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index3] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
}
$267b85717c4872ea$export$fff9d9d5e544a780.prototype.isAnimationObjectGroup = true;
class $267b85717c4872ea$var$AnimationAction {
    constructor(mixer, clip1, localRoot = null, blendMode1 = clip1.blendMode){
        this._mixer = mixer;
        this._clip = clip1;
        this._localRoot = localRoot;
        this.blendMode = blendMode1;
        const tracks1 = clip1.tracks, nTracks = tracks1.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: $267b85717c4872ea$export$d8b6fdb2f300ab40,
            endingEnd: $267b85717c4872ea$export$d8b6fdb2f300ab40
        };
        for(let i18 = 0; i18 !== nTracks; ++i18){
            const interpolant = tracks1[i18].createInterpolant(null);
            interpolants[i18] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = $267b85717c4872ea$export$a7f3b3240c891dfd;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
    // State & Scheduling
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer1 = this._mixer, now = mixer1.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer1._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times1 = interpolant.parameterPositions, values1 = interpolant.sampleValues;
        times1[0] = now;
        times1[1] = now + duration;
        values1[0] = startTimeScale / timeScale;
        values1[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    // Object Accessors
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants1 = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case $267b85717c4872ea$export$1b7d33858890b670:
                    for(let j7 = 0, m = interpolants1.length; j7 !== m; ++j7){
                        interpolants1[j7].evaluate(clipTime);
                        propertyMixers[j7].accumulateAdditive(weight);
                    }
                    break;
                case $267b85717c4872ea$export$54330578444a738c:
                default:
                    for(let j8 = 0, m1 = interpolants1.length; j8 !== m1; ++j8){
                        interpolants1[j8].evaluate(clipTime);
                        propertyMixers[j8].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration2 = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === $267b85717c4872ea$export$bb892b3ce5de7091;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration2 - time : time;
        }
        if (loop === $267b85717c4872ea$export$1efb31fa1fe592ac) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration2) time = duration2;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration2 || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration2); // signed
                time -= duration2 * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration2 : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration2 - time;
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = $267b85717c4872ea$export$6f63fb2e509705af;
            settings.endingEnd = $267b85717c4872ea$export$6f63fb2e509705af;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? $267b85717c4872ea$export$6f63fb2e509705af : $267b85717c4872ea$export$d8b6fdb2f300ab40;
            else settings.endingStart = $267b85717c4872ea$export$ab43ac719393f08d;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? $267b85717c4872ea$export$6f63fb2e509705af : $267b85717c4872ea$export$d8b6fdb2f300ab40;
            else settings.endingEnd = $267b85717c4872ea$export$ab43ac719393f08d;
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer1 = this._mixer, now = mixer1.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer1._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times1 = interpolant.parameterPositions, values1 = interpolant.sampleValues;
        times1[0] = now;
        values1[0] = weightNow;
        times1[1] = now + duration;
        values1[1] = weightThen;
        return this;
    }
}
class $267b85717c4872ea$export$5d3d694f1f816b02 extends $267b85717c4872ea$export$4615b0b33ebec6c8 {
    constructor(root1){
        super();
        this._root = root1;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
        const root1 = action._localRoot || this._root, tracks2 = action._clip.tracks, nTracks1 = tracks2.length, bindings = action._propertyBindings, interpolants1 = action._interpolants, rootUuid = root1.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {
            };
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i19 = 0; i19 !== nTracks1; ++i19){
            const track = tracks2[i19], trackName = track.name;
            let binding1 = bindingsByName[trackName];
            if (binding1 !== undefined) bindings[i19] = binding1;
            else {
                binding1 = bindings[i19];
                if (binding1 !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding1._cacheIndex === null) {
                        ++binding1.referenceCount;
                        this._addInactiveBinding(binding1, rootUuid, trackName);
                    }
                    continue;
                }
                const path4 = prototypeAction && prototypeAction._propertyBindings[i19].binding.parsedPath;
                binding1 = new $267b85717c4872ea$export$3dad248fccc371a8($267b85717c4872ea$export$824ece731fa712ce.create(root1, trackName, path4), track.ValueTypeName, track.getValueSize());
                ++binding1.referenceCount;
                this._addInactiveBinding(binding1, rootUuid, trackName);
                bindings[i19] = binding1;
            }
            interpolants1[i19].resultBuffer = binding1.buffer;
        }
    }
    _activateAction(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i19 = 0, n1 = bindings.length; i19 !== n1; ++i19){
                const binding1 = bindings[i19];
                if ((binding1.useCount++) === 0) {
                    this._lendBinding(binding1);
                    binding1.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    }
    _deactivateAction(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i19 = 0, n1 = bindings.length; i19 !== n1; ++i19){
                const binding1 = bindings[i19];
                if ((--binding1.useCount) === 0) {
                    binding1.restoreOriginalState();
                    this._takeBackBinding(binding1);
                }
            }
            this._takeBackAction(action);
        }
    }
    // Memory manager
    _initMemoryManager() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {
        };
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {
        }; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope7 = this;
        this.stats = {
            actions: {
                get total () {
                    return scope7._actions.length;
                },
                get inUse () {
                    return scope7._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope7._bindings.length;
                },
                get inUse () {
                    return scope7._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope7._controlInterpolants.length;
                },
                get inUse () {
                    return scope7._nActiveControlInterpolants;
                }
            }
        };
    }
    // Memory management for AnimationAction objects
    _isActiveAction(action) {
        const index3 = action._cacheIndex;
        return index3 !== null && index3 < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {
                }
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for(let i19 = 0, n1 = bindings.length; i19 !== n1; ++i19){
            const binding1 = bindings[i19];
            if ((--binding1.referenceCount) === 0) this._removeInactiveBinding(binding1);
        }
    }
    _lendAction(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    }
    // Memory management for PropertyMixer objects
    _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {
            };
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    }
    _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    }
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant() {
        const interpolants1 = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants1[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new $267b85717c4872ea$export$53b17592d36ed11c(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants1[lastActiveIndex] = interpolant;
        }
        return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
        const interpolants1 = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants1[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants1[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants1[prevIndex] = lastActiveInterpolant;
    }
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction(clip, optionalRoot, blendMode) {
        const root1 = optionalRoot || this._root, rootUuid = root1.uuid;
        let clipObject = typeof clip === 'string' ? $267b85717c4872ea$export$79ad2141f3423764.findByName(root1, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === undefined) {
            if (clipObject !== null) blendMode = clipObject.blendMode;
            else blendMode = $267b85717c4872ea$export$54330578444a738c;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new $267b85717c4872ea$var$AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    }
    // get an existing action
    existingAction(clip, optionalRoot) {
        const root1 = optionalRoot || this._root, rootUuid = root1.uuid, clipObject = typeof clip === 'string' ? $267b85717c4872ea$export$79ad2141f3423764.findByName(root1, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    }
    // deactivates all previously scheduled actions
    stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i19 = nActions - 1; i19 >= 0; --i19)actions[i19].stop();
        return this;
    }
    // advance the time and update apply the animation
    update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i19 = 0; i19 !== nActions; ++i19){
            const action = actions[i19];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i20 = 0; i20 !== nBindings; ++i20)bindings[i20].apply(accuIndex);
        return this;
    }
    // Allows you to seek to a specific time in an animation.
    setTime(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i19 = 0; i19 < this._actions.length; i19++)this._actions[i19].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    }
    // return this mixer's root target object
    getRoot() {
        return this._root;
    }
    // free all resources specific to a particular clip
    uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i19 = 0, n1 = actionsToRemove.length; i19 !== n1; ++i19){
                const action = actionsToRemove[i19];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    }
    // free all resources specific to a particular root target object
    uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding2 = bindingByName[trackName];
            binding2.restoreOriginalState();
            this._removeInactiveBinding(binding2);
        }
    }
    // remove a targeted clip from the cache
    uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
}
$267b85717c4872ea$export$5d3d694f1f816b02.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
class $267b85717c4872ea$export$d267c48b1accdfaf {
    constructor(value1){
        if (typeof value1 === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value1 = arguments[1];
        }
        this.value = value1;
    }
    clone() {
        return new $267b85717c4872ea$export$d267c48b1accdfaf(this.value.clone === undefined ? this.value : this.value.clone());
    }
}
class $267b85717c4872ea$export$cef93bdd94dc2bf5 extends $267b85717c4872ea$export$a310785f1020d6c0 {
    constructor(array15, stride2, meshPerAttribute1 = 1){
        super(array15, stride2);
        this.meshPerAttribute = meshPerAttribute1;
    }
    copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    }
    clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    }
    toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
}
$267b85717c4872ea$export$cef93bdd94dc2bf5.prototype.isInstancedInterleavedBuffer = true;
class $267b85717c4872ea$export$6a5caaf2350c6592 {
    constructor(buffer1, type7, itemSize13, elementSize1, count3){
        this.buffer = buffer1;
        this.type = type7;
        this.itemSize = itemSize13;
        this.elementSize = elementSize1;
        this.count = count3;
        this.version = 0;
    }
    set needsUpdate(value) {
        if (value === true) this.version++;
    }
    setBuffer(buffer) {
        this.buffer = buffer;
        return this;
    }
    setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
    }
    setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
    }
    setCount(count) {
        this.count = count;
        return this;
    }
}
$267b85717c4872ea$export$6a5caaf2350c6592.prototype.isGLBufferAttribute = true;
class $267b85717c4872ea$export$8484abb50025d7ed {
    constructor(origin2, direction2, near4 = 0, far4 = Infinity){
        this.ray = new $267b85717c4872ea$export$c0bfd01633e732a2(origin2, direction2);
        // direction is assumed to be normalized (for accurate distance calculations)
        this.near = near4;
        this.far = far4;
        this.camera = null;
        this.layers = new $267b85717c4872ea$export$89313398f0a7ef36();
        this.params = {
            Mesh: {
            },
            Line: {
                threshold: 1
            },
            LOD: {
            },
            Points: {
                threshold: 1
            },
            Sprite: {
            }
        };
    }
    set(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin, direction);
    }
    setFromCamera(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
    }
    intersectObject(object, recursive = false, intersects = []) {
        $267b85717c4872ea$var$intersectObject(object, this, intersects, recursive);
        intersects.sort($267b85717c4872ea$var$ascSort);
        return intersects;
    }
    intersectObjects(objects, recursive = false, intersects = []) {
        for(let i19 = 0, l1 = objects.length; i19 < l1; i19++)$267b85717c4872ea$var$intersectObject(objects[i19], this, intersects, recursive);
        intersects.sort($267b85717c4872ea$var$ascSort);
        return intersects;
    }
}
function $267b85717c4872ea$var$ascSort(a2, b3) {
    return a2.distance - b3.distance;
}
function $267b85717c4872ea$var$intersectObject(object, raycaster, intersects, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects);
    if (recursive === true) {
        const children = object.children;
        for(let i19 = 0, l1 = children.length; i19 < l1; i19++)$267b85717c4872ea$var$intersectObject(children[i19], raycaster, intersects, true);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */ class $267b85717c4872ea$export$e61300ac00f458c7 {
    constructor(radius14 = 1, phi1 = 0, theta1 = 0){
        this.radius = radius14;
        this.phi = phi1; // polar angle
        this.theta = theta1; // azimuthal angle
        return this;
    }
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe() {
        const EPS1 = 0.000001;
        this.phi = Math.max(EPS1, Math.min(Math.PI - EPS1, this.phi));
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos($267b85717c4872ea$var$clamp(y / this.radius, -1, 1));
        }
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */ class $267b85717c4872ea$export$b6364e89fe15dc16 {
    constructor(radius15 = 1, theta2 = 0, y6 = 0){
        this.radius = radius15; // distance from the origin to a point in the x-z plane
        this.theta = theta2; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = y6; // height above the x-z plane
        return this;
    }
    set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
    }
    copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
const $267b85717c4872ea$var$_vector$4 = /*@__PURE__*/ new $267b85717c4872ea$export$95d9e1e745cc7977();
class $267b85717c4872ea$export$1f2e587aaea1c9d2 {
    constructor(min2 = new $267b85717c4872ea$export$95d9e1e745cc7977(Infinity, Infinity), max2 = new $267b85717c4872ea$export$95d9e1e745cc7977(-Infinity, -Infinity)){
        this.min = min2;
        this.max = max2;
    }
    set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    }
    setFromPoints(points) {
        this.makeEmpty();
        for(let i19 = 0, il = points.length; i19 < il; i19++)this.expandByPoint(points[i19]);
        return this;
    }
    setFromCenterAndSize(center, size) {
        const halfSize = $267b85717c4872ea$var$_vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    }
    makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    }
    isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    }
    expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    }
    expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    }
    containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
        const clampedPoint = $267b85717c4872ea$var$_vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    }
    intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    }
    union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    }
    translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    }
    equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
}
$267b85717c4872ea$export$1f2e587aaea1c9d2.prototype.isBox2 = true;
const $267b85717c4872ea$var$_startP = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_startEnd = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$227ad60d21b4b779 {
    constructor(start1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(), end1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2()){
        this.start = start1;
        this.end = end1;
    }
    set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    }
    copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    }
    getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
        return target.subVectors(this.end, this.start);
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end);
    }
    distance() {
        return this.start.distanceTo(this.end);
    }
    at(t, target) {
        return this.delta(target).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
        $267b85717c4872ea$var$_startP.subVectors(point, this.start);
        $267b85717c4872ea$var$_startEnd.subVectors(this.end, this.start);
        const startEnd2 = $267b85717c4872ea$var$_startEnd.dot($267b85717c4872ea$var$_startEnd);
        const startEnd_startP = $267b85717c4872ea$var$_startEnd.dot($267b85717c4872ea$var$_startP);
        let t3 = startEnd_startP / startEnd2;
        if (clampToLine) t3 = $267b85717c4872ea$var$clamp(t3, 0, 1);
        return t3;
    }
    closestPointToPoint(point, clampToLine, target) {
        const t3 = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t3).add(this.start);
    }
    applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    }
    equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
        return new this.constructor().copy(this);
    }
}
class $267b85717c4872ea$export$3458dceb5d6adb41 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(material8){
        super();
        this.material = material8;
        this.render = function() {
        };
        this.hasPositions = false;
        this.hasNormals = false;
        this.hasColors = false;
        this.hasUvs = false;
        this.positionArray = null;
        this.normalArray = null;
        this.colorArray = null;
        this.uvArray = null;
        this.count = 0;
    }
}
$267b85717c4872ea$export$3458dceb5d6adb41.prototype.isImmediateRenderObject = true;
const $267b85717c4872ea$var$_vector$3 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$22c8de43a90bfee8 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(light, color10){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color10;
        const geometry9 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let i19 = 0, j7 = 1, l1 = 32; i19 < l1; i19++, j7++){
            const p13 = i19 / l1 * Math.PI * 2;
            const p22 = j7 / l1 * Math.PI * 2;
            positions.push(Math.cos(p13), Math.sin(p13), 1, Math.cos(p22), Math.sin(p22), 1);
        }
        geometry9.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(positions, 3));
        const material9 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            fog: false,
            toneMapped: false
        });
        this.cone = new $267b85717c4872ea$export$705b5dac58c594af(geometry9, material9);
        this.add(this.cone);
        this.update();
    }
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        $267b85717c4872ea$var$_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt($267b85717c4872ea$var$_vector$3);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    }
}
const $267b85717c4872ea$var$_vector$2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_boneMatrix = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
const $267b85717c4872ea$var$_matrixWorldInv = /*@__PURE__*/ new $267b85717c4872ea$export$960b1460cb9cd6c9();
class $267b85717c4872ea$export$957c2ba4ab7ce56d extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(object2){
        const bones2 = $267b85717c4872ea$var$getBoneList(object2);
        const geometry10 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        const vertices19 = [];
        const colors = [];
        const color13 = new $267b85717c4872ea$export$e4830c8e55b4f80d(0, 0, 1);
        const color22 = new $267b85717c4872ea$export$e4830c8e55b4f80d(0, 1, 0);
        for(let i20 = 0; i20 < bones2.length; i20++){
            const bone = bones2[i20];
            if (bone.parent && bone.parent.isBone) {
                vertices19.push(0, 0, 0);
                vertices19.push(0, 0, 0);
                colors.push(color13.r, color13.g, color13.b);
                colors.push(color22.r, color22.g, color22.b);
            }
        }
        geometry10.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices19, 3));
        geometry10.setAttribute('color', new $267b85717c4872ea$export$8af155dd3ccd7773(colors, 3));
        const material10 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry10, material10);
        this.type = 'SkeletonHelper';
        this.isSkeletonHelper = true;
        this.root = object2;
        this.bones = bones2;
        this.matrix = object2.matrixWorld;
        this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
        const bones3 = this.bones;
        const geometry11 = this.geometry;
        const position1 = geometry11.getAttribute('position');
        $267b85717c4872ea$var$_matrixWorldInv.copy(this.root.matrixWorld).invert();
        for(let i21 = 0, j8 = 0; i21 < bones3.length; i21++){
            const bone = bones3[i21];
            if (bone.parent && bone.parent.isBone) {
                $267b85717c4872ea$var$_boneMatrix.multiplyMatrices($267b85717c4872ea$var$_matrixWorldInv, bone.matrixWorld);
                $267b85717c4872ea$var$_vector$2.setFromMatrixPosition($267b85717c4872ea$var$_boneMatrix);
                position1.setXYZ(j8, $267b85717c4872ea$var$_vector$2.x, $267b85717c4872ea$var$_vector$2.y, $267b85717c4872ea$var$_vector$2.z);
                $267b85717c4872ea$var$_boneMatrix.multiplyMatrices($267b85717c4872ea$var$_matrixWorldInv, bone.parent.matrixWorld);
                $267b85717c4872ea$var$_vector$2.setFromMatrixPosition($267b85717c4872ea$var$_boneMatrix);
                position1.setXYZ(j8 + 1, $267b85717c4872ea$var$_vector$2.x, $267b85717c4872ea$var$_vector$2.y, $267b85717c4872ea$var$_vector$2.z);
                j8 += 2;
            }
        }
        geometry11.getAttribute('position').needsUpdate = true;
        super.updateMatrixWorld(force);
    }
}
function $267b85717c4872ea$var$getBoneList(object1) {
    const boneList = [];
    if (object1 && object1.isBone) boneList.push(object1);
    for(let i21 = 0; i21 < object1.children.length; i21++)boneList.push.apply(boneList, $267b85717c4872ea$var$getBoneList(object1.children[i21]));
    return boneList;
}
class $267b85717c4872ea$export$66c89bc3c336e6c9 extends $267b85717c4872ea$export$4cdb671a7054bbf9 {
    constructor(light1, sphereSize, color14){
        const geometry11 = new $267b85717c4872ea$export$56e3472b8168fecc(sphereSize, 4, 2);
        const material11 = new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        super(geometry11, material11);
        this.light = light1;
        this.light.updateMatrixWorld();
        this.color = color14;
        this.type = 'PointLightHelper';
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    /*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/ }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    update() {
        if (this.color !== undefined) this.material.color.set(this.color);
        else this.material.color.copy(this.light.color);
    /*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/ }
}
const $267b85717c4872ea$var$_vector$1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_color1 = /*@__PURE__*/ new $267b85717c4872ea$export$e4830c8e55b4f80d();
const $267b85717c4872ea$var$_color2 = /*@__PURE__*/ new $267b85717c4872ea$export$e4830c8e55b4f80d();
class $267b85717c4872ea$export$e01b7a7b2ab37a30 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(light2, size2, color15){
        super();
        this.light = light2;
        this.light.updateMatrixWorld();
        this.matrix = light2.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color15;
        const geometry12 = new $267b85717c4872ea$export$4f8ac4fd44f1e5f(size2);
        geometry12.rotateY(Math.PI * 0.5);
        this.material = new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        if (this.color === undefined) this.material.vertexColors = true;
        const position1 = geometry12.getAttribute('position');
        const colors1 = new Float32Array(position1.count * 3);
        geometry12.setAttribute('color', new $267b85717c4872ea$export$3d45483f125de856(colors1, 3));
        this.add(new $267b85717c4872ea$export$4cdb671a7054bbf9(geometry12, this.material));
        this.update();
    }
    dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
    update() {
        const mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            const colors2 = mesh.geometry.getAttribute('color');
            $267b85717c4872ea$var$_color1.copy(this.light.color);
            $267b85717c4872ea$var$_color2.copy(this.light.groundColor);
            for(let i21 = 0, l2 = colors2.count; i21 < l2; i21++){
                const color16 = i21 < l2 / 2 ? $267b85717c4872ea$var$_color1 : $267b85717c4872ea$var$_color2;
                colors2.setXYZ(i21, color16.r, color16.g, color16.b);
            }
            colors2.needsUpdate = true;
        }
        mesh.lookAt($267b85717c4872ea$var$_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
}
class $267b85717c4872ea$export$fcd051d0d393c83f extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(size3 = 10, divisions = 10, color16 = 4473924, color23 = 8947848){
        color16 = new $267b85717c4872ea$export$e4830c8e55b4f80d(color16);
        color23 = new $267b85717c4872ea$export$e4830c8e55b4f80d(color23);
        const center3 = divisions / 2;
        const step = size3 / divisions;
        const halfSize = size3 / 2;
        const vertices20 = [], colors2 = [];
        for(let i21 = 0, j8 = 0, k = -halfSize; i21 <= divisions; i21++, k += step){
            vertices20.push(-halfSize, 0, k, halfSize, 0, k);
            vertices20.push(k, 0, -halfSize, k, 0, halfSize);
            const color17 = i21 === center3 ? color16 : color23;
            color17.toArray(colors2, j8);
            j8 += 3;
            color17.toArray(colors2, j8);
            j8 += 3;
            color17.toArray(colors2, j8);
            j8 += 3;
            color17.toArray(colors2, j8);
            j8 += 3;
        }
        const geometry13 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry13.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices20, 3));
        geometry13.setAttribute('color', new $267b85717c4872ea$export$8af155dd3ccd7773(colors2, 3));
        const material12 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry13, material12);
        this.type = 'GridHelper';
    }
}
class $267b85717c4872ea$export$30b712a624c9af18 extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(radius16 = 10, radials = 16, circles = 8, divisions1 = 64, color17 = 4473924, color24 = 8947848){
        color17 = new $267b85717c4872ea$export$e4830c8e55b4f80d(color17);
        color24 = new $267b85717c4872ea$export$e4830c8e55b4f80d(color24);
        const vertices21 = [];
        const colors3 = [];
        // create the radials
        for(let i22 = 0; i22 <= radials; i22++){
            const v = i22 / radials * (Math.PI * 2);
            const x6 = Math.sin(v) * radius16;
            const z5 = Math.cos(v) * radius16;
            vertices21.push(0, 0, 0);
            vertices21.push(x6, 0, z5);
            const color18 = i22 & 1 ? color17 : color24;
            colors3.push(color18.r, color18.g, color18.b);
            colors3.push(color18.r, color18.g, color18.b);
        }
        // create the circles
        for(let i23 = 0; i23 <= circles; i23++){
            const color18 = i23 & 1 ? color17 : color24;
            const r3 = radius16 - radius16 / circles * i23;
            for(let j9 = 0; j9 < divisions1; j9++){
                // first vertex
                let v = j9 / divisions1 * (Math.PI * 2);
                let x6 = Math.sin(v) * r3;
                let z5 = Math.cos(v) * r3;
                vertices21.push(x6, 0, z5);
                colors3.push(color18.r, color18.g, color18.b);
                // second vertex
                v = (j9 + 1) / divisions1 * (Math.PI * 2);
                x6 = Math.sin(v) * r3;
                z5 = Math.cos(v) * r3;
                vertices21.push(x6, 0, z5);
                colors3.push(color18.r, color18.g, color18.b);
            }
        }
        const geometry14 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry14.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices21, 3));
        geometry14.setAttribute('color', new $267b85717c4872ea$export$8af155dd3ccd7773(colors3, 3));
        const material13 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry14, material13);
        this.type = 'PolarGridHelper';
    }
}
const $267b85717c4872ea$var$_v1 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v2 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_v3 = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
class $267b85717c4872ea$export$9dbd8cac592c85b4 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    constructor(light3, size4, color18){
        super();
        this.light = light3;
        this.light.updateMatrixWorld();
        this.matrix = light3.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color18;
        if (size4 === undefined) size4 = 1;
        let geometry15 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry15.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773([
            -size4,
            size4,
            0,
            size4,
            size4,
            0,
            size4,
            -size4,
            0,
            -size4,
            -size4,
            0,
            -size4,
            size4,
            0
        ], 3));
        const material14 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            fog: false,
            toneMapped: false
        });
        this.lightPlane = new $267b85717c4872ea$export$2034040bfbe12f9(geometry15, material14);
        this.add(this.lightPlane);
        geometry15 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry15.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3));
        this.targetLine = new $267b85717c4872ea$export$2034040bfbe12f9(geometry15, material14);
        this.add(this.targetLine);
        this.update();
    }
    dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
    update() {
        $267b85717c4872ea$var$_v1.setFromMatrixPosition(this.light.matrixWorld);
        $267b85717c4872ea$var$_v2.setFromMatrixPosition(this.light.target.matrixWorld);
        $267b85717c4872ea$var$_v3.subVectors($267b85717c4872ea$var$_v2, $267b85717c4872ea$var$_v1);
        this.lightPlane.lookAt($267b85717c4872ea$var$_v2);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt($267b85717c4872ea$var$_v2);
        this.targetLine.scale.z = $267b85717c4872ea$var$_v3.length();
    }
}
const $267b85717c4872ea$var$_vector = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
const $267b85717c4872ea$var$_camera = /*@__PURE__*/ new $267b85717c4872ea$export$d193d689dcf22ce8();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */ class $267b85717c4872ea$export$d702457fb9a6666a extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(camera2){
        const geometry16 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        const material15 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
        });
        const vertices22 = [];
        const colors4 = [];
        const pointMap = {
        };
        // colors
        const colorFrustum = new $267b85717c4872ea$export$e4830c8e55b4f80d(16755200);
        const colorCone = new $267b85717c4872ea$export$e4830c8e55b4f80d(16711680);
        const colorUp = new $267b85717c4872ea$export$e4830c8e55b4f80d(43775);
        const colorTarget = new $267b85717c4872ea$export$e4830c8e55b4f80d(16777215);
        const colorCross = new $267b85717c4872ea$export$e4830c8e55b4f80d(3355443);
        // near
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        // far
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        // sides
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        // cone
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        // up
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        // target
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        // cross
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a2, b3, color19) {
            addPoint(a2, color19);
            addPoint(b3, color19);
        }
        function addPoint(id, color19) {
            vertices22.push(0, 0, 0);
            colors4.push(color19.r, color19.g, color19.b);
            if (pointMap[id] === undefined) pointMap[id] = [];
            pointMap[id].push(vertices22.length / 3 - 1);
        }
        geometry16.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices22, 3));
        geometry16.setAttribute('color', new $267b85717c4872ea$export$8af155dd3ccd7773(colors4, 3));
        super(geometry16, material15);
        this.type = 'CameraHelper';
        this.camera = camera2;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera2.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
    update() {
        const geometry17 = this.geometry;
        const pointMap1 = this.pointMap;
        const w3 = 1, h = 1;
        // we need just camera projection matrix inverse
        // world matrix must be identity
        $267b85717c4872ea$var$_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        // center / target
        $267b85717c4872ea$var$setPoint('c', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, 0, -1);
        $267b85717c4872ea$var$setPoint('t', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, 0, 1);
        // near
        $267b85717c4872ea$var$setPoint('n1', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, -h, -1);
        $267b85717c4872ea$var$setPoint('n2', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, -h, -1);
        $267b85717c4872ea$var$setPoint('n3', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, h, -1);
        $267b85717c4872ea$var$setPoint('n4', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, h, -1);
        // far
        $267b85717c4872ea$var$setPoint('f1', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, -h, 1);
        $267b85717c4872ea$var$setPoint('f2', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, -h, 1);
        $267b85717c4872ea$var$setPoint('f3', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, h, 1);
        $267b85717c4872ea$var$setPoint('f4', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, h, 1);
        // up
        $267b85717c4872ea$var$setPoint('u1', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3 * 0.7, h * 1.1, -1);
        $267b85717c4872ea$var$setPoint('u2', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3 * 0.7, h * 1.1, -1);
        $267b85717c4872ea$var$setPoint('u3', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, h * 2, -1);
        // cross
        $267b85717c4872ea$var$setPoint('cf1', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, 0, 1);
        $267b85717c4872ea$var$setPoint('cf2', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, 0, 1);
        $267b85717c4872ea$var$setPoint('cf3', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, -h, 1);
        $267b85717c4872ea$var$setPoint('cf4', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, h, 1);
        $267b85717c4872ea$var$setPoint('cn1', pointMap1, geometry17, $267b85717c4872ea$var$_camera, -w3, 0, -1);
        $267b85717c4872ea$var$setPoint('cn2', pointMap1, geometry17, $267b85717c4872ea$var$_camera, w3, 0, -1);
        $267b85717c4872ea$var$setPoint('cn3', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, -h, -1);
        $267b85717c4872ea$var$setPoint('cn4', pointMap1, geometry17, $267b85717c4872ea$var$_camera, 0, h, -1);
        geometry17.getAttribute('position').needsUpdate = true;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
function $267b85717c4872ea$var$setPoint(point, pointMap1, geometry17, camera3, x6, y7, z5) {
    $267b85717c4872ea$var$_vector.set(x6, y7, z5).unproject(camera3);
    const points6 = pointMap1[point];
    if (points6 !== undefined) {
        const position2 = geometry17.getAttribute('position');
        for(let i24 = 0, l2 = points6.length; i24 < l2; i24++)position2.setXYZ(points6[i24], $267b85717c4872ea$var$_vector.x, $267b85717c4872ea$var$_vector.y, $267b85717c4872ea$var$_vector.z);
    }
}
const $267b85717c4872ea$var$_box = /*@__PURE__*/ new $267b85717c4872ea$export$c99edadde72ee706();
class $267b85717c4872ea$export$f0decbf290d48835 extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(object1, color19 = 16776960){
        const indices18 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions1 = new Float32Array(24);
        const geometry17 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry17.setIndex(new $267b85717c4872ea$export$3d45483f125de856(indices18, 1));
        geometry17.setAttribute('position', new $267b85717c4872ea$export$3d45483f125de856(positions1, 3));
        super(geometry17, new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            color: color19,
            toneMapped: false
        }));
        this.object = object1;
        this.type = 'BoxHelper';
        this.matrixAutoUpdate = false;
        this.update();
    }
    update(object) {
        if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
        if (this.object !== undefined) $267b85717c4872ea$var$_box.setFromObject(this.object);
        if ($267b85717c4872ea$var$_box.isEmpty()) return;
        const min3 = $267b85717c4872ea$var$_box.min;
        const max3 = $267b85717c4872ea$var$_box.max;
        /*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/ const position2 = this.geometry.attributes.position;
        const array16 = position2.array;
        array16[0] = max3.x;
        array16[1] = max3.y;
        array16[2] = max3.z;
        array16[3] = min3.x;
        array16[4] = max3.y;
        array16[5] = max3.z;
        array16[6] = min3.x;
        array16[7] = min3.y;
        array16[8] = max3.z;
        array16[9] = max3.x;
        array16[10] = min3.y;
        array16[11] = max3.z;
        array16[12] = max3.x;
        array16[13] = max3.y;
        array16[14] = min3.z;
        array16[15] = min3.x;
        array16[16] = max3.y;
        array16[17] = min3.z;
        array16[18] = min3.x;
        array16[19] = min3.y;
        array16[20] = min3.z;
        array16[21] = max3.x;
        array16[22] = min3.y;
        array16[23] = min3.z;
        position2.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
    setFromObject(object) {
        this.object = object;
        this.update();
        return this;
    }
    copy(source) {
        $267b85717c4872ea$export$705b5dac58c594af.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
    }
}
class $267b85717c4872ea$export$d48d84797cac3c9e extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(box, color20 = 16776960){
        const indices19 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions2 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ];
        const geometry18 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry18.setIndex(new $267b85717c4872ea$export$3d45483f125de856(indices19, 1));
        geometry18.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(positions2, 3));
        super(geometry18, new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            color: color20,
            toneMapped: false
        }));
        this.box = box;
        this.type = 'Box3Helper';
        this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(force) {
        const box1 = this.box;
        if (box1.isEmpty()) return;
        box1.getCenter(this.position);
        box1.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
    }
}
class $267b85717c4872ea$export$b8c58917081cc622 extends $267b85717c4872ea$export$2034040bfbe12f9 {
    constructor(plane, size5 = 1, hex = 16776960){
        const color25 = hex;
        const positions3 = [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ];
        const geometry19 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry19.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(positions3, 3));
        geometry19.computeBoundingSphere();
        super(geometry19, new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            color: color25,
            toneMapped: false
        }));
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = size5;
        const positions21 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1
        ];
        const geometry21 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry21.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(positions21, 3));
        geometry21.computeBoundingSphere();
        this.add(new $267b85717c4872ea$export$4cdb671a7054bbf9(geometry21, new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
            color: color25,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
        })));
    }
    updateMatrixWorld(force) {
        let scale1 = -this.plane.constant;
        if (Math.abs(scale1) < 0.00000001) scale1 = 0.00000001; // sign does not matter
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale1);
        this.children[0].material.side = scale1 < 0 ? $267b85717c4872ea$export$fbde0e233a2945e1 : $267b85717c4872ea$export$9b320e6c690b4c3e; // renderer flips side when determinant < 0; flipping not wanted here
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
    }
}
const $267b85717c4872ea$var$_axis = /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2();
let $267b85717c4872ea$var$_lineGeometry, $267b85717c4872ea$var$_coneGeometry;
class $267b85717c4872ea$export$504269eedfd14df2 extends $267b85717c4872ea$export$c8ea94beaa33360 {
    // dir is assumed to be normalized
    constructor(dir1 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 1), origin3 = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 0, 0), length1 = 1, color26 = 16776960, headLength1 = length1 * 0.2, headWidth1 = headLength1 * 0.2){
        super();
        this.type = 'ArrowHelper';
        if ($267b85717c4872ea$var$_lineGeometry === undefined) {
            $267b85717c4872ea$var$_lineGeometry = new $267b85717c4872ea$export$84a34b4c8ecb6751();
            $267b85717c4872ea$var$_lineGeometry.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3));
            $267b85717c4872ea$var$_coneGeometry = new $267b85717c4872ea$export$94c6884a61a1e52e(0, 0.5, 1, 5, 1);
            $267b85717c4872ea$var$_coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin3);
        this.line = new $267b85717c4872ea$export$2034040bfbe12f9($267b85717c4872ea$var$_lineGeometry, new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            color: color26,
            toneMapped: false
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new $267b85717c4872ea$export$4cdb671a7054bbf9($267b85717c4872ea$var$_coneGeometry, new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
            color: color26,
            toneMapped: false
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir1);
        this.setLength(length1, headLength1, headWidth1);
    }
    setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            $267b85717c4872ea$var$_axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle($267b85717c4872ea$var$_axis, radians);
        }
    }
    setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
    setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
    }
    copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
    }
}
class $267b85717c4872ea$export$9f8bf6f3d774afbf extends $267b85717c4872ea$export$705b5dac58c594af {
    constructor(size6 = 1){
        const vertices23 = [
            0,
            0,
            0,
            size6,
            0,
            0,
            0,
            0,
            0,
            0,
            size6,
            0,
            0,
            0,
            0,
            0,
            0,
            size6
        ];
        const colors5 = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
        ];
        const geometry20 = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        geometry20.setAttribute('position', new $267b85717c4872ea$export$8af155dd3ccd7773(vertices23, 3));
        geometry20.setAttribute('color', new $267b85717c4872ea$export$8af155dd3ccd7773(colors5, 3));
        const material16 = new $267b85717c4872ea$export$9dd1d6697fbc79f6({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry20, material16);
        this.type = 'AxesHelper';
    }
    setColors(xAxisColor, yAxisColor, zAxisColor) {
        const color27 = new $267b85717c4872ea$export$e4830c8e55b4f80d();
        const array16 = this.geometry.attributes.color.array;
        color27.set(xAxisColor);
        color27.toArray(array16, 0);
        color27.toArray(array16, 3);
        color27.set(yAxisColor);
        color27.toArray(array16, 6);
        color27.toArray(array16, 9);
        color27.set(zAxisColor);
        color27.toArray(array16, 12);
        color27.toArray(array16, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
    }
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
}
const $267b85717c4872ea$var$_floatView = new Float32Array(1);
const $267b85717c4872ea$var$_int32View = new Int32Array($267b85717c4872ea$var$_floatView.buffer);
class $267b85717c4872ea$export$e0e22357653ba251 {
    // Converts float32 to float16 (stored as uint16 value).
    static toHalfFloat(val) {
        // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410
        /* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */ $267b85717c4872ea$var$_floatView[0] = val;
        const x6 = $267b85717c4872ea$var$_int32View[0];
        let bits = x6 >> 16 & 32768; /* Get the sign */ 
        let m = x6 >> 12 & 2047; /* Keep one extra bit for rounding */ 
        const e = x6 >> 23 & 255; /* Using int is faster here */ 
        /* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */ if (e < 103) return bits;
        /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */ if (e > 142) {
            bits |= 31744;
            /* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */ bits |= (e == 255 ? 0 : 1) && x6 & 8388607;
            return bits;
        }
        /* If exponent underflows but not too much, return a denormal */ if (e < 113) {
            m |= 2048;
            /* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */ bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            return bits;
        }
        bits |= e - 112 << 10 | m >> 1;
        /* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */ bits += m & 1;
        return bits;
    }
}
const $267b85717c4872ea$var$LOD_MIN = 4;
const $267b85717c4872ea$var$LOD_MAX = 8;
const $267b85717c4872ea$var$SIZE_MAX = Math.pow(2, $267b85717c4872ea$var$LOD_MAX);
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const $267b85717c4872ea$var$EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const $267b85717c4872ea$var$TOTAL_LODS = $267b85717c4872ea$var$LOD_MAX - $267b85717c4872ea$var$LOD_MIN + 1 + $267b85717c4872ea$var$EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const $267b85717c4872ea$var$MAX_SAMPLES = 20;
const $267b85717c4872ea$var$ENCODINGS = {
    [$267b85717c4872ea$export$b2fb0348530d6a72]: 0,
    [$267b85717c4872ea$export$e7c1dc234bb46352]: 1,
    [$267b85717c4872ea$export$ace080f0744d1804]: 2,
    [$267b85717c4872ea$export$8a6fae5b6cf692b2]: 3,
    [$267b85717c4872ea$export$75672e157e360d47]: 4,
    [$267b85717c4872ea$export$d7502b91b57a25b6]: 5,
    [$267b85717c4872ea$export$bdceb2aaf414b246]: 6
};
const $267b85717c4872ea$var$backgroundMaterial = new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
    side: $267b85717c4872ea$export$fbde0e233a2945e1,
    depthWrite: false,
    depthTest: false
});
const $267b85717c4872ea$var$backgroundBox = new $267b85717c4872ea$export$4cdb671a7054bbf9(new $267b85717c4872ea$export$7adcd09f49b1ca3c(), $267b85717c4872ea$var$backgroundMaterial);
const $267b85717c4872ea$var$_flatCamera = /*@__PURE__*/ new $267b85717c4872ea$export$a38f6f1a088d3096();
const { _lodPlanes: $267b85717c4872ea$var$_lodPlanes , _sizeLods: $267b85717c4872ea$var$_sizeLods , _sigmas: $267b85717c4872ea$var$_sigmas  } = /*@__PURE__*/ $267b85717c4872ea$var$_createPlanes();
const $267b85717c4872ea$var$_clearColor = /*@__PURE__*/ new $267b85717c4872ea$export$e4830c8e55b4f80d();
let $267b85717c4872ea$var$_oldTarget = null;
// Golden Ratio
const $267b85717c4872ea$var$PHI = (1 + Math.sqrt(5)) / 2;
const $267b85717c4872ea$var$INV_PHI = 1 / $267b85717c4872ea$var$PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const $267b85717c4872ea$var$_axisDirections = [
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 1, 1),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-1, 1, 1),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(1, 1, -1),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-1, 1, -1),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, $267b85717c4872ea$var$PHI, $267b85717c4872ea$var$INV_PHI),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, $267b85717c4872ea$var$PHI, -$267b85717c4872ea$var$INV_PHI),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2($267b85717c4872ea$var$INV_PHI, 0, $267b85717c4872ea$var$PHI),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-$267b85717c4872ea$var$INV_PHI, 0, $267b85717c4872ea$var$PHI),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2($267b85717c4872ea$var$PHI, $267b85717c4872ea$var$INV_PHI, 0),
    /*@__PURE__*/ new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(-$267b85717c4872ea$var$PHI, $267b85717c4872ea$var$INV_PHI, 0)
];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 *
 * Paper: Fast, Accurate Image-Based Lighting
 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
*/ function $267b85717c4872ea$var$convertLinearToRGBE(color27) {
    const maxComponent = Math.max(color27.r, color27.g, color27.b);
    const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
    color27.multiplyScalar(Math.pow(2, -fExp));
    const alpha = (fExp + 128) / 255;
    return alpha;
}
class $267b85717c4872ea$export$6a278e242a11c0bf {
    constructor(renderer1){
        this._renderer = renderer1;
        this._pingPongRenderTarget = null;
        this._blurMaterial = $267b85717c4872ea$var$_getBlurShader($267b85717c4872ea$var$MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
    }
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */ fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        $267b85717c4872ea$var$_oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
    }
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */ fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
    }
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileCubemapShader() {
        if (this._cubemapShader === null) {
            this._cubemapShader = $267b85717c4872ea$var$_getCubemapShader();
            this._compileMaterial(this._cubemapShader);
        }
    }
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */ compileEquirectangularShader() {
        if (this._equirectShader === null) {
            this._equirectShader = $267b85717c4872ea$var$_getEquirectShader();
            this._compileMaterial(this._equirectShader);
        }
    }
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */ dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null) this._cubemapShader.dispose();
        if (this._equirectShader !== null) this._equirectShader.dispose();
        for(let i24 = 0; i24 < $267b85717c4872ea$var$_lodPlanes.length; i24++)$267b85717c4872ea$var$_lodPlanes[i24].dispose();
    }
    // private interface
    _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget($267b85717c4872ea$var$_oldTarget);
        outputTarget.scissorTest = false;
        $267b85717c4872ea$var$_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture) {
        $267b85717c4872ea$var$_oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    _allocateTargets(texture) {
        const params = {
            magFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
            minFilter: $267b85717c4872ea$export$f8b53649f0062e3e,
            generateMipmaps: false,
            type: $267b85717c4872ea$export$33b8d64de134adc1,
            format: $267b85717c4872ea$export$1148782ca903ca69,
            encoding: $267b85717c4872ea$var$_isLDR(texture) ? texture.encoding : $267b85717c4872ea$export$ace080f0744d1804,
            depthBuffer: false
        };
        const cubeUVRenderTarget = $267b85717c4872ea$var$_createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = $267b85717c4872ea$var$_createRenderTarget(params);
        return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
        const tmpMesh = new $267b85717c4872ea$export$4cdb671a7054bbf9($267b85717c4872ea$var$_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, $267b85717c4872ea$var$_flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov1 = 90;
        const aspect1 = 1;
        const cubeCamera = new $267b85717c4872ea$export$95bab1c599905cc4(fov1, aspect1, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer2 = this._renderer;
        const originalAutoClear = renderer2.autoClear;
        const outputEncoding = renderer2.outputEncoding;
        const toneMapping = renderer2.toneMapping;
        renderer2.getClearColor($267b85717c4872ea$var$_clearColor);
        renderer2.toneMapping = $267b85717c4872ea$export$f1d4bd8fdcc91a4e;
        renderer2.outputEncoding = $267b85717c4872ea$export$b2fb0348530d6a72;
        renderer2.autoClear = false;
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
            if (background.isColor) {
                $267b85717c4872ea$var$backgroundMaterial.color.copy(background).convertSRGBToLinear();
                scene.background = null;
                const alpha = $267b85717c4872ea$var$convertLinearToRGBE($267b85717c4872ea$var$backgroundMaterial.color);
                $267b85717c4872ea$var$backgroundMaterial.opacity = alpha;
                useSolidColor = true;
            }
        } else {
            $267b85717c4872ea$var$backgroundMaterial.color.copy($267b85717c4872ea$var$_clearColor).convertSRGBToLinear();
            const alpha = $267b85717c4872ea$var$convertLinearToRGBE($267b85717c4872ea$var$backgroundMaterial.color);
            $267b85717c4872ea$var$backgroundMaterial.opacity = alpha;
            useSolidColor = true;
        }
        for(let i24 = 0; i24 < 6; i24++){
            const col = i24 % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i24], 0);
                cubeCamera.lookAt(forwardSign[i24], 0, 0);
            } else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i24]);
                cubeCamera.lookAt(0, forwardSign[i24], 0);
            } else {
                cubeCamera.up.set(0, upSign[i24], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i24]);
            }
            $267b85717c4872ea$var$_setViewport(cubeUVRenderTarget, col * $267b85717c4872ea$var$SIZE_MAX, i24 > 2 ? $267b85717c4872ea$var$SIZE_MAX : 0, $267b85717c4872ea$var$SIZE_MAX, $267b85717c4872ea$var$SIZE_MAX);
            renderer2.setRenderTarget(cubeUVRenderTarget);
            if (useSolidColor) renderer2.render($267b85717c4872ea$var$backgroundBox, cubeCamera);
            renderer2.render(scene, cubeCamera);
        }
        renderer2.toneMapping = toneMapping;
        renderer2.outputEncoding = outputEncoding;
        renderer2.autoClear = originalAutoClear;
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer2 = this._renderer;
        if (texture.isCubeTexture) {
            if (this._cubemapShader == null) this._cubemapShader = $267b85717c4872ea$var$_getCubemapShader();
        } else if (this._equirectShader == null) this._equirectShader = $267b85717c4872ea$var$_getEquirectShader();
        const material18 = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new $267b85717c4872ea$export$4cdb671a7054bbf9($267b85717c4872ea$var$_lodPlanes[0], material18);
        const uniforms = material18.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
        uniforms['inputEncoding'].value = $267b85717c4872ea$var$ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = $267b85717c4872ea$var$ENCODINGS[cubeUVRenderTarget.texture.encoding];
        $267b85717c4872ea$var$_setViewport(cubeUVRenderTarget, 0, 0, 3 * $267b85717c4872ea$var$SIZE_MAX, 2 * $267b85717c4872ea$var$SIZE_MAX);
        renderer2.setRenderTarget(cubeUVRenderTarget);
        renderer2.render(mesh, $267b85717c4872ea$var$_flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
        const renderer2 = this._renderer;
        const autoClear = renderer2.autoClear;
        renderer2.autoClear = false;
        for(let i24 = 1; i24 < $267b85717c4872ea$var$TOTAL_LODS; i24++){
            const sigma = Math.sqrt($267b85717c4872ea$var$_sigmas[i24] * $267b85717c4872ea$var$_sigmas[i24] - $267b85717c4872ea$var$_sigmas[i24 - 1] * $267b85717c4872ea$var$_sigmas[i24 - 1]);
            const poleAxis = $267b85717c4872ea$var$_axisDirections[(i24 - 1) % $267b85717c4872ea$var$_axisDirections.length];
            this._blur(cubeUVRenderTarget, i24 - 1, i24, sigma, poleAxis);
        }
        renderer2.autoClear = autoClear;
    }
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */ _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer2 = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new $267b85717c4872ea$export$4cdb671a7054bbf9($267b85717c4872ea$var$_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = $267b85717c4872ea$var$_sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * $267b85717c4872ea$var$MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : $267b85717c4872ea$var$MAX_SAMPLES;
        if (samples > $267b85717c4872ea$var$MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${$267b85717c4872ea$var$MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i24 = 0; i24 < $267b85717c4872ea$var$MAX_SAMPLES; ++i24){
            const x6 = i24 / sigmaPixels;
            const weight = Math.exp(-x6 * x6 / 2);
            weights.push(weight);
            if (i24 == 0) sum += weight;
            else if (i24 < samples) sum += 2 * weight;
        }
        for(let i25 = 0; i25 < weights.length; i25++)weights[i25] = weights[i25] / sum;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = $267b85717c4872ea$var$LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = $267b85717c4872ea$var$ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = $267b85717c4872ea$var$ENCODINGS[targetIn.texture.encoding];
        const outputSize = $267b85717c4872ea$var$_sizeLods[lodOut];
        const x6 = 3 * Math.max(0, $267b85717c4872ea$var$SIZE_MAX - 2 * outputSize);
        const y7 = (lodOut === 0 ? 0 : 2 * $267b85717c4872ea$var$SIZE_MAX) + 2 * outputSize * (lodOut > $267b85717c4872ea$var$LOD_MAX - $267b85717c4872ea$var$LOD_MIN ? lodOut - $267b85717c4872ea$var$LOD_MAX + $267b85717c4872ea$var$LOD_MIN : 0);
        $267b85717c4872ea$var$_setViewport(targetOut, x6, y7, 3 * outputSize, 2 * outputSize);
        renderer2.setRenderTarget(targetOut);
        renderer2.render(blurMesh, $267b85717c4872ea$var$_flatCamera);
    }
}
function $267b85717c4872ea$var$_isLDR(texture2) {
    if (texture2 === undefined || texture2.type !== $267b85717c4872ea$export$33b8d64de134adc1) return false;
    return texture2.encoding === $267b85717c4872ea$export$b2fb0348530d6a72 || texture2.encoding === $267b85717c4872ea$export$e7c1dc234bb46352 || texture2.encoding === $267b85717c4872ea$export$bdceb2aaf414b246;
}
function $267b85717c4872ea$var$_createPlanes() {
    const _lodPlanes = [];
    const _sizeLods = [];
    const _sigmas = [];
    let lod = $267b85717c4872ea$var$LOD_MAX;
    for(let i24 = 0; i24 < $267b85717c4872ea$var$TOTAL_LODS; i24++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i24 > $267b85717c4872ea$var$LOD_MAX - $267b85717c4872ea$var$LOD_MIN) sigma = $267b85717c4872ea$var$EXTRA_LOD_SIGMA[i24 - $267b85717c4872ea$var$LOD_MAX + $267b85717c4872ea$var$LOD_MIN - 1];
        else if (i24 == 0) sigma = 0;
        _sigmas.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min3 = -texelSize / 2;
        const max3 = 1 + texelSize / 2;
        const uv11 = [
            min3,
            min3,
            max3,
            min3,
            max3,
            max3,
            min3,
            min3,
            max3,
            max3,
            min3,
            max3
        ];
        const cubeFaces = 6;
        const vertices24 = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position2 = new Float32Array(positionSize * vertices24 * cubeFaces);
        const uv4 = new Float32Array(uvSize * vertices24 * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices24 * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x6 = face % 3 * 2 / 3 - 1;
            const y7 = face > 2 ? 0 : -1;
            const coordinates = [
                x6,
                y7,
                0,
                x6 + 2 / 3,
                y7,
                0,
                x6 + 2 / 3,
                y7 + 1,
                0,
                x6,
                y7,
                0,
                x6 + 2 / 3,
                y7 + 1,
                0,
                x6,
                y7 + 1,
                0
            ];
            position2.set(coordinates, positionSize * vertices24 * face);
            uv4.set(uv11, uvSize * vertices24 * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices24 * face);
        }
        const planes = new $267b85717c4872ea$export$84a34b4c8ecb6751();
        planes.setAttribute('position', new $267b85717c4872ea$export$3d45483f125de856(position2, positionSize));
        planes.setAttribute('uv', new $267b85717c4872ea$export$3d45483f125de856(uv4, uvSize));
        planes.setAttribute('faceIndex', new $267b85717c4872ea$export$3d45483f125de856(faceIndex, faceIndexSize));
        _lodPlanes.push(planes);
        if (lod > $267b85717c4872ea$var$LOD_MIN) lod--;
    }
    return {
        _lodPlanes: _lodPlanes,
        _sizeLods: _sizeLods,
        _sigmas: _sigmas
    };
}
function $267b85717c4872ea$var$_createRenderTarget(params) {
    const cubeUVRenderTarget = new $267b85717c4872ea$export$aef5a065c75d61ea(3 * $267b85717c4872ea$var$SIZE_MAX, 3 * $267b85717c4872ea$var$SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = $267b85717c4872ea$export$fb3ca8bcae285728;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function $267b85717c4872ea$var$_setViewport(target, x6, y7, width12, height14) {
    target.viewport.set(x6, y7, width12, height14);
    target.scissor.set(x6, y7, width12, height14);
}
function $267b85717c4872ea$var$_getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(0, 1, 0);
    const shaderMaterial = new $267b85717c4872ea$export$44c67e5b3e2f1fcc({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': maxSamples
        },
        uniforms: {
            'envMap': {
                value: null
            },
            'samples': {
                value: 1
            },
            'weights': {
                value: weights
            },
            'latitudinal': {
                value: false
            },
            'dTheta': {
                value: 0
            },
            'mipInt': {
                value: 0
            },
            'poleAxis': {
                value: poleAxis
            },
            'inputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            },
            'outputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            }
        },
        vertexShader: $267b85717c4872ea$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			${$267b85717c4872ea$var$_getEncodings()}\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: $267b85717c4872ea$export$8dd1256cd8ee174c,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function $267b85717c4872ea$var$_getEquirectShader() {
    const texelSize = new $267b85717c4872ea$export$95d9e1e745cc7977(1, 1);
    const shaderMaterial = new $267b85717c4872ea$export$44c67e5b3e2f1fcc({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'texelSize': {
                value: texelSize
            },
            'inputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            },
            'outputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            }
        },
        vertexShader: $267b85717c4872ea$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform vec2 texelSize;\n\n			${$267b85717c4872ea$var$_getEncodings()}\n\n			#include <common>\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				vec2 f = fract( uv / texelSize - 0.5 );\n				uv -= f * texelSize;\n				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x += texelSize.x;\n				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.y += texelSize.y;\n				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x -= texelSize.x;\n				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n				vec3 tm = mix( tl, tr, f.x );\n				vec3 bm = mix( bl, br, f.x );\n				gl_FragColor.rgb = mix( tm, bm, f.y );\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: $267b85717c4872ea$export$8dd1256cd8ee174c,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function $267b85717c4872ea$var$_getCubemapShader() {
    const shaderMaterial = new $267b85717c4872ea$export$44c67e5b3e2f1fcc({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'inputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            },
            'outputEncoding': {
                value: $267b85717c4872ea$var$ENCODINGS[$267b85717c4872ea$export$b2fb0348530d6a72]
            }
        },
        vertexShader: $267b85717c4872ea$var$_getCommonVertexShader(),
        fragmentShader: /* glsl */ `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			${$267b85717c4872ea$var$_getEncodings()}\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: $267b85717c4872ea$export$8dd1256cd8ee174c,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function $267b85717c4872ea$var$_getCommonVertexShader() {
    return(/* glsl */ `\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	`);
}
function $267b85717c4872ea$var$_getEncodings() {
    return(/* glsl */ `\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	`);
}
const $267b85717c4872ea$export$c32a1ccced55ca = 0;
const $267b85717c4872ea$export$b9777af7c0366d57 = 1;
const $267b85717c4872ea$export$3fc9f494700939 = 0;
const $267b85717c4872ea$export$98d05520ec1a5a13 = 1;
const $267b85717c4872ea$export$1e4edebbd7da24ef = 2;
function $267b85717c4872ea$export$beec5233c7ebdc6a(materials) {
    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
    return materials;
}
function $267b85717c4872ea$export$cf0896e280f8efc7(materials = []) {
    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
    materials.isMultiMaterial = true;
    materials.materials = materials;
    materials.clone = function() {
        return materials.slice();
    };
    return materials;
}
function $267b85717c4872ea$export$37cc6183db362cda(geometry22, material18) {
    console.warn('THREE.PointCloud has been renamed to THREE.Points.');
    return new $267b85717c4872ea$export$fd24d21d3cd7fd59(geometry22, material18);
}
function $267b85717c4872ea$export$77964a87ff738a0(material18) {
    console.warn('THREE.Particle has been renamed to THREE.Sprite.');
    return new $267b85717c4872ea$export$c01017fc2f0e32a2(material18);
}
function $267b85717c4872ea$export$791b710881bda33a(geometry22, material18) {
    console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
    return new $267b85717c4872ea$export$fd24d21d3cd7fd59(geometry22, material18);
}
function $267b85717c4872ea$export$a7200bc48c0376a6(parameters18) {
    console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
    return new $267b85717c4872ea$export$5e855264a077e9f(parameters18);
}
function $267b85717c4872ea$export$474e5029c6b0278e(parameters18) {
    console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
    return new $267b85717c4872ea$export$5e855264a077e9f(parameters18);
}
function $267b85717c4872ea$export$7c45d6f6655ac7b9(parameters18) {
    console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
    return new $267b85717c4872ea$export$5e855264a077e9f(parameters18);
}
function $267b85717c4872ea$export$92549cf6c5f073d4(x6, y7, z5) {
    console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
    return new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2(x6, y7, z5);
}
//
function $267b85717c4872ea$export$9a79fc84ceff9d33(array16, itemSize15) {
    console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
    return new $267b85717c4872ea$export$3d45483f125de856(array16, itemSize15).setUsage($267b85717c4872ea$export$7d5edd11bbbbcdb4);
}
function $267b85717c4872ea$export$ab28f4c47ca1ad8b(array16, itemSize15) {
    console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
    return new $267b85717c4872ea$export$f614dc6b4671f584(array16, itemSize15);
}
function $267b85717c4872ea$export$7d51702c0d415b8a(array16, itemSize15) {
    console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
    return new $267b85717c4872ea$export$f45fc10ff2aaa0ef(array16, itemSize15);
}
function $267b85717c4872ea$export$57eb5ca2747bdd0f(array16, itemSize15) {
    console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
    return new $267b85717c4872ea$export$522e22163c689adf(array16, itemSize15);
}
function $267b85717c4872ea$export$1582b7b61b13c453(array16, itemSize15) {
    console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
    return new $267b85717c4872ea$export$3e147586bc80f717(array16, itemSize15);
}
function $267b85717c4872ea$export$e8d3cf88aef33479(array16, itemSize15) {
    console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
    return new $267b85717c4872ea$export$1673be55325c3b52(array16, itemSize15);
}
function $267b85717c4872ea$export$659e71e3c873d8f1(array16, itemSize15) {
    console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
    return new $267b85717c4872ea$export$5117506a26efbc58(array16, itemSize15);
}
function $267b85717c4872ea$export$41ec08a469164e69(array16, itemSize15) {
    console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
    return new $267b85717c4872ea$export$f86c6826769eb286(array16, itemSize15);
}
function $267b85717c4872ea$export$37933e3b5a4f4103(array16, itemSize15) {
    console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
    return new $267b85717c4872ea$export$8af155dd3ccd7773(array16, itemSize15);
}
function $267b85717c4872ea$export$dd54fdf1e3db8131(array16, itemSize15) {
    console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
    return new $267b85717c4872ea$export$eb3f0288ee857d2b(array16, itemSize15);
}
//
$267b85717c4872ea$export$c94d58bf7a3bdecc.create = function(construct, getPoint) {
    console.log('THREE.Curve.create() has been deprecated');
    construct.prototype = Object.create($267b85717c4872ea$export$c94d58bf7a3bdecc.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
};
//
$267b85717c4872ea$export$49a62d21c8b8d137.prototype.fromPoints = function(points6) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    return this.setFromPoints(points6);
};
//
function $267b85717c4872ea$export$92c868c586268f41(size7) {
    console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
    return new $267b85717c4872ea$export$9f8bf6f3d774afbf(size7);
}
function $267b85717c4872ea$export$58d9d76e841db02a(object3, color27) {
    console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
    return new $267b85717c4872ea$export$f0decbf290d48835(object3, color27);
}
function $267b85717c4872ea$export$6be4918774d6f31a(object3, hex1) {
    console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
    return new $267b85717c4872ea$export$705b5dac58c594af(new $267b85717c4872ea$export$2042389ca5695441(object3.geometry), new $267b85717c4872ea$export$9dd1d6697fbc79f6({
        color: hex1 !== undefined ? hex1 : 16777215
    }));
}
$267b85717c4872ea$export$fcd051d0d393c83f.prototype.setColors = function() {
    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};
$267b85717c4872ea$export$957c2ba4ab7ce56d.prototype.update = function() {
    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};
function $267b85717c4872ea$export$a2aa8d90df67fb1b(object3, hex1) {
    console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
    return new $267b85717c4872ea$export$705b5dac58c594af(new $267b85717c4872ea$export$f05a2fa5988a1b9d(object3.geometry), new $267b85717c4872ea$export$9dd1d6697fbc79f6({
        color: hex1 !== undefined ? hex1 : 16777215
    }));
}
//
$267b85717c4872ea$export$11b02ccb21615fa4.prototype.extractUrlBase = function(url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return $267b85717c4872ea$export$ca1479a24257f322.extractUrlBase(url);
};
$267b85717c4872ea$export$11b02ccb21615fa4.Handlers = {
    add: function() {
        console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
    },
    get: function() {
        console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
    }
};
function $267b85717c4872ea$export$37a9b9c09ffea084(manager14) {
    console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
    return new $267b85717c4872ea$export$de6ef55ef3be029c(manager14);
}
function $267b85717c4872ea$export$458632b0f07b0c82(manager14) {
    console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
    return new $267b85717c4872ea$export$9409c5fcd4393162(manager14);
}
//
$267b85717c4872ea$export$1f2e587aaea1c9d2.prototype.center = function(optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
$267b85717c4872ea$export$1f2e587aaea1c9d2.prototype.empty = function() {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
$267b85717c4872ea$export$1f2e587aaea1c9d2.prototype.isIntersectionBox = function(box1) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box1);
};
$267b85717c4872ea$export$1f2e587aaea1c9d2.prototype.size = function(optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
};
//
$267b85717c4872ea$export$c99edadde72ee706.prototype.center = function(optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
$267b85717c4872ea$export$c99edadde72ee706.prototype.empty = function() {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
$267b85717c4872ea$export$c99edadde72ee706.prototype.isIntersectionBox = function(box1) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box1);
};
$267b85717c4872ea$export$c99edadde72ee706.prototype.isIntersectionSphere = function(sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
};
$267b85717c4872ea$export$c99edadde72ee706.prototype.size = function(optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
};
//
$267b85717c4872ea$export$48b052fa5734fd42.prototype.empty = function() {
    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
};
//
$267b85717c4872ea$export$6ef72105b8c3e2c6.prototype.setFromMatrix = function(m) {
    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
    return this.setFromProjectionMatrix(m);
};
//
$267b85717c4872ea$export$227ad60d21b4b779.prototype.center = function(optionalTarget) {
    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
};
//
$267b85717c4872ea$export$6b1dbb040148d435.prototype.flattenToArrayOffset = function(array16, offset2) {
    console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array16, offset2);
};
$267b85717c4872ea$export$6b1dbb040148d435.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
};
$267b85717c4872ea$export$6b1dbb040148d435.prototype.multiplyVector3Array = function() {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
};
$267b85717c4872ea$export$6b1dbb040148d435.prototype.applyToBufferAttribute = function(attribute) {
    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
    return attribute.applyMatrix3(this);
};
$267b85717c4872ea$export$6b1dbb040148d435.prototype.applyToVector3Array = function() {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
};
$267b85717c4872ea$export$6b1dbb040148d435.prototype.getInverse = function(matrix) {
    console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
};
//
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.extractPosition = function(m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.flattenToArrayOffset = function(array16, offset2) {
    console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
    return this.toArray(array16, offset2);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.getPosition = function() {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new $267b85717c4872ea$export$cbf9fa4ea4e2e3d2().setFromMatrixColumn(this, 3);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.setRotationFromQuaternion = function(q1) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q1);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.multiplyToArray = function() {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.multiplyVector4 = function(vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.multiplyVector3Array = function() {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.rotateAxis = function(v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.crossVector = function(vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.translate = function() {
    console.error('THREE.Matrix4: .translate() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.rotateX = function() {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.rotateY = function() {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.rotateZ = function() {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.rotateByAxis = function() {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.applyToBufferAttribute = function(attribute) {
    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
    return attribute.applyMatrix4(this);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.applyToVector3Array = function() {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.makeFrustum = function(left1, right1, bottom1, top1, near6, far6) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left1, right1, top1, bottom1, near6, far6);
};
$267b85717c4872ea$export$960b1460cb9cd6c9.prototype.getInverse = function(matrix) {
    console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
    return this.copy(matrix).invert();
};
//
$267b85717c4872ea$export$eff7a5260ebddee8.prototype.isIntersectionLine = function(line) {
    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
    return this.intersectsLine(line);
};
//
$267b85717c4872ea$export$8756178d528e80f7.prototype.multiplyVector3 = function(vector) {
    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return vector.applyQuaternion(this);
};
$267b85717c4872ea$export$8756178d528e80f7.prototype.inverse = function() {
    console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
    return this.invert();
};
//
$267b85717c4872ea$export$c0bfd01633e732a2.prototype.isIntersectionBox = function(box1) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box1);
};
$267b85717c4872ea$export$c0bfd01633e732a2.prototype.isIntersectionPlane = function(plane1) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane1);
};
$267b85717c4872ea$export$c0bfd01633e732a2.prototype.isIntersectionSphere = function(sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
};
//
$267b85717c4872ea$export$cc2ce4c411239af4.prototype.area = function() {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
};
$267b85717c4872ea$export$cc2ce4c411239af4.prototype.barycoordFromPoint = function(point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
};
$267b85717c4872ea$export$cc2ce4c411239af4.prototype.midpoint = function(target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
};
$267b85717c4872ea$export$cc2ce4c411239af4.prototypenormal = function(target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
};
$267b85717c4872ea$export$cc2ce4c411239af4.prototype.plane = function(target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
};
$267b85717c4872ea$export$cc2ce4c411239af4.barycoordFromPoint = function(point, a2, b3, c2, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return $267b85717c4872ea$export$cc2ce4c411239af4.getBarycoord(point, a2, b3, c2, target);
};
$267b85717c4872ea$export$cc2ce4c411239af4.normal = function(a2, b3, c2, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return $267b85717c4872ea$export$cc2ce4c411239af4.getNormal(a2, b3, c2, target);
};
//
$267b85717c4872ea$export$5d9987e6723d242f.prototype.extractAllPoints = function(divisions2) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions2);
};
$267b85717c4872ea$export$5d9987e6723d242f.prototype.extrude = function(options5) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new $267b85717c4872ea$export$7dac0f8fbb3b30ab(this, options5);
};
$267b85717c4872ea$export$5d9987e6723d242f.prototype.makeGeometry = function(options5) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new $267b85717c4872ea$export$aacf45bade30a4eb(this, options5);
};
//
$267b85717c4872ea$export$95d9e1e745cc7977.prototype.fromAttribute = function(attribute, index3, offset2) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index3, offset2);
};
$267b85717c4872ea$export$95d9e1e745cc7977.prototype.distanceToManhattan = function(v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
};
$267b85717c4872ea$export$95d9e1e745cc7977.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.setEulerFromRotationMatrix = function() {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.setEulerFromQuaternion = function() {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.getPositionFromMatrix = function(m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.getScaleFromMatrix = function(m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.getColumnFromMatrix = function(index3, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index3);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.applyProjection = function(m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.fromAttribute = function(attribute, index3, offset2) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index3, offset2);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.distanceToManhattan = function(v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
};
$267b85717c4872ea$export$cbf9fa4ea4e2e3d2.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
$267b85717c4872ea$export$14dfcb76afe97063.prototype.fromAttribute = function(attribute, index3, offset2) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index3, offset2);
};
$267b85717c4872ea$export$14dfcb76afe97063.prototype.lengthManhattan = function() {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
};
//
$267b85717c4872ea$export$c8ea94beaa33360.prototype.getChildByName = function(name3) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name3);
};
$267b85717c4872ea$export$c8ea94beaa33360.prototype.renderDepth = function() {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
};
$267b85717c4872ea$export$c8ea94beaa33360.prototype.translate = function(distance2, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance2);
};
$267b85717c4872ea$export$c8ea94beaa33360.prototype.getWorldRotation = function() {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
};
$267b85717c4872ea$export$c8ea94beaa33360.prototype.applyMatrix = function(matrix) {
    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
};
Object.defineProperties($267b85717c4872ea$export$c8ea94beaa33360.prototype, {
    eulerOrder: {
        get: function() {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            return this.rotation.order;
        },
        set: function(value2) {
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
            this.rotation.order = value2;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        },
        set: function() {
            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
        }
    }
});
$267b85717c4872ea$export$4cdb671a7054bbf9.prototype.setDrawMode = function() {
    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
};
Object.defineProperties($267b85717c4872ea$export$4cdb671a7054bbf9.prototype, {
    drawMode: {
        get: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
            return $267b85717c4872ea$export$cb8e90c753659143;
        },
        set: function() {
            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
        }
    }
});
$267b85717c4872ea$export$5d42c2f029f93672.prototype.initBones = function() {
    console.error('THREE.SkinnedMesh: initBones() has been removed.');
};
//
$267b85717c4872ea$export$95bab1c599905cc4.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== undefined) this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
};
//
Object.defineProperties($267b85717c4872ea$export$d5415290bbbd757d.prototype, {
    onlyShadow: {
        set: function() {
            console.warn('THREE.Light: .onlyShadow has been removed.');
        }
    },
    shadowCameraFov: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
            this.shadow.camera.fov = value2;
        }
    },
    shadowCameraLeft: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
            this.shadow.camera.left = value2;
        }
    },
    shadowCameraRight: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
            this.shadow.camera.right = value2;
        }
    },
    shadowCameraTop: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
            this.shadow.camera.top = value2;
        }
    },
    shadowCameraBottom: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
            this.shadow.camera.bottom = value2;
        }
    },
    shadowCameraNear: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
            this.shadow.camera.near = value2;
        }
    },
    shadowCameraFar: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
            this.shadow.camera.far = value2;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
        }
    },
    shadowBias: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
            this.shadow.bias = value2;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
    },
    shadowMapWidth: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
            this.shadow.mapSize.width = value2;
        }
    },
    shadowMapHeight: {
        set: function(value2) {
            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
            this.shadow.mapSize.height = value2;
        }
    }
});
//
Object.defineProperties($267b85717c4872ea$export$3d45483f125de856.prototype, {
    length: {
        get: function() {
            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
            return this.array.length;
        }
    },
    dynamic: {
        get: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            return this.usage === $267b85717c4872ea$export$7d5edd11bbbbcdb4;
        },
        set: function() {
            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
            this.setUsage($267b85717c4872ea$export$7d5edd11bbbbcdb4);
        }
    }
});
$267b85717c4872ea$export$3d45483f125de856.prototype.setDynamic = function(value2) {
    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value2 === true ? $267b85717c4872ea$export$7d5edd11bbbbcdb4 : $267b85717c4872ea$export$ec469a709bf33b5b);
    return this;
};
$267b85717c4872ea$export$3d45483f125de856.prototype.copyIndicesArray = function() {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
}, $267b85717c4872ea$export$3d45483f125de856.prototype.setArray = function() {
    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
};
//
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.addIndex = function(index3) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index3);
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.addAttribute = function(name3, attribute) {
    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
        return this.setAttribute(name3, new $267b85717c4872ea$export$3d45483f125de856(arguments[1], arguments[2]));
    }
    if (name3 === 'index') {
        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
        this.setIndex(attribute);
        return this;
    }
    return this.setAttribute(name3, attribute);
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.addDrawCall = function(start2, count4, indexOffset) {
    if (indexOffset !== undefined) console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start2, count4);
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.clearDrawCalls = function() {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.computeOffsets = function() {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.removeAttribute = function(name3) {
    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
    return this.deleteAttribute(name3);
};
$267b85717c4872ea$export$84a34b4c8ecb6751.prototype.applyMatrix = function(matrix) {
    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
};
Object.defineProperties($267b85717c4872ea$export$84a34b4c8ecb6751.prototype, {
    drawcalls: {
        get: function() {
            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
            return this.groups;
        }
    },
    offsets: {
        get: function() {
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
            return this.groups;
        }
    }
});
$267b85717c4872ea$export$a310785f1020d6c0.prototype.setDynamic = function(value2) {
    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value2 === true ? $267b85717c4872ea$export$7d5edd11bbbbcdb4 : $267b85717c4872ea$export$ec469a709bf33b5b);
    return this;
};
$267b85717c4872ea$export$a310785f1020d6c0.prototype.setArray = function() {
    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
};
//
$267b85717c4872ea$export$7dac0f8fbb3b30ab.prototype.getArrays = function() {
    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
};
$267b85717c4872ea$export$7dac0f8fbb3b30ab.prototype.addShapeList = function() {
    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
};
$267b85717c4872ea$export$7dac0f8fbb3b30ab.prototype.addShape = function() {
    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
};
//
$267b85717c4872ea$export$df6b198c079ba70b.prototype.dispose = function() {
    console.error('THREE.Scene: .dispose() has been removed.');
};
//
$267b85717c4872ea$export$d267c48b1accdfaf.prototype.onUpdate = function() {
    console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
    return this;
};
//
Object.defineProperties($267b85717c4872ea$export$1631e5d26e6ca932.prototype, {
    wrapAround: {
        get: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .wrapAround has been removed.');
        }
    },
    overdraw: {
        get: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        },
        set: function() {
            console.warn('THREE.Material: .overdraw has been removed.');
        }
    },
    wrapRGB: {
        get: function() {
            console.warn('THREE.Material: .wrapRGB has been removed.');
            return new $267b85717c4872ea$export$e4830c8e55b4f80d();
        }
    },
    shading: {
        get: function() {
            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        },
        set: function(value2) {
            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
            this.flatShading = value2 === $267b85717c4872ea$export$f5234beed215aca0;
        }
    },
    stencilMask: {
        get: function() {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            return this.stencilFuncMask;
        },
        set: function(value2) {
            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
            this.stencilFuncMask = value2;
        }
    }
});
Object.defineProperties($267b85717c4872ea$export$2a77b7c526ae5937.prototype, {
    derivatives: {
        get: function() {
            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            return this.extensions.derivatives;
        },
        set: function(value2) {
            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
            this.extensions.derivatives = value2;
        }
    }
});
//
$267b85717c4872ea$export$55c403e650ad28d0.prototype.clearTarget = function(renderTarget1, color27, depth4, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget1);
    this.clear(color27, depth4, stencil);
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.animate = function(callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.getCurrentRenderTarget = function() {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.getMaxAnisotropy = function() {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.getPrecision = function() {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.resetGLState = function() {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsFloatTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsHalfFloatTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsStandardDerivatives = function() {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsCompressedTextureS3TC = function() {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsCompressedTexturePVRTC = function() {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsBlendMinMax = function() {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsVertexTextures = function() {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.supportsInstancedArrays = function() {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.enableScissorTest = function(boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.initMaterial = function() {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.addPrePlugin = function() {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.addPostPlugin = function() {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.updateShadowMap = function() {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.setFaceCulling = function() {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.allocTextureUnit = function() {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.setTexture = function() {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.setTexture2D = function() {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.setTextureCube = function() {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
};
$267b85717c4872ea$export$55c403e650ad28d0.prototype.getActiveMipMapLevel = function() {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
};
Object.defineProperties($267b85717c4872ea$export$55c403e650ad28d0.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
            this.shadowMap.enabled = value2;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
            this.shadowMap.type = value2;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    context: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
            return this.getContext();
        }
    },
    vr: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
            return this.xr;
        }
    },
    gammaInput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
            return false;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
        }
    },
    gammaOutput: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            return false;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
            this.outputEncoding = value2 === true ? $267b85717c4872ea$export$e7c1dc234bb46352 : $267b85717c4872ea$export$b2fb0348530d6a72;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
            return 1;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
        }
    }
});
Object.defineProperties($267b85717c4872ea$var$WebGLShadowMap.prototype, {
    cullFace: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
            return undefined;
        },
        set: function() {
            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
        }
    }
});
function $267b85717c4872ea$export$259065dea6360efc(width12, height14, options5) {
    console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
    return new $267b85717c4872ea$export$48f3d94ab2a784eb(width12, options5);
}
//
Object.defineProperties($267b85717c4872ea$export$aef5a065c75d61ea.prototype, {
    wrapS: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            return this.texture.wrapS;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
            this.texture.wrapS = value2;
        }
    },
    wrapT: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            return this.texture.wrapT;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
            this.texture.wrapT = value2;
        }
    },
    magFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            return this.texture.magFilter;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
            this.texture.magFilter = value2;
        }
    },
    minFilter: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            return this.texture.minFilter;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
            this.texture.minFilter = value2;
        }
    },
    anisotropy: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            return this.texture.anisotropy;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
            this.texture.anisotropy = value2;
        }
    },
    offset: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            return this.texture.offset;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
            this.texture.offset = value2;
        }
    },
    repeat: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            return this.texture.repeat;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
            this.texture.repeat = value2;
        }
    },
    format: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            return this.texture.format;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
            this.texture.format = value2;
        }
    },
    type: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            return this.texture.type;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
            this.texture.type = value2;
        }
    },
    generateMipmaps: {
        get: function() {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            return this.texture.generateMipmaps;
        },
        set: function(value2) {
            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
            this.texture.generateMipmaps = value2;
        }
    }
});
//
$267b85717c4872ea$export$aea72bdf6b67b9.prototype.load = function(file) {
    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
    const scope7 = this;
    const audioLoader = new $267b85717c4872ea$export$ad9e97c8f8cbaf8d();
    audioLoader.load(file, function(buffer2) {
        scope7.setBuffer(buffer2);
    });
    return this;
};
$267b85717c4872ea$export$6a674a0986333d77.prototype.getData = function() {
    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
    return this.getFrequencyData();
};
//
$267b85717c4872ea$export$62bcc2046b614bc8.prototype.updateCubeMap = function(renderer2, scene) {
    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
    return this.update(renderer2, scene);
};
$267b85717c4872ea$export$62bcc2046b614bc8.prototype.clear = function(renderer2, color27, depth4, stencil) {
    console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
    return this.renderTarget.clear(renderer2, color27, depth4, stencil);
};
$267b85717c4872ea$export$efc8126a946586b9.crossOrigin = undefined;
$267b85717c4872ea$export$efc8126a946586b9.loadTexture = function(url, mapping7, onLoad2, onError2) {
    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
    const loader = new $267b85717c4872ea$export$b1cf4a115f3af368();
    loader.setCrossOrigin(this.crossOrigin);
    const texture2 = loader.load(url, onLoad2, undefined, onError2);
    if (mapping7) texture2.mapping = mapping7;
    return texture2;
};
$267b85717c4872ea$export$efc8126a946586b9.loadTextureCube = function(urls, mapping7, onLoad2, onError2) {
    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
    const loader = new $267b85717c4872ea$export$ef8b534c169b03e2();
    loader.setCrossOrigin(this.crossOrigin);
    const texture2 = loader.load(urls, onLoad2, undefined, onError2);
    if (mapping7) texture2.mapping = mapping7;
    return texture2;
};
$267b85717c4872ea$export$efc8126a946586b9.loadCompressedTexture = function() {
    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};
$267b85717c4872ea$export$efc8126a946586b9.loadCompressedTextureCube = function() {
    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
};
//
function $267b85717c4872ea$export$5ec9d36e6df9165b() {
    console.error('THREE.CanvasRenderer has been removed');
}
//
function $267b85717c4872ea$export$3b694858642c5ea1() {
    console.error('THREE.JSONLoader has been removed.');
}
//
const $267b85717c4872ea$export$89d2e3e3ff31ca61 = {
    createMultiMaterialObject: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    detach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    },
    attach: function() {
        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
    }
};
//
function $267b85717c4872ea$export$90a22fbd66711a73() {
    console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') /* eslint-disable no-undef */ __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
        revision: $267b85717c4872ea$export$fa32c300549af6a5
    }
}));
if (typeof window !== 'undefined') {
    if (window.__THREE__) console.warn('WARNING: Multiple instances of Three.js being imported.');
    else window.__THREE__ = $267b85717c4872ea$export$fa32c300549af6a5;
}


//scene and camera variables
const $b8d6fa9fc2446427$var$scene = new $267b85717c4872ea$export$df6b198c079ba70b();
const $b8d6fa9fc2446427$var$camera = new $267b85717c4872ea$export$95bab1c599905cc4(90, window.innerWidth / window.innerHeight, 0.1, 1000);
$b8d6fa9fc2446427$var$camera.position.z = 5;
//renderer
const $b8d6fa9fc2446427$var$renderer = new $267b85717c4872ea$export$55c403e650ad28d0();
$b8d6fa9fc2446427$var$renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild($b8d6fa9fc2446427$var$renderer.domElement);
//raycasting for mouse
const $b8d6fa9fc2446427$var$raycaster = new $267b85717c4872ea$export$8484abb50025d7ed();
const $b8d6fa9fc2446427$var$mouse = new $267b85717c4872ea$export$95d9e1e745cc7977();
/* Target variables */ //for aim report
var $b8d6fa9fc2446427$var$targetList = [];
var $b8d6fa9fc2446427$var$targetsHit = 0;
var $b8d6fa9fc2446427$var$clicks = 0;
//add first circle target
var $b8d6fa9fc2446427$var$geometry = new $267b85717c4872ea$export$7d8d1abfdf118042(0.1, 50);
var $b8d6fa9fc2446427$var$material = new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
    color: 16777215
});
var $b8d6fa9fc2446427$var$target = new $267b85717c4872ea$export$4cdb671a7054bbf9($b8d6fa9fc2446427$var$geometry, $b8d6fa9fc2446427$var$material);
//for random positioning
var $b8d6fa9fc2446427$var$x = 0;
var $b8d6fa9fc2446427$var$y = 0;
//add target to scene
$b8d6fa9fc2446427$var$scene.add($b8d6fa9fc2446427$var$target);
$b8d6fa9fc2446427$var$targetList.push($b8d6fa9fc2446427$var$target);
/* End of Target variables */ //timer
var $b8d6fa9fc2446427$var$time = "|";
var $b8d6fa9fc2446427$var$endTime = "|";
const $b8d6fa9fc2446427$var$SECONDS = 1000;
//render the screen
function $b8d6fa9fc2446427$var$render() {
    //make sure there is only one target, and stop after 10 are hit
    if ($b8d6fa9fc2446427$var$targetList.length < 1 && $b8d6fa9fc2446427$var$targetsHit < 10) {
        //calculate psuedo random position between (4, 4) and (-4, -4)
        $b8d6fa9fc2446427$var$x = Math.floor(Math.random() * 9) - 4;
        $b8d6fa9fc2446427$var$y = Math.floor(Math.random() * 9) - 4;
        //create a new target if hit
        $b8d6fa9fc2446427$var$geometry = new $267b85717c4872ea$export$7d8d1abfdf118042(0.1, 50);
        $b8d6fa9fc2446427$var$material = new $267b85717c4872ea$export$f191b8c5dbd3d9f9({
            color: 16777215
        });
        $b8d6fa9fc2446427$var$target = new $267b85717c4872ea$export$4cdb671a7054bbf9($b8d6fa9fc2446427$var$geometry, $b8d6fa9fc2446427$var$material);
        $b8d6fa9fc2446427$var$target.position.x = $b8d6fa9fc2446427$var$x;
        $b8d6fa9fc2446427$var$target.position.y = $b8d6fa9fc2446427$var$y;
        $b8d6fa9fc2446427$var$targetList.push($b8d6fa9fc2446427$var$target);
        $b8d6fa9fc2446427$var$scene.add($b8d6fa9fc2446427$var$target);
    }
    //if 10 targets hit, report stats
    if ($b8d6fa9fc2446427$var$targetsHit >= 10) {
        //stop timer
        $b8d6fa9fc2446427$var$endTime = new Date();
        $b8d6fa9fc2446427$var$endTime = $b8d6fa9fc2446427$var$endTime.getTime() / $b8d6fa9fc2446427$var$SECONDS;
        //get total time
        let totalTime = $b8d6fa9fc2446427$var$endTime - $b8d6fa9fc2446427$var$time;
        alert("You hit " + $b8d6fa9fc2446427$var$targetsHit + "/" + $b8d6fa9fc2446427$var$clicks + " shots in: " + totalTime.toString().substring(0, 6) + " seconds");
        //reset game/timer
        $b8d6fa9fc2446427$var$clicks = 0;
        $b8d6fa9fc2446427$var$targetsHit = 0;
        $b8d6fa9fc2446427$var$time = "|";
        $b8d6fa9fc2446427$var$endTime = "|";
    }
}
//animation loop
function $b8d6fa9fc2446427$var$animate() {
    requestAnimationFrame($b8d6fa9fc2446427$var$animate);
    $b8d6fa9fc2446427$var$render();
    $b8d6fa9fc2446427$var$renderer.render($b8d6fa9fc2446427$var$scene, $b8d6fa9fc2446427$var$camera);
}
$b8d6fa9fc2446427$var$animate();
//when mouse is clicked
function $b8d6fa9fc2446427$var$onDocumentMouseDown(event) {
    event.preventDefault();
    //start timer after first click
    if ($b8d6fa9fc2446427$var$time == "|") {
        $b8d6fa9fc2446427$var$time = new Date();
        $b8d6fa9fc2446427$var$time = $b8d6fa9fc2446427$var$time.getTime() / $b8d6fa9fc2446427$var$SECONDS;
    }
    $b8d6fa9fc2446427$var$clicks += 1;
    //update mouse location
    $b8d6fa9fc2446427$var$mouse.x = event.clientX / $b8d6fa9fc2446427$var$renderer.domElement.width * 2 - 1;
    $b8d6fa9fc2446427$var$mouse.y = -(event.clientY / $b8d6fa9fc2446427$var$renderer.domElement.height) * 2 + 1;
    $b8d6fa9fc2446427$var$raycaster.setFromCamera($b8d6fa9fc2446427$var$mouse, $b8d6fa9fc2446427$var$camera);
    //was a target hit
    var intersects = $b8d6fa9fc2446427$var$raycaster.intersectObject($b8d6fa9fc2446427$var$target);
    for(let i = 0; i < intersects.length; i++)if (intersects[i].object == $b8d6fa9fc2446427$var$target) {
        $b8d6fa9fc2446427$var$scene.remove($b8d6fa9fc2446427$var$target);
        $b8d6fa9fc2446427$var$targetList.pop();
        $b8d6fa9fc2446427$var$targetsHit += 1;
    }
    $b8d6fa9fc2446427$var$renderer.render($b8d6fa9fc2446427$var$scene, $b8d6fa9fc2446427$var$camera);
}
window.addEventListener('mousedown', $b8d6fa9fc2446427$var$onDocumentMouseDown, false);


//# sourceMappingURL=three.js.map
